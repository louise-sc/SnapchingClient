{"version":3,"sources":["C:/SnapChingWebSite/SnapchingClient/node_modules/ngx-page-scroll-core/fesm5/ngx-page-scroll-core.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0CAg0B0C,AAKpC;;;;;;;;;;;;;;;;kCAKmO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA+CnO;;;;;;;;;;;;;;gDAQA","file":"ngx-page-scroll-core.js","sourcesContent":["import { InjectionToken, isDevMode, Injectable, Inject, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';\nimport { __assign } from 'tslib';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * An Interface specifying the possible options to be passed into the newInstance() factory method\n * @record\n */\nfunction PageScrollOptions() { }\nif (false) {\n    /**\n     * The document object of the current app\n     * @type {?}\n     */\n    PageScrollOptions.prototype.document;\n    /**\n     * A specification of the DOM element to scroll to. Either a string referring to an\n     * element using a valid css selector (`#target`, `.class`, `div.class`) or a HTMLElement\n     * that is attached to the document's DOM tree.\n     * @type {?}\n     */\n    PageScrollOptions.prototype.scrollTarget;\n    /**\n     * Array of HTMLElements or the body object that should be manipulated while performing\n     * the scroll animation.\n     * @type {?|undefined}\n     */\n    PageScrollOptions.prototype.scrollViews;\n    /**\n     * Maximum speed to be used for the scroll animation. Only taken\n     * into account of no duration is provided\n     * @type {?|undefined}\n     */\n    PageScrollOptions.prototype.speed;\n    /**\n     * A listener to be called whenever the scroll animation stops\n     * @type {?|undefined}\n     */\n    PageScrollOptions.prototype.scrollFinishListener;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.namespace;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.verticalScrolling;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.duration;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.scrollOffset;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.advancedInlineOffsetCalculation;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.interruptEvents;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.interruptKeys;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.interruptible;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.scrollInView;\n    /** @type {?|undefined} */\n    PageScrollOptions.prototype.easingLogic;\n}\n/**\n * Represents a scrolling action\n */\nvar  /**\n * Represents a scrolling action\n */\nPageScrollInstance = /** @class */ (function () {\n    /**\n     * Private constructor, requires the properties assumed to be the bare minimum.\n     * Use the factory methods to create instances:\n     *      {@link PageScrollService#create}\n     */\n    function PageScrollInstance(pageScrollOptions) {\n        /**\n         * These properties will be set/manipulated if the scroll animation starts\n         */\n        /* The initial value of the scrollTop or scrollLeft position when the animation starts */\n        this.startScrollPosition = 0;\n        /* Whether an interrupt listener is attached to the body or not */\n        this.interruptListenersAttached = false;\n        /* References to the timer instance that is used to perform the scroll animation to be\n           able to clear it on animation end*/\n        this.timer = null;\n        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {\n            pageScrollOptions.scrollViews = [\n                pageScrollOptions.document.documentElement,\n                pageScrollOptions.document.body,\n                pageScrollOptions.document.body.parentNode,\n            ];\n            this.isInlineScrolling = false;\n        }\n        else {\n            this.isInlineScrolling = true;\n        }\n        this.pageScrollOptions = pageScrollOptions;\n    }\n    /**\n     * @private\n     * @param {?} pageScrollOptions\n     * @param {?} scrollTargetElement\n     * @return {?}\n     */\n    PageScrollInstance.getScrollingTargetPosition = /**\n     * @private\n     * @param {?} pageScrollOptions\n     * @param {?} scrollTargetElement\n     * @return {?}\n     */\n    function (pageScrollOptions, scrollTargetElement) {\n        /** @type {?} */\n        var body = pageScrollOptions.document.body;\n        /** @type {?} */\n        var docEl = pageScrollOptions.document.documentElement;\n        /** @type {?} */\n        var windowPageYOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageYOffset || undefined;\n        /** @type {?} */\n        var windowPageXOffset = pageScrollOptions.document.defaultView &&\n            pageScrollOptions.document.defaultView.pageXOffset || undefined;\n        /** @type {?} */\n        var scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;\n        /** @type {?} */\n        var scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;\n        /** @type {?} */\n        var clientTop = docEl.clientTop || body.clientTop || 0;\n        /** @type {?} */\n        var clientLeft = docEl.clientLeft || body.clientLeft || 0;\n        if (scrollTargetElement === undefined || scrollTargetElement === null) {\n            // No element found, so return the current position to not cause any change in scroll position\n            return { top: scrollTop, left: scrollLeft };\n        }\n        /** @type {?} */\n        var box = scrollTargetElement.getBoundingClientRect();\n        /** @type {?} */\n        var top = box.top + scrollTop - clientTop;\n        /** @type {?} */\n        var left = box.left + scrollLeft - clientLeft;\n        return { top: Math.round(top), left: Math.round(left) };\n    };\n    /**\n     * @private\n     * @param {?} pageScrollOptions\n     * @param {?} scrollTargetElement\n     * @return {?}\n     */\n    PageScrollInstance.getInlineScrollingTargetPosition = /**\n     * @private\n     * @param {?} pageScrollOptions\n     * @param {?} scrollTargetElement\n     * @return {?}\n     */\n    function (pageScrollOptions, scrollTargetElement) {\n        /** @type {?} */\n        var position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };\n        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {\n            /** @type {?} */\n            var accumulatedParentsPos = { top: 0, left: 0 };\n            // not named window to make sure we're not getting the global window variable by accident\n            /** @type {?} */\n            var theWindow = scrollTargetElement.ownerDocument.defaultView;\n            /** @type {?} */\n            var parentFound = false;\n            // Start parent is the immediate parent\n            /** @type {?} */\n            var parent_1 = scrollTargetElement.parentElement;\n            // Iterate upwards all parents\n            while (!parentFound && parent_1 !== undefined && parent_1 !== null) {\n                if (theWindow.getComputedStyle(parent_1).getPropertyValue('position') === 'relative') {\n                    accumulatedParentsPos.top += parent_1.offsetTop;\n                    accumulatedParentsPos.left += parent_1.offsetLeft;\n                }\n                // Next iteration\n                parent_1 = parent_1.parentElement;\n                parentFound = parent_1 === pageScrollOptions.scrollViews[0];\n            }\n            if (parentFound) {\n                // Only use the results if we found the parent, otherwise we accumulated too much anyway\n                position.top += accumulatedParentsPos.top;\n                position.left += accumulatedParentsPos.left;\n            }\n            else {\n                /* TODO Uncomment\n                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {\n                  console.warn('Unable to find nested scrolling targets parent!');\n                }*/\n            }\n        }\n        return position;\n    };\n    /**\n     * @param {?} scrollingView\n     * @return {?}\n     */\n    PageScrollInstance.prototype.getScrollPropertyValue = /**\n     * @param {?} scrollingView\n     * @return {?}\n     */\n    function (scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.scrollLeft;\n        }\n        return scrollingView.scrollTop;\n    };\n    /**\n     * @param {?} scrollingView\n     * @return {?}\n     */\n    PageScrollInstance.prototype.getScrollClientPropertyValue = /**\n     * @param {?} scrollingView\n     * @return {?}\n     */\n    function (scrollingView) {\n        if (!this.pageScrollOptions.verticalScrolling) {\n            return scrollingView.clientWidth;\n        }\n        return scrollingView.clientHeight;\n    };\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     */\n    /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     * @return {?}\n     */\n    PageScrollInstance.prototype.extractScrollTargetPosition = /**\n     * Extract the exact location of the scrollTarget element.\n     *\n     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be\n     * a string like \"#heading2\", then this method returns the corresponding DOM element for that id.\n     *\n     * @return {?}\n     */\n    function () {\n        /** @type {?} */\n        var scrollTargetElement = this.getScrollTargetElement();\n        if (scrollTargetElement === null || scrollTargetElement === undefined) {\n            // Scroll target not found\n            return { top: NaN, left: NaN };\n        }\n        if (this.isInlineScrolling) {\n            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n        }\n        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);\n    };\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     */\n    /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     * @return {?}\n     */\n    PageScrollInstance.prototype.getCurrentOffset = /**\n     * Get the top offset of the scroll animation.\n     * This automatically takes the offset location of the scrolling container/scrolling view\n     * into account (for nested/inline scrolling).\n     * @return {?}\n     */\n    function () {\n        return this.pageScrollOptions.scrollOffset;\n    };\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @param {?} position\n     * @return {?} true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    PageScrollInstance.prototype.setScrollPosition = /**\n     * Sets the \"scrollTop\" or \"scrollLeft\" property for all scrollViews to the provided value\n     * @param {?} position\n     * @return {?} true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.\n     *          false if it failed for all ScrollViews, meaning that we should stop the animation\n     *          (probably because we're at the end of the scrolling region)\n     */\n    function (position) {\n        var _this = this;\n        // Set the new scrollTop/scrollLeft to all scrollViews elements\n        return this.pageScrollOptions.scrollViews.reduce((/**\n         * @param {?} oneAlreadyWorked\n         * @param {?} scrollingView\n         * @return {?}\n         */\n        function (oneAlreadyWorked, scrollingView) {\n            /** @type {?} */\n            var startScrollPropertyValue = _this.getScrollPropertyValue(scrollingView);\n            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {\n                /** @type {?} */\n                var scrollDistance = Math.abs(startScrollPropertyValue - position);\n                // The movement we need to perform is less than 2px\n                // This we consider a small movement which some browser may not perform when\n                // changing the scrollTop/scrollLeft property\n                // Thus in this cases we do not stop the scroll animation, although setting the\n                // scrollTop/scrollLeft value \"fails\"\n                /** @type {?} */\n                var isSmallMovement = scrollDistance < _this.pageScrollOptions._minScrollDistance;\n                if (!_this.pageScrollOptions.verticalScrolling) {\n                    scrollingView.scrollLeft = position;\n                }\n                else {\n                    scrollingView.scrollTop = position;\n                }\n                // Return true if setting the new scrollTop/scrollLeft value worked\n                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the\n                // desired scrollTop/scrollLeft than before (it might not be exactly the value we\n                // set due to dpi or rounding irregularities)\n                if (isSmallMovement || scrollDistance > Math.abs(_this.getScrollPropertyValue(scrollingView) - position)) {\n                    return true;\n                }\n            }\n            return oneAlreadyWorked;\n        }), false);\n    };\n    /**\n     * Trigger firing a animation finish event\n     * @param value Whether the animation finished at the target (true) or got interrupted (false)\n     */\n    /**\n     * Trigger firing a animation finish event\n     * @param {?} value Whether the animation finished at the target (true) or got interrupted (false)\n     * @return {?}\n     */\n    PageScrollInstance.prototype.fireEvent = /**\n     * Trigger firing a animation finish event\n     * @param {?} value Whether the animation finished at the target (true) or got interrupted (false)\n     * @return {?}\n     */\n    function (value) {\n        if (this.pageScrollOptions.scrollFinishListener) {\n            this.pageScrollOptions.scrollFinishListener.emit(value);\n        }\n    };\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     */\n    /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     * @param {?} interruptReporter\n     * @return {?}\n     */\n    PageScrollInstance.prototype.attachInterruptListeners = /**\n     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter\n     * will be called if any of the attached events is fired.\n     *\n     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.\n     * @param {?} interruptReporter\n     * @return {?}\n     */\n    function (interruptReporter) {\n        var _this = this;\n        if (this.interruptListenersAttached) {\n            // Detach possibly existing listeners first\n            this.detachInterruptListeners();\n        }\n        this.interruptListener = (/**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) {\n            interruptReporter.report(event, _this);\n        });\n        this.pageScrollOptions.interruptEvents.forEach((/**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) { return _this.pageScrollOptions.document.body.addEventListener(event, _this.interruptListener); }));\n        this.interruptListenersAttached = true;\n    };\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     */\n    /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     * @return {?}\n     */\n    PageScrollInstance.prototype.detachInterruptListeners = /**\n     * Remove event listeners from the body and stop listening for events that might be treated as \"animation\n     * interrupt\" events.\n     * @return {?}\n     */\n    function () {\n        var _this = this;\n        this.pageScrollOptions.interruptEvents.forEach((/**\n         * @param {?} event\n         * @return {?}\n         */\n        function (event) { return _this.pageScrollOptions.document.body.removeEventListener(event, _this.interruptListener); }));\n        this.interruptListenersAttached = false;\n    };\n    /**\n     * @private\n     * @return {?}\n     */\n    PageScrollInstance.prototype.getScrollTargetElement = /**\n     * @private\n     * @return {?}\n     */\n    function () {\n        if (typeof this.pageScrollOptions.scrollTarget === 'string') {\n            /** @type {?} */\n            var targetSelector = (/** @type {?} */ (this.pageScrollOptions.scrollTarget));\n            if (targetSelector.match(/^#[^\\s]+$/g) !== null) {\n                // It's an id selector and a valid id, as it does not contain any white space characters\n                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));\n            }\n            return (/** @type {?} */ (this.pageScrollOptions.document.querySelector(targetSelector)));\n        }\n        return (/** @type {?} */ (this.pageScrollOptions.scrollTarget));\n    };\n    return PageScrollInstance;\n}());\nif (false) {\n    /** @type {?} */\n    PageScrollInstance.prototype.pageScrollOptions;\n    /**\n     * @type {?}\n     * @private\n     */\n    PageScrollInstance.prototype.isInlineScrolling;\n    /**\n     * @type {?}\n     * @private\n     */\n    PageScrollInstance.prototype.interruptListener;\n    /**\n     * These properties will be set/manipulated if the scroll animation starts\n     * @type {?}\n     */\n    PageScrollInstance.prototype.startScrollPosition;\n    /** @type {?} */\n    PageScrollInstance.prototype.targetScrollPosition;\n    /** @type {?} */\n    PageScrollInstance.prototype.distanceToScroll;\n    /** @type {?} */\n    PageScrollInstance.prototype.startTime;\n    /** @type {?} */\n    PageScrollInstance.prototype.endTime;\n    /** @type {?} */\n    PageScrollInstance.prototype.executionDuration;\n    /** @type {?} */\n    PageScrollInstance.prototype.interruptListenersAttached;\n    /** @type {?} */\n    PageScrollInstance.prototype.timer;\n}\n/**\n * An Interface a listener should implement to be notified about possible interrupt events\n * that happened due to user interaction while a scroll animation takes place.\n *\n * The PageScrollService provides an implementation to a PageScrollInstance to be notified\n * about scroll animation interrupts and stop related animations.\n * @record\n */\nfunction InterruptReporter() { }\nif (false) {\n    /**\n     * @param {?} event\n     * @param {?} pageScrollInstance\n     * @return {?}\n     */\n    InterruptReporter.prototype.report = function (event, pageScrollInstance) { };\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar NGXPS_CONFIG = new InjectionToken('ngxps_config');\nvar ɵ0 = /**\n * @param {?} t\n * @param {?} b\n * @param {?} c\n * @param {?} d\n * @return {?}\n */\nfunction (t, b, c, d) {\n    // Linear easing\n    return c * t / d + b;\n};\n/** @type {?} */\nvar defaultPageScrollConfig = {\n    _interval: 10,\n    _minScrollDistance: 2,\n    _logLevel: 1,\n    namespace: 'default',\n    verticalScrolling: true,\n    duration: 1250,\n    scrollOffset: 0,\n    advancedInlineOffsetCalculation: false,\n    interruptEvents: ['mousedown', 'wheel', 'DOMMouseScroll', 'mousewheel', 'keyup', 'touchmove'],\n    interruptKeys: [' ', 'Escape', 'Tab', 'Enter', 'PageUp', 'PageDown', 'Home', 'End', 'ArrowUp', 'ArrowRight', 'ArrowLeft', 'ArrowDown'],\n    interruptible: true,\n    scrollInView: true,\n    easingLogic: (ɵ0),\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar PageScrollService = /** @class */ (function () {\n    function PageScrollService(customConfig) {\n        var _this = this;\n        this.runningInstances = [];\n        this.onInterrupted = {\n            report: (/**\n             * @param {?} event\n             * @param {?} pageScrollInstance\n             * @return {?}\n             */\n            function (event, pageScrollInstance) {\n                if (!pageScrollInstance.pageScrollOptions.interruptible) {\n                    // Non-interruptible anyway, so do not stop anything\n                    return;\n                }\n                /** @type {?} */\n                var shouldStop = true;\n                if (event.type === 'keyup') {\n                    // Only stop if specific keys have been pressed, for all others don't stop anything\n                    if (_this.config.interruptKeys.indexOf(((/** @type {?} */ (event))).key) === -1) {\n                        // The pressed key is not in the list of interrupting keys\n                        shouldStop = false;\n                    }\n                }\n                else if (event.type === 'mousedown') {\n                    // For mousedown events we only stop the scroll animation of the mouse has\n                    // been clicked inside the scrolling container\n                    if (!pageScrollInstance.pageScrollOptions.scrollViews.some((/**\n                     * @param {?} scrollingView\n                     * @return {?}\n                     */\n                    function (scrollingView) { return scrollingView.contains((/** @type {?} */ (event.target))); }))) {\n                        // Mouse clicked an element which is not inside any of the the scrolling containers\n                        shouldStop = false;\n                    }\n                }\n                if (shouldStop) {\n                    _this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n                }\n            }),\n        };\n        this.config = __assign({}, defaultPageScrollConfig, customConfig);\n        if (PageScrollService.instanceCounter > 0 &&\n            (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode()))) {\n            console.warn('An instance of PageScrollService already exists, usually ' +\n                'including one provider should be enough, so double check.');\n        }\n        PageScrollService.instanceCounter++;\n    }\n    /**\n     * @private\n     * @param {?} interrupted\n     * @param {?} pageScrollInstance\n     * @return {?}\n     */\n    PageScrollService.prototype.stopInternal = /**\n     * @private\n     * @param {?} interrupted\n     * @param {?} pageScrollInstance\n     * @return {?}\n     */\n    function (interrupted, pageScrollInstance) {\n        /** @type {?} */\n        var index = this.runningInstances.indexOf(pageScrollInstance);\n        if (index >= 0) {\n            this.runningInstances.splice(index, 1);\n        }\n        if (pageScrollInstance.interruptListenersAttached) {\n            pageScrollInstance.detachInterruptListeners();\n        }\n        if (pageScrollInstance.timer) {\n            // Clear/Stop the timer\n            clearInterval(pageScrollInstance.timer);\n            // Clear the reference to this timer\n            pageScrollInstance.timer = undefined;\n            pageScrollInstance.fireEvent(!interrupted);\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    PageScrollService.prototype.create = /**\n     * @param {?} options\n     * @return {?}\n     */\n    function (options) {\n        return new PageScrollInstance((/** @type {?} */ (__assign({}, this.config, options))));\n    };\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    /**\n     * Start a scroll animation. All properties of the animation are stored in the given {\\@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     * @param {?} pageScrollInstance\n     * @return {?}\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    PageScrollService.prototype.start = /**\n     * Start a scroll animation. All properties of the animation are stored in the given {\\@link PageScrollInstance} object.\n     *\n     * This is the core functionality of the whole library.\n     * @param {?} pageScrollInstance\n     * @return {?}\n     */\n    // tslint:disable-next-line:cyclomatic-complexity\n    function (pageScrollInstance) {\n        var _this = this;\n        // Merge the default options in the pageScrollInstance options\n        pageScrollInstance.pageScrollOptions = (/** @type {?} */ (__assign({}, this.config, pageScrollInstance.pageScrollOptions)));\n        // Stop all possibly running scroll animations in the same namespace\n        this.stopAll(pageScrollInstance.pageScrollOptions.namespace);\n        if (pageScrollInstance.pageScrollOptions.scrollViews === null || pageScrollInstance.pageScrollOptions.scrollViews.length === 0) {\n            // No scrollViews specified, thus we can't animate anything\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.warn('No scrollViews specified, thus ngx-page-scroll does not know which DOM elements to scroll');\n            }\n            return;\n        }\n        /** @type {?} */\n        var startScrollPositionFound = false;\n        /** @type {?} */\n        var scrollRange = pageScrollInstance.getScrollClientPropertyValue(pageScrollInstance.pageScrollOptions.scrollViews[0]);\n        // Reset start scroll position to 0. If any of the scrollViews has a different one, it will be extracted next\n        pageScrollInstance.startScrollPosition = 0;\n        // Get the start scroll position from the scrollViews (e.g. if the user already scrolled down the content)\n        pageScrollInstance.pageScrollOptions.scrollViews.forEach((/**\n         * @param {?} scrollingView\n         * @return {?}\n         */\n        function (scrollingView) {\n            if (scrollingView === undefined || scrollingView === null) {\n                return;\n            }\n            // Get the scrollTop or scrollLeft value of the first scrollingView that returns a value for its \"scrollTop\"\n            // or \"scrollLeft\" property that is not undefined and unequal to 0\n            /** @type {?} */\n            var scrollPosition = pageScrollInstance.getScrollPropertyValue(scrollingView);\n            if (!startScrollPositionFound && scrollPosition) {\n                // We found a scrollingView that does not have scrollTop or scrollLeft 0\n                // Return the scroll position value, as this will be our startScrollPosition\n                pageScrollInstance.startScrollPosition = scrollPosition;\n                startScrollPositionFound = true;\n                // Remember te scrollRange of this scrollingView\n                scrollRange = pageScrollInstance.getScrollClientPropertyValue(scrollingView);\n            }\n        }));\n        /** @type {?} */\n        var pageScrollOffset = pageScrollInstance.getCurrentOffset();\n        // Calculate the target position that the scroll animation should go to\n        /** @type {?} */\n        var scrollTargetPosition = pageScrollInstance.extractScrollTargetPosition();\n        pageScrollInstance.targetScrollPosition = Math.round((pageScrollInstance.pageScrollOptions.verticalScrolling ? scrollTargetPosition.top : scrollTargetPosition.left) - pageScrollOffset);\n        // Calculate the distance we need to go in total\n        pageScrollInstance.distanceToScroll = pageScrollInstance.targetScrollPosition - pageScrollInstance.startScrollPosition;\n        if (isNaN(pageScrollInstance.distanceToScroll)) {\n            // We weren't able to find the target position, maybe the element does not exist?\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                console.log('Scrolling not possible, as we can\\'t find the specified target');\n            }\n            pageScrollInstance.fireEvent(false);\n            return;\n        }\n        // We're at the final destination already\n        // OR we need to scroll down but are already at the end\n        // OR we need to scroll up but are at the top already\n        /** @type {?} */\n        var allReadyAtDestination = Math.abs(pageScrollInstance.distanceToScroll) < pageScrollInstance.pageScrollOptions._minScrollDistance;\n        // Check how long we need to scroll if a speed option is given\n        // Default executionDuration is the specified duration\n        pageScrollInstance.executionDuration = pageScrollInstance.pageScrollOptions.duration;\n        // Maybe we need to pay attention to the speed option?\n        if ((pageScrollInstance.pageScrollOptions.speed !== undefined && pageScrollInstance.pageScrollOptions.speed !== null) &&\n            (pageScrollInstance.pageScrollOptions.duration === undefined || pageScrollInstance.pageScrollOptions.duration === null)) {\n            // Speed option is set and no duration => calculate duration based on speed and scroll distance\n            pageScrollInstance.executionDuration =\n                Math.abs(pageScrollInstance.distanceToScroll) / pageScrollInstance.pageScrollOptions.speed * 1000;\n        }\n        // We should go there directly, as our \"animation\" would have one big step\n        // only anyway and this way we save the interval stuff\n        /** @type {?} */\n        var tooShortInterval = pageScrollInstance.executionDuration <= pageScrollInstance.pageScrollOptions._interval;\n        if (allReadyAtDestination || tooShortInterval) {\n            if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                if (allReadyAtDestination) {\n                    console.log('Scrolling not possible, as we can\\'t get any closer to the destination');\n                }\n                else {\n                    console.log('Scroll duration shorter that interval length, jumping to target');\n                }\n            }\n            pageScrollInstance.setScrollPosition(pageScrollInstance.targetScrollPosition);\n            pageScrollInstance.fireEvent(true);\n            return;\n        }\n        if (!pageScrollInstance.pageScrollOptions.scrollInView) {\n            /** @type {?} */\n            var alreadyInView = pageScrollInstance.targetScrollPosition > pageScrollInstance.startScrollPosition &&\n                pageScrollInstance.targetScrollPosition <= pageScrollInstance.startScrollPosition + scrollRange;\n            if (alreadyInView) {\n                if (this.config._logLevel >= 2 || (this.config._logLevel >= 1 && isDevMode())) {\n                    console.log('Not scrolling, as target already in view');\n                }\n                pageScrollInstance.fireEvent(true);\n                return;\n            }\n        }\n        // Register the interrupt listeners if we want an interruptible scroll animation\n        if (pageScrollInstance.pageScrollOptions.interruptible) {\n            pageScrollInstance.attachInterruptListeners(this.onInterrupted);\n        }\n        // Let's get started, get the start time...\n        pageScrollInstance.startTime = new Date().getTime();\n        // .. and calculate the end time (when we need to finish at last)\n        pageScrollInstance.endTime = pageScrollInstance.startTime + pageScrollInstance.executionDuration;\n        pageScrollInstance.timer = setInterval((/**\n         * @param {?} _pageScrollInstance\n         * @return {?}\n         */\n        function (_pageScrollInstance) {\n            // Take the current time\n            /** @type {?} */\n            var currentTime = new Date().getTime();\n            // Determine the new scroll position\n            /** @type {?} */\n            var newScrollPosition;\n            /** @type {?} */\n            var stopNow = false;\n            if (_pageScrollInstance.endTime <= currentTime) {\n                // We're over the time already, so go the targetScrollPosition (aka destination)\n                newScrollPosition = _pageScrollInstance.targetScrollPosition;\n                stopNow = true;\n            }\n            else {\n                // Calculate the scroll position based on the current time using the easing function\n                newScrollPosition = Math.round(_pageScrollInstance.pageScrollOptions.easingLogic(currentTime - _pageScrollInstance.startTime, _pageScrollInstance.startScrollPosition, _pageScrollInstance.distanceToScroll, _pageScrollInstance.executionDuration));\n            }\n            if (_this.config._logLevel >= 5 && isDevMode()) {\n                console.warn('Scroll Position: ' + newScrollPosition);\n            }\n            // Set the new scrollPosition to all scrollViews elements\n            if (!_pageScrollInstance.setScrollPosition(newScrollPosition)) {\n                // Setting the new scrollTop/scrollLeft value failed for all ScrollViews\n                // early stop the scroll animation to save resources\n                stopNow = true;\n            }\n            // At the end do the internal stop maintenance and fire the pageScrollFinish event\n            // (otherwise the event might arrive at \"too early\")\n            if (stopNow) {\n                _this.stopInternal(false, _pageScrollInstance);\n            }\n        }), this.config._interval, pageScrollInstance);\n        // Register the instance as running one\n        this.runningInstances.push(pageScrollInstance);\n    };\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    PageScrollService.prototype.scroll = /**\n     * @param {?} options\n     * @return {?}\n     */\n    function (options) {\n        this.start(this.create(options));\n    };\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     */\n    /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     * @param {?=} namespace\n     * @return {?}\n     */\n    PageScrollService.prototype.stopAll = /**\n     * Stop all running scroll animations. Optionally limit to stop only the ones of specific namespace.\n     * @param {?=} namespace\n     * @return {?}\n     */\n    function (namespace) {\n        if (this.runningInstances.length > 0) {\n            /** @type {?} */\n            var stoppedSome = false;\n            for (var i = 0; i < this.runningInstances.length; ++i) {\n                /** @type {?} */\n                var pageScrollInstance = this.runningInstances[i];\n                if (!namespace || pageScrollInstance.pageScrollOptions.namespace === namespace) {\n                    stoppedSome = true;\n                    this.stopInternal(true, pageScrollInstance);\n                    // Decrease the counter, as we removed an item from the array we iterate over\n                    i--;\n                }\n            }\n            return stoppedSome;\n        }\n        return false;\n    };\n    /**\n     * @param {?} pageScrollInstance\n     * @return {?}\n     */\n    PageScrollService.prototype.stop = /**\n     * @param {?} pageScrollInstance\n     * @return {?}\n     */\n    function (pageScrollInstance) {\n        return this.stopInternal(true, pageScrollInstance);\n    };\n    PageScrollService.instanceCounter = 0;\n    PageScrollService.decorators = [\n        { type: Injectable, args: [{\n                    providedIn: 'root',\n                },] }\n    ];\n    /** @nocollapse */\n    PageScrollService.ctorParameters = function () { return [\n        { type: undefined, decorators: [{ type: Inject, args: [NGXPS_CONFIG,] }] }\n    ]; };\n    /** @nocollapse */ PageScrollService.ngInjectableDef = ɵɵdefineInjectable({ factory: function PageScrollService_Factory() { return new PageScrollService(ɵɵinject(NGXPS_CONFIG)); }, token: PageScrollService, providedIn: \"root\" });\n    return PageScrollService;\n}());\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    PageScrollService.instanceCounter;\n    /**\n     * @type {?}\n     * @private\n     */\n    PageScrollService.prototype.config;\n    /**\n     * @type {?}\n     * @private\n     */\n    PageScrollService.prototype.runningInstances;\n    /**\n     * @type {?}\n     * @private\n     */\n    PageScrollService.prototype.onInterrupted;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ɵ0$1 = {};\nvar NgxPageScrollCoreModule = /** @class */ (function () {\n    function NgxPageScrollCoreModule() {\n    }\n    /**\n     * @param {?=} config\n     * @return {?}\n     */\n    NgxPageScrollCoreModule.forRoot = /**\n     * @param {?=} config\n     * @return {?}\n     */\n    function (config) {\n        return {\n            ngModule: NgxPageScrollCoreModule,\n            providers: [PageScrollService, { provide: NGXPS_CONFIG, useValue: config }],\n        };\n    };\n    NgxPageScrollCoreModule.decorators = [\n        { type: NgModule, args: [{\n                    providers: [\n                        PageScrollService,\n                        { provide: NGXPS_CONFIG, useValue: ɵ0$1 },\n                    ],\n                },] }\n    ];\n    return NgxPageScrollCoreModule;\n}());\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @record\n */\nfunction PageScrollConfig() { }\nif (false) {\n    /**\n     * The number of milliseconds to wait till updating the scroll position again.\n     * Small amounts may produce smoother animations but require more processing power.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype._interval;\n    /**\n     * The amount of pixels that need to be between the current scrollTop/scrollLeft position\n     * and the target position the cause a scroll animation. In case distance is below\n     * this threshold, an immediate jump will be performed.\n     * Due to dpi or rounding irregularities in browsers floating point numbers for scrollTop/scrollLeft values\n     * are possible, making a === comparison of current scrollTop or scrollLeft and target scrollPosition error-prone.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype._minScrollDistance;\n    /**\n     * How many console logs should be emitted. Also influenced by angular mode (dev or prod mode)\n     * 0: No logs, neither in dev nor in prod mode\n     * 1: Animation errors in dev mode, no logs in prod mode\n     * 2: Animation errors in dev and prod mode\n     * 5: Animation errors in dev and all scroll position values that get set; animation errors in prod mode\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype._logLevel;\n    /**\n     * Name of the default namespace.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.namespace;\n    /**\n     * Whether by default the scrolling should happen in vertical direction (by manipulating the scrollTop property)\n     * (= true; default) or in horizontal direction (by manipulating the scrollLeft property) (= false\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.verticalScrolling;\n    /**\n     * The duration how long a scrollTo animation should last by default.\n     * May be overridden using the page-scroll-duration attribute on a single ngxPageScroll instance.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.duration;\n    /**\n     * The distance in pixels above scroll target where the animation should stop. Setting a positive number results in\n     * the scroll target being more in the middle of the screen, negative numbers will produce scrolling \"too far\"\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.scrollOffset;\n    /**\n     * Whether by default for inline scroll animations the advanced offset calculation should take place (true) or\n     * not (false). Default is false.\n     * The advanced offset calculation will traverse the DOM tree upwards, starting at the scrollTarget, until it finds\n     * the scrollingView container element. Along the way the offset positions of the relative positioned\n     * (position: relative) elements will be taken into account for calculating the target elements position.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.advancedInlineOffsetCalculation;\n    /**\n     * The events that are listened to on the body to decide whether a scroll animation has been interfered/interrupted by the user\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.interruptEvents;\n    /**\n     * The keys that are considered to interrupt a scroll animation (mainly the arrow keys). All other key presses will not stop the\n     * scroll animation.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.interruptKeys;\n    /**\n     * Whether a scroll animation should be interruptible by user interaction (true) or not (false). If the user performs an\n     * interrupting event while a scroll animation takes place, the scroll animation stops.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.interruptible;\n    /**\n     * Whether the scroll animation should take place if the target is already in the view (true). If set to false the scroll\n     * animation will not start, in case the target pixel is already inside the current view.\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.scrollInView;\n    /**\n     * Easing logic to be applied when performing the scroll animation\n     * @type {?|undefined}\n     */\n    PageScrollConfig.prototype.easingLogic;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { NGXPS_CONFIG, NgxPageScrollCoreModule, PageScrollInstance, PageScrollService, defaultPageScrollConfig };\n"]}