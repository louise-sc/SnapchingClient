/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/ssr-dev-server/index", ["require", "exports", "@angular-devkit/architect", "@angular-devkit/core", "browser-sync", "http-proxy-middleware", "path", "rxjs", "rxjs/operators", "url", "@nguniversal/builders/src/ssr-dev-server/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    const architect_1 = require("@angular-devkit/architect");
    const core_1 = require("@angular-devkit/core");
    const browserSync = require("browser-sync");
    const proxy = require("http-proxy-middleware");
    const path_1 = require("path");
    const rxjs_1 = require("rxjs");
    const operators_1 = require("rxjs/operators");
    const url = require("url");
    const utils_1 = require("@nguniversal/builders/src/ssr-dev-server/utils");
    /** Log messages to ignore and not rely to the logger */
    const IGNORED_STDOUT_MESSAGES = [
        'server listening on',
        'Angular is running in the development mode. Call enableProdMode() to enable the production mode.'
    ];
    function execute(options, context) {
        const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
        const serverTarget = architect_1.targetFromTargetString(options.serverTarget);
        const getBaseUrl = (bs) => `${bs.getOption('scheme')}://${bs.getOption('host')}:${bs.getOption('port')}`;
        const browserTargetRun = context.scheduleTarget(browserTarget, {
            extractCss: true,
            serviceWorker: false,
            watch: true,
            progress: options.progress,
        });
        const serverTargetRun = context.scheduleTarget(serverTarget, {
            watch: true,
            progress: options.progress,
        });
        const bsInstance = browserSync.create();
        context.logger.error(core_1.tags.stripIndents `
  ****************************************************************************************
  This is a simple server for use in testing or debugging Angular applications locally.
  It hasn't been reviewed for security issues.

  DON'T USE IT FOR PRODUCTION!
  ****************************************************************************************
 `);
        return rxjs_1.zip(browserTargetRun, serverTargetRun, utils_1.getAvailablePort()).pipe(operators_1.switchMap(([br, sr, nodeServerPort]) => {
            const server$ = sr.output.pipe(operators_1.switchMap(s => {
                if (!s.success) {
                    return rxjs_1.of(s);
                }
                return startNodeServer(s, nodeServerPort, context.logger).pipe(operators_1.mapTo(s), operators_1.catchError(err => {
                    context.logger.error(`A server error has occurred.\n${mapErrorToMessage(err)}`);
                    return rxjs_1.EMPTY;
                }));
            }));
            return rxjs_1.combineLatest([br.output, server$]).pipe(
            // This is needed so that if both server and browser emit close to each other
            // we only emit once. This typically happens on the first build.
            operators_1.debounceTime(120), operators_1.map(([b, s]) => [
                {
                    success: b.success && s.success,
                    error: b.error || s.error,
                },
                nodeServerPort,
            ]), operators_1.tap(([builderOutput]) => {
                if (builderOutput.success) {
                    context.logger.info('\nCompiled successfully.');
                }
            }), operators_1.debounce(([builderOutput]) => builderOutput.success
                ? utils_1.waitUntilServerIsListening(nodeServerPort)
                : rxjs_1.EMPTY));
        }), operators_1.concatMap(([builderOutput, nodeServerPort]) => {
            if (!builderOutput.success) {
                return rxjs_1.of(builderOutput);
            }
            if (bsInstance.active) {
                bsInstance.reload();
                return rxjs_1.of(builderOutput);
            }
            else {
                return rxjs_1.from(initBrowserSync(bsInstance, nodeServerPort, options))
                    .pipe(operators_1.tap(bs => {
                    const baseUrl = getBaseUrl(bs);
                    context.logger.info(core_1.tags.oneLine `
                **
                Angular Universal Live Development Server is listening on ${baseUrl},
                open your browser on ${baseUrl}
                **
              `);
                }), operators_1.mapTo(builderOutput));
            }
        }), operators_1.map(builderOutput => ({
            success: builderOutput.success,
            error: builderOutput.error,
            baseUrl: bsInstance && getBaseUrl(bsInstance),
        })), operators_1.finalize(() => {
            if (bsInstance) {
                bsInstance.exit();
                bsInstance.cleanup();
            }
        }), operators_1.catchError(error => rxjs_1.of({
            success: false,
            error: mapErrorToMessage(error),
        })));
    }
    exports.execute = execute;
    function startNodeServer(serverOutput, port, logger) {
        const outputPath = serverOutput.outputPath;
        const path = path_1.join(outputPath, 'main.js');
        const env = Object.assign(Object.assign({}, process.env), { PORT: '' + port });
        return rxjs_1.of(null)
            .pipe(operators_1.delay(0), // Avoid EADDRINUSE error since it will cause the kill event to be finish.
        operators_1.switchMap(() => utils_1.spawnAsObservable('node', [`"${path}"`], { env, shell: true })), operators_1.tap(({ stderr, stdout }) => {
            if (stderr) {
                logger.error(stderr);
            }
            if (stdout && !IGNORED_STDOUT_MESSAGES.some(x => stdout.includes(x))) {
                logger.info(stdout);
            }
        }), operators_1.ignoreElements(), 
        // Emit a signal after the process has been started
        operators_1.startWith(undefined));
    }
    function initBrowserSync(browserSyncInstance, nodeServerPort, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (browserSyncInstance.active) {
                return browserSyncInstance;
            }
            const { port: browserSyncPort, open, host, publicHost } = options;
            const bsPort = browserSyncPort || (yield utils_1.getAvailablePort());
            const bsOptions = {
                proxy: {
                    target: `localhost:${nodeServerPort}`,
                    proxyOptions: {
                        xfwd: true
                    },
                    proxyRes: [
                        proxyRes => {
                            if ('headers' in proxyRes) {
                                proxyRes.headers['cache-control'] = undefined;
                            }
                        },
                    ]
                    // proxyOptions is not in the typings
                },
                host,
                port: bsPort,
                ui: false,
                server: false,
                notify: false,
                ghostMode: false,
                logLevel: 'silent',
                open,
                // Remove leading slash
                scriptPath: path => path.substring(1),
            };
            const publicHostNormalized = publicHost && publicHost.endsWith('/')
                ? publicHost.substring(0, publicHost.length - 1)
                : publicHost;
            if (publicHostNormalized) {
                const { protocol, hostname, port, pathname } = url.parse(publicHostNormalized);
                const defaultSocketIoPath = '/browser-sync/socket.io';
                const defaultNamespace = '/browser-sync';
                const hasPathname = !!(pathname && pathname !== '/');
                const namespace = hasPathname ? pathname + defaultNamespace : defaultNamespace;
                const path = hasPathname ? pathname + defaultSocketIoPath : defaultSocketIoPath;
                bsOptions.socket = {
                    namespace,
                    path,
                    domain: url.format({
                        protocol,
                        hostname,
                        port,
                    }),
                };
                // When having a pathname we also need to create a reverse proxy because socket.io
                // will be listening on: 'http://localhost:4200/ssr/browser-sync/socket.io'
                // However users will typically have a reverse proxy that will redirect all matching requests
                // ex: http://testinghost.com/ssr -> http://localhost:4200 which will result in a 404.
                if (hasPathname) {
                    bsOptions.middleware = [
                        proxy(defaultSocketIoPath, {
                            target: url.format({
                                protocol: 'http',
                                hostname: host,
                                port: bsPort,
                                pathname: path,
                            }),
                            ws: true,
                            logLevel: 'silent',
                        }),
                    ];
                }
            }
            return new Promise((resolve, reject) => {
                browserSyncInstance.init(bsOptions, (error, bs) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(bs);
                    }
                });
            });
        });
    }
    function mapErrorToMessage(error) {
        if (error instanceof Error) {
            return error.message;
        }
        if (typeof error === 'string') {
            return error;
        }
        return '';
    }
    exports.default = architect_1.createBuilder(execute);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9zc3ItZGV2LXNlcnZlci9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0dBTUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUVILHlEQUttQztJQUNuQywrQ0FBMkQ7SUFDM0QsNENBQTRDO0lBQzVDLCtDQUErQztJQUMvQywrQkFBNEI7SUFDNUIsK0JBT2M7SUFDZCw4Q0Fhd0I7SUFDeEIsMkJBQTJCO0lBRzNCLDBFQUEwRjtJQUUxRix3REFBd0Q7SUFDeEQsTUFBTSx1QkFBdUIsR0FBRztRQUM5QixxQkFBcUI7UUFDckIsa0dBQWtHO0tBQ25HLENBQUM7SUFRRixTQUFnQixPQUFPLENBQ3JCLE9BQW1DLEVBQ25DLE9BQXVCO1FBRXZCLE1BQU0sYUFBYSxHQUFHLGtDQUFzQixDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNwRSxNQUFNLFlBQVksR0FBRyxrQ0FBc0IsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDbEUsTUFBTSxVQUFVLEdBQUcsQ0FBQyxFQUFtQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFFMUksTUFBTSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRTtZQUM3RCxVQUFVLEVBQUUsSUFBSTtZQUNoQixhQUFhLEVBQUUsS0FBSztZQUNwQixLQUFLLEVBQUUsSUFBSTtZQUNYLFFBQVEsRUFBRSxPQUFPLENBQUMsUUFBUTtTQUMzQixDQUFDLENBQUM7UUFFSCxNQUFNLGVBQWUsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLFlBQVksRUFB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QUksS0FBSyxZQUFZLEtBQUssRUFBRTtZQUMxQixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUM7U0FDdEI7UUFFRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUM3QixPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsa0JBQWUseUJBQWEsQ0FBNEMsT0FBTyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHtcbiAgQnVpbGRlckNvbnRleHQsXG4gIEJ1aWxkZXJPdXRwdXQsXG4gIGNyZWF0ZUJ1aWxkZXIsXG4gIHRhcmdldEZyb21UYXJnZXRTdHJpbmcsXG59IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9hcmNoaXRlY3QnO1xuaW1wb3J0IHsganNvbiwgbG9nZ2luZywgdGFncyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlJztcbmltcG9ydCAqIGFzIGJyb3dzZXJTeW5jIGZyb20gJ2Jyb3dzZXItc3luYyc7XG5pbXBvcnQgKiBhcyBwcm94eSBmcm9tICdodHRwLXByb3h5LW1pZGRsZXdhcmUnO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHtcbiAgRU1QVFksXG4gIE9ic2VydmFibGUsXG4gIGNvbWJpbmVMYXRlc3QsXG4gIGZyb20sXG4gIG9mLFxuICB6aXAsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgY29uY2F0TWFwLFxuICBkZWJvdW5jZSxcbiAgZGVib3VuY2VUaW1lLFxuICBkZWxheSxcbiAgZmluYWxpemUsXG4gIGlnbm9yZUVsZW1lbnRzLFxuICBtYXAsXG4gIG1hcFRvLFxuICBzdGFydFdpdGgsXG4gIHN3aXRjaE1hcCxcbiAgdGFwLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgKiBhcyB1cmwgZnJvbSAndXJsJztcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gJy4vc2NoZW1hJztcblxuaW1wb3J0IHsgZ2V0QXZhaWxhYmxlUG9ydCwgc3Bhd25Bc09ic2VydmFibGUsIHdhaXRVbnRpbFNlcnZlcklzTGlzdGVuaW5nIH0gZnJvbSAnLi91dGlscyc7XG5cbi8qKiBMb2cgbWVzc2FnZXMgdG8gaWdub3JlIGFuZCBub3QgcmVseSB0byB0aGUgbG9nZ2VyICovXG5jb25zdCBJR05PUkVEX1NURE9VVF9NRVNTQUdFUyA9IFtcbiAgJ3NlcnZlciBsaXN0ZW5pbmcgb24nLFxuICAnQW5ndWxhciBpcyBydW5uaW5nIGluIHRoZSBkZXZlbG9wbWVudCBtb2RlLiBDYWxsIGVuYWJsZVByb2RNb2RlKCkgdG8gZW5hYmxlIHRoZSBwcm9kdWN0aW9uIG1vZGUuJ1xuXTtcblxuXG5leHBvcnQgdHlwZSBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyA9IFNjaGVtYSAmIGpzb24uSnNvbk9iamVjdDtcbmV4cG9ydCB0eXBlIFNTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQgPSBCdWlsZGVyT3V0cHV0ICYge1xuICBiYXNlVXJsPzogc3RyaW5nO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGUoXG4gIG9wdGlvbnM6IFNTUkRldlNlcnZlckJ1aWxkZXJPcHRpb25zLFxuICBjb250ZXh0OiBCdWlsZGVyQ29udGV4dCxcbik6IE9ic2VydmFibGU8U1NSRGV2U2VydmVyQnVpbGRlck91dHB1dD4ge1xuICBjb25zdCBicm93c2VyVGFyZ2V0ID0gdGFyZ2V0RnJvbVRhcmdldFN0cmluZyhvcHRpb25zLmJyb3dzZXJUYXJnZXQpO1xuICBjb25zdCBzZXJ2ZXJUYXJnZXQgPSB0YXJnZXRGcm9tVGFyZ2V0U3RyaW5nKG9wdGlvbnMuc2VydmVyVGFyZ2V0KTtcbiAgY29uc3QgZ2V0QmFzZVVybCA9IChiczogYnJvd3NlclN5bmMuQnJvd3NlclN5bmNJbnN0YW5jZSkgPT4gYCR7YnMuZ2V0T3B0aW9uKCdzY2hlbWUnKX06Ly8ke2JzLmdldE9wdGlvbignaG9zdCcpfToke2JzLmdldE9wdGlvbigncG9ydCcpfWA7XG5cbiAgY29uc3QgYnJvd3NlclRhcmdldFJ1biA9IGNvbnRleHQuc2NoZWR1bGVUYXJnZXQoYnJvd3NlclRhcmdldCwge1xuICAgIGV4dHJhY3RDc3M6IHRydWUsXG4gICAgc2VydmljZVdvcmtlcjogZmFsc2UsXG4gICAgd2F0Y2g6IHRydWUsXG4gICAgcHJvZ3Jlc3M6IG9wdGlvbnMucHJvZ3Jlc3MsXG4gIH0pO1xuXG4gIGNvbnN0IHNlcnZlclRhcmdldFJ1biA9IGNvbnRleHQuc2NoZWR1bGVUYXJnZXQoc2VydmVyVGFyZ2V0LCB7XG4gICAgd2F0Y2g6IHRydWUsXG4gICAgcHJvZ3Jlc3M6IG9wdGlvbnMucHJvZ3Jlc3MsXG4gIH0pO1xuXG4gIGNvbnN0IGJzSW5zdGFuY2UgPSBicm93c2VyU3luYy5jcmVhdGUoKTtcblxuICBjb250ZXh0LmxvZ2dlci5lcnJvcih0YWdzLnN0cmlwSW5kZW50c2BcbiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBUaGlzIGlzIGEgc2ltcGxlIHNlcnZlciBmb3IgdXNlIGluIHRlc3Rpbmcgb3IgZGVidWdnaW5nIEFuZ3VsYXIgYXBwbGljYXRpb25zIGxvY2FsbHkuXG4gIEl0IGhhc24ndCBiZWVuIHJldmlld2VkIGZvciBzZWN1cml0eSBpc3N1ZXMuXG5cbiAgRE9OJ1QgVVNFIElUIEZPUiBQUk9EVUNUSU9OIVxuICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gYCk7XG5cbiAgcmV0dXJuIHppcChcbiAgICBicm93c2VyVGFyZ2V0UnVuLFxuICAgIHNlcnZlclRhcmdldFJ1bixcbiAgICBnZXRBdmFpbGFibGVQb3J0KCksXG4gICkucGlwZShcbiAgICBzd2l0Y2hNYXAoKFticiwgc3IsIG5vZGVTZXJ2ZXJQb3J0XSkgPT4ge1xuICAgICAgY29uc3Qgc2VydmVyJCA9IHNyLm91dHB1dC5waXBlKFxuICAgICAgICBzd2l0Y2hNYXAocyA9PiB7XG4gICAgICAgICAgaWYgKCFzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBvZihzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhcnROb2RlU2VydmVyKHMsIG5vZGVTZXJ2ZXJQb3J0LCBjb250ZXh0LmxvZ2dlcikucGlwZShcbiAgICAgICAgICAgIG1hcFRvKHMpLFxuICAgICAgICAgICAgY2F0Y2hFcnJvcihlcnIgPT4ge1xuICAgICAgICAgICAgICBjb250ZXh0LmxvZ2dlci5lcnJvcihgQSBzZXJ2ZXIgZXJyb3IgaGFzIG9jY3VycmVkLlxcbiR7bWFwRXJyb3JUb01lc3NhZ2UoZXJyKX1gKTtcblxuICAgICAgICAgICAgICByZXR1cm4gRU1QVFk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICB9KSk7XG5cbiAgICAgIHJldHVybiBjb21iaW5lTGF0ZXN0KFtici5vdXRwdXQsIHNlcnZlciRdKS5waXBlKFxuICAgICAgICAvLyBUaGlzIGlzIG5lZWRlZCBzbyB0aGF0IGlmIGJvdGggc2VydmVyIGFuZCBicm93c2VyIGVtaXQgY2xvc2UgdG8gZWFjaCBvdGhlclxuICAgICAgICAvLyB3ZSBvbmx5IGVtaXQgb25jZS4gVGhpcyB0eXBpY2FsbHkgaGFwcGVucyBvbiB0aGUgZmlyc3QgYnVpbGQuXG4gICAgICAgIGRlYm91bmNlVGltZSgxMjApLFxuICAgICAgICBtYXAoKFtiLCBzXSkgPT4gKFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdWNjZXNzOiBiLnN1Y2Nlc3MgJiYgcy5zdWNjZXNzLFxuICAgICAgICAgICAgZXJyb3I6IGIuZXJyb3IgfHwgcy5lcnJvcixcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vZGVTZXJ2ZXJQb3J0LFxuICAgICAgICBdIGFzIFtTU1JEZXZTZXJ2ZXJCdWlsZGVyT3V0cHV0LCBudW1iZXJdKSksXG4gICAgICAgIHRhcCgoW2J1aWxkZXJPdXRwdXRdKSA9PiB7XG4gICAgICAgICAgaWYgKGJ1aWxkZXJPdXRwdXQuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuaW5mbygnXFxuQ29tcGlsZWQgc3VjY2Vzc2Z1bGx5LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGRlYm91bmNlKChbYnVpbGRlck91dHB1dF0pID0+IGJ1aWxkZXJPdXRwdXQuc3VjY2Vzc1xuICAgICAgICAgID8gd2FpdFVudGlsU2VydmVySXNMaXN0ZW5pbmcobm9kZVNlcnZlclBvcnQpXG4gICAgICAgICAgOiBFTVBUWSlcbiAgICAgICk7XG4gICAgfSksXG4gICAgY29uY2F0TWFwKChbYnVpbGRlck91dHB1dCwgbm9kZVNlcnZlclBvcnRdKSA9PiB7XG4gICAgICBpZiAoIWJ1aWxkZXJPdXRwdXQuc3VjY2Vzcykge1xuICAgICAgICByZXR1cm4gb2YoYnVpbGRlck91dHB1dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChic0luc3RhbmNlLmFjdGl2ZSkge1xuICAgICAgICBic0luc3RhbmNlLnJlbG9hZCgpO1xuXG4gICAgICAgIHJldHVybiBvZihidWlsZGVyT3V0cHV0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmcm9tKGluaXRCcm93c2VyU3luYyhic0luc3RhbmNlLCBub2RlU2VydmVyUG9ydCwgb3B0aW9ucykpXG4gICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICB0YXAoYnMgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChicyk7XG4gICAgICAgICAgICAgIGNvbnRleHQubG9nZ2VyLmluZm8odGFncy5vbmVMaW5lYFxuICAgICAgICAgICAgICAgICoqXG4gICAgICAgICAgICAgICAgQW5ndWxhciBVbml2ZXJzYWwgTGl2ZSBEZXZlbG9wbWVudCBTZXJ2ZXIgaXMgbGlzdGVuaW5nIG9uICR7YmFzZVVybH0sXG4gICAgICAgICAgICAgICAgb3BlbiB5b3VyIGJyb3dzZXIgb24gJHtiYXNlVXJsfVxuICAgICAgICAgICAgICAgICoqXG4gICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXBUbyhidWlsZGVyT3V0cHV0KSxcbiAgICAgICAgICApO1xuICAgICAgfVxuICAgIH0pLFxuICAgIG1hcChidWlsZGVyT3V0cHV0ID0+ICh7XG4gICAgICBzdWNjZXNzOiBidWlsZGVyT3V0cHV0LnN1Y2Nlc3MsXG4gICAgICBlcnJvcjogYnVpbGRlck91dHB1dC5lcnJvcixcbiAgICAgIGJhc2VVcmw6IGJzSW5zdGFuY2UgJiYgZ2V0QmFzZVVybChic0luc3RhbmNlKSxcbiAgICB9IGFzIFNTUkRldlNlcnZlckJ1aWxkZXJPdXRwdXQpKSxcbiAgICBmaW5hbGl6ZSgoKSA9PiB7XG4gICAgICBpZiAoYnNJbnN0YW5jZSkge1xuICAgICAgICBic0luc3RhbmNlLmV4aXQoKTtcbiAgICAgICAgYnNJbnN0YW5jZS5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgY2F0Y2hFcnJvcihlcnJvciA9PiBvZih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBtYXBFcnJvclRvTWVzc2FnZShlcnJvciksXG4gICAgfSkpLFxuICApO1xufVxuXG5mdW5jdGlvbiBzdGFydE5vZGVTZXJ2ZXIoXG4gIHNlcnZlck91dHB1dDogQnVpbGRlck91dHB1dCxcbiAgcG9ydDogbnVtYmVyLFxuICBsb2dnZXI6IGxvZ2dpbmcuTG9nZ2VyQXBpLFxuKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gIGNvbnN0IG91dHB1dFBhdGggPSBzZXJ2ZXJPdXRwdXQub3V0cHV0UGF0aCBhcyBzdHJpbmc7XG4gIGNvbnN0IHBhdGggPSBqb2luKG91dHB1dFBhdGgsICdtYWluLmpzJyk7XG4gIGNvbnN0IGVudiA9IHsgLi4ucHJvY2Vzcy5lbnYsIFBPUlQ6ICcnICsgcG9ydCB9O1xuXG4gIHJldHVybiBvZihudWxsKVxuICAgIC5waXBlKFxuICAgICAgZGVsYXkoMCksIC8vIEF2b2lkIEVBRERSSU5VU0UgZXJyb3Igc2luY2UgaXQgd2lsbCBjYXVzZSB0aGUga2lsbCBldmVudCB0byBiZSBmaW5pc2guXG4gICAgICBzd2l0Y2hNYXAoKCkgPT4gc3Bhd25Bc09ic2VydmFibGUoJ25vZGUnLCBbYFwiJHtwYXRofVwiYF0sIHsgZW52LCBzaGVsbDogdHJ1ZSB9KSksXG4gICAgICB0YXAoKHsgc3RkZXJyLCBzdGRvdXQgfSkgPT4ge1xuICAgICAgICBpZiAoc3RkZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKHN0ZGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3Rkb3V0ICYmICFJR05PUkVEX1NURE9VVF9NRVNTQUdFUy5zb21lKHggPT4gc3Rkb3V0LmluY2x1ZGVzKHgpKSkge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKHN0ZG91dCk7XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgaWdub3JlRWxlbWVudHMoKSxcbiAgICAgIC8vIEVtaXQgYSBzaWduYWwgYWZ0ZXIgdGhlIHByb2Nlc3MgaGFzIGJlZW4gc3RhcnRlZFxuICAgICAgc3RhcnRXaXRoKHVuZGVmaW5lZCksXG4gICAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5pdEJyb3dzZXJTeW5jKFxuICBicm93c2VyU3luY0luc3RhbmNlOiBicm93c2VyU3luYy5Ccm93c2VyU3luY0luc3RhbmNlLFxuICBub2RlU2VydmVyUG9ydDogbnVtYmVyLFxuICBvcHRpb25zOiBTU1JEZXZTZXJ2ZXJCdWlsZGVyT3B0aW9ucyxcbik6IFByb21pc2U8YnJvd3NlclN5bmMuQnJvd3NlclN5bmNJbnN0YW5jZT4ge1xuICBpZiAoYnJvd3NlclN5bmNJbnN0YW5jZS5hY3RpdmUpIHtcbiAgICByZXR1cm4gYnJvd3NlclN5bmNJbnN0YW5jZTtcbiAgfVxuXG4gIGNvbnN0IHsgcG9ydDogYnJvd3NlclN5bmNQb3J0LCBvcGVuLCBob3N0LCBwdWJsaWNIb3N0IH0gPSBvcHRpb25zO1xuICBjb25zdCBic1BvcnQgPSBicm93c2VyU3luY1BvcnQgfHwgYXdhaXQgZ2V0QXZhaWxhYmxlUG9ydCgpO1xuICBjb25zdCBic09wdGlvbnM6IGJyb3dzZXJTeW5jLk9wdGlvbnMgPSB7XG4gICAgcHJveHk6IHtcbiAgICAgIHRhcmdldDogYGxvY2FsaG9zdDoke25vZGVTZXJ2ZXJQb3J0fWAsXG4gICAgICBwcm94eU9wdGlvbnM6IHtcbiAgICAgICAgeGZ3ZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHByb3h5UmVzOiBbXG4gICAgICAgIHByb3h5UmVzID0+IHtcbiAgICAgICAgICBpZiAoJ2hlYWRlcnMnIGluIHByb3h5UmVzKSB7XG4gICAgICAgICAgICBwcm94eVJlcy5oZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgXVxuICAgICAgLy8gcHJveHlPcHRpb25zIGlzIG5vdCBpbiB0aGUgdHlwaW5nc1xuICAgIH0gYXMgYnJvd3NlclN5bmMuUHJveHlPcHRpb25zICYgeyBwcm94eU9wdGlvbnM6IHsgeGZ3ZDogYm9vbGVhbiB9IH0sXG4gICAgaG9zdCxcbiAgICBwb3J0OiBic1BvcnQsXG4gICAgdWk6IGZhbHNlLFxuICAgIHNlcnZlcjogZmFsc2UsXG4gICAgbm90aWZ5OiBmYWxzZSxcbiAgICBnaG9zdE1vZGU6IGZhbHNlLFxuICAgIGxvZ0xldmVsOiAnc2lsZW50JyxcbiAgICBvcGVuLFxuICAgIC8vIFJlbW92ZSBsZWFkaW5nIHNsYXNoXG4gICAgc2NyaXB0UGF0aDogcGF0aCA9PiBwYXRoLnN1YnN0cmluZygxKSxcbiAgfTtcblxuICBjb25zdCBwdWJsaWNIb3N0Tm9ybWFsaXplZCA9IHB1YmxpY0hvc3QgJiYgcHVibGljSG9zdC5lbmRzV2l0aCgnLycpXG4gICAgPyBwdWJsaWNIb3N0LnN1YnN0cmluZygwLCBwdWJsaWNIb3N0Lmxlbmd0aCAtIDEpXG4gICAgOiBwdWJsaWNIb3N0O1xuXG4gIGlmIChwdWJsaWNIb3N0Tm9ybWFsaXplZCkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wsIGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSB9ID0gdXJsLnBhcnNlKHB1YmxpY0hvc3ROb3JtYWxpemVkKTtcbiAgICBjb25zdCBkZWZhdWx0U29ja2V0SW9QYXRoID0gJy9icm93c2VyLXN5bmMvc29ja2V0LmlvJztcbiAgICBjb25zdCBkZWZhdWx0TmFtZXNwYWNlID0gJy9icm93c2VyLXN5bmMnO1xuICAgIGNvbnN0IGhhc1BhdGhuYW1lID0gISEocGF0aG5hbWUgJiYgcGF0aG5hbWUgIT09ICcvJyk7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gaGFzUGF0aG5hbWUgPyBwYXRobmFtZSArIGRlZmF1bHROYW1lc3BhY2UgOiBkZWZhdWx0TmFtZXNwYWNlO1xuICAgIGNvbnN0IHBhdGggPSBoYXNQYXRobmFtZSA/IHBhdGhuYW1lICsgZGVmYXVsdFNvY2tldElvUGF0aCA6IGRlZmF1bHRTb2NrZXRJb1BhdGg7XG5cbiAgICBic09wdGlvbnMuc29ja2V0ID0ge1xuICAgICAgbmFtZXNwYWNlLFxuICAgICAgcGF0aCxcbiAgICAgIGRvbWFpbjogdXJsLmZvcm1hdCh7XG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcG9ydCxcbiAgICAgIH0pLFxuICAgIH07XG5cbiAgICAvLyBXaGVuIGhhdmluZyBhIHBhdGhuYW1lIHdlIGFsc28gbmVlZCB0byBjcmVhdGUgYSByZXZlcnNlIHByb3h5IGJlY2F1c2Ugc29ja2V0LmlvXG4gICAgLy8gd2lsbCBiZSBsaXN0ZW5pbmcgb246ICdodHRwOi8vbG9jYWxob3N0OjQyMDAvc3NyL2Jyb3dzZXItc3luYy9zb2NrZXQuaW8nXG4gICAgLy8gSG93ZXZlciB1c2VycyB3aWxsIHR5cGljYWxseSBoYXZlIGEgcmV2ZXJzZSBwcm94eSB0aGF0IHdpbGwgcmVkaXJlY3QgYWxsIG1hdGNoaW5nIHJlcXVlc3RzXG4gICAgLy8gZXg6IGh0dHA6Ly90ZXN0aW5naG9zdC5jb20vc3NyIC0+IGh0dHA6Ly9sb2NhbGhvc3Q6NDIwMCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIDQwNC5cbiAgICBpZiAoaGFzUGF0aG5hbWUpIHtcbiAgICAgIGJzT3B0aW9ucy5taWRkbGV3YXJlID0gW1xuICAgICAgICBwcm94eShkZWZhdWx0U29ja2V0SW9QYXRoLCB7XG4gICAgICAgICAgdGFyZ2V0OiB1cmwuZm9ybWF0KHtcbiAgICAgICAgICAgIHByb3RvY29sOiAnaHR0cCcsXG4gICAgICAgICAgICBob3N0bmFtZTogaG9zdCxcbiAgICAgICAgICAgIHBvcnQ6IGJzUG9ydCxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHdzOiB0cnVlLFxuICAgICAgICAgIGxvZ0xldmVsOiAnc2lsZW50JyxcbiAgICAgICAgfSksXG4gICAgICBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgYnJvd3NlclN5bmNJbnN0YW5jZS5pbml0KGJzT3B0aW9ucywgKGVycm9yLCBicykgPT4ge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGJzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1hcEVycm9yVG9NZXNzYWdlKGVycm9yOiB1bmtub3duKTogc3RyaW5nIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCdWlsZGVyPFNTUkRldlNlcnZlckJ1aWxkZXJPcHRpb25zLCBCdWlsZGVyT3V0cHV0PihleGVjdXRlKTtcbiJdfQ==