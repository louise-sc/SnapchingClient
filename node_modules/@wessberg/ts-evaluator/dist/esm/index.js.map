{"version":3,"file":"index.js","sources":["../../src/interpreter/util/proxy/can-be-observed.ts","../../src/interpreter/util/function/is-bind-call-apply.ts","../../src/interpreter/proxy/create-policy-proxy.ts","../../src/interpreter/policy/policy-trap-kind.ts","../../src/interpreter/policy/network/network-map.ts","../../src/interpreter/policy/nondeterministic/nondeterministic-map.ts","../../src/interpreter/policy/trap-condition-map.ts","../../src/interpreter/policy/is-trap-condition-met.ts","../../src/interpreter/policy/nondeterministic/is-nondeterministic.ts","../../src/interpreter/error/evaluation-error/evaluation-error.ts","../../src/interpreter/error/policy-error/policy-error.ts","../../src/interpreter/error/policy-error/non-deterministic-error/non-deterministic-error.ts","../../src/interpreter/policy/io/io-map.ts","../../src/interpreter/policy/io/is-io-read.ts","../../src/interpreter/error/policy-error/io-error/io-error.ts","../../src/interpreter/policy/io/is-io-write.ts","../../src/interpreter/policy/network/is-network-operation.ts","../../src/interpreter/error/policy-error/network-error/network-error.ts","../../src/interpreter/policy/process/process-map.ts","../../src/interpreter/policy/process/is-process-exit-operation.ts","../../src/interpreter/error/policy-error/process-error/process-error.ts","../../src/interpreter/policy/process/is-process-spawn-child-operation.ts","../../src/interpreter/policy/console/console-map.ts","../../src/interpreter/policy/console/is-console-operation.ts","../../src/interpreter/environment/create-sanitized-environment.ts","../../src/interpreter/environment/ecma/ecma-globals.ts","../../src/interpreter/util/descriptor/merge-descriptors.ts","../../src/interpreter/util/object/subtract.ts","../../src/interpreter/environment/node/node-globals.ts","../../src/interpreter/environment/environment-preset-kind.ts","../../src/interpreter/environment/browser/lib/raf.ts","../../src/interpreter/environment/browser/browser-globals.ts","../../src/interpreter/util/return/return-symbol.ts","../../src/interpreter/util/break/break-symbol.ts","../../src/interpreter/util/continue/continue-symbol.ts","../../src/interpreter/util/this/this-symbol.ts","../../src/interpreter/util/super/super-symbol.ts","../../src/interpreter/lexical-environment/lexical-environment.ts","../../src/interpreter/util/node/is-boolean-literal.ts","../../src/interpreter/util/node/is-null-literal.ts","../../src/interpreter/evaluator/simple/evaluate-simple-literal.ts","../../src/interpreter/error/policy-error/max-ops-exceeded-error/max-ops-exceeded-error.ts","../../src/interpreter/evaluator/evaluate-variable-declaration.ts","../../src/interpreter/util/node/is-this-expression.ts","../../src/interpreter/util/node/is-super-expression.ts","../../src/interpreter/lexical-environment/get-dot-path-from-node.ts","../../src/interpreter/error/unexpected-node-error/unexpected-node-error.ts","../../src/interpreter/error/undefined-left-value-error/undefined-left-value-error.ts","../../src/interpreter/evaluator/evaluate-binary-expression.ts","../../src/interpreter/literal/literal.ts","../../src/interpreter/error/not-callable-error/not-callable-error.ts","../../src/interpreter/util/expression/expression-contains-super-keyword.ts","../../src/interpreter/evaluator/evaluate-call-expression.ts","../../src/interpreter/evaluator/evaluate-parenthesized-expression.ts","../../src/interpreter/lexical-environment/clone-lexical-environment.ts","../../src/interpreter/util/modifier/has-modifier.ts","../../src/interpreter/evaluator/evaluate-parameter-declarations.ts","../../src/interpreter/evaluator/evaluate-arrow-function-expression.ts","../../src/interpreter/evaluator/evaluate-string-literal.ts","../../src/interpreter/evaluator/evaluate-numeric-literal.ts","../../src/interpreter/evaluator/evaluate-boolean-literal.ts","../../src/interpreter/evaluator/evaluate-regular-expression-literal.ts","../../src/interpreter/evaluator/evaluate-object-literal-expression.ts","../../src/interpreter/util/iterable/is-iterable.ts","../../src/interpreter/evaluator/evaluate-array-literal-expression.ts","../../src/interpreter/error/undefined-identifier-error/undefined-identifier-error.ts","../../src/interpreter/util/flags/is-var-declaration.ts","../../src/interpreter/util/node/find-nearest-parent-node-of-kind.ts","../../src/interpreter/error/module-not-found-error/module-not-found-error.ts","../../src/interpreter/util/declaration/get-declaration-name.ts","../../src/interpreter/util/module/get-implementation-for-declaration-within-declaration-file.ts","../../src/interpreter/evaluator/evaluate-identifier.ts","../../src/interpreter/evaluator/evaluate-block.ts","../../src/interpreter/evaluator/evaluate-return-statement.ts","../../src/interpreter/evaluator/evaluate-variable-declaration-list.ts","../../src/interpreter/evaluator/evaluate-variable-statement.ts","../../src/interpreter/evaluator/evaluate-prefix-unary-expression.ts","../../src/interpreter/evaluator/evaluate-property-access-expression.ts","../../src/interpreter/evaluator/evaluate-element-access-expression.ts","../../src/interpreter/evaluator/evaluate-computed-property-name.ts","../../src/interpreter/evaluator/evaluate-function-declaration.ts","../../src/interpreter/evaluator/evaluate-if-statement.ts","../../src/interpreter/evaluator/evaluate-expression-statement.ts","../../src/interpreter/evaluator/evaluate-template-expression.ts","../../src/interpreter/evaluator/evaluate-type-assertion-expression.ts","../../src/interpreter/evaluator/evaluate-postfix-unary-expression.ts","../../src/interpreter/evaluator/evaluate-new-expression.ts","../../src/interpreter/evaluator/evaluate-non-null-expression.ts","../../src/interpreter/evaluator/evaluate-as-expression.ts","../../src/interpreter/evaluator/evaluate-switch-statement.ts","../../src/interpreter/error/async-not-supported-error/async-not-supported-error.ts","../../src/interpreter/util/await/sync-await.ts","../../src/interpreter/evaluator/evaluate-for-of-statement.ts","../../src/interpreter/evaluator/evaluate-this-expression.ts","../../src/interpreter/evaluator/evaluate-break-statement.ts","../../src/interpreter/evaluator/evaluate-continue-statement.ts","../../src/interpreter/evaluator/evaluate-for-statement.ts","../../src/interpreter/evaluator/evaluate-while-statement.ts","../../src/interpreter/evaluator/evaluate-for-in-statement.ts","../../src/interpreter/evaluator/evaluate-function-expression.ts","../../src/interpreter/error/missing-catch-or-finally-after-try-error/missing-catch-or-finally-after-try-error.ts","../../src/interpreter/util/try/try-symbol.ts","../../src/interpreter/evaluator/evaluate-try-statement.ts","../../src/interpreter/util/class/generate-class-declaration.ts","../../src/interpreter/evaluator/evaluate-class-declaration.ts","../../src/interpreter/evaluator/evaluate-constructor-declaration.ts","../../src/interpreter/evaluator/evaluate-super-expression.ts","../../src/interpreter/evaluator/evaluate-spread-element.ts","../../src/interpreter/evaluator/evaluate-class-expression.ts","../../src/interpreter/evaluator/evaluate-null-literal.ts","../../src/interpreter/evaluator/evaluate-void-expression.ts","../../src/interpreter/evaluator/evaluate-type-of-expression.ts","../../src/interpreter/evaluator/evaluate-big-int-literal.ts","../../src/interpreter/evaluator/evaluate-enum-declaration.ts","../../src/interpreter/evaluator/evaluate-source-file-as-namespace-object.ts","../../src/interpreter/evaluator/evaluate-module-declaration.ts","../../src/interpreter/evaluator/evaluate-import-declaration.ts","../../src/interpreter/evaluator/evaluate-throw-statement.ts","../../src/interpreter/evaluator/evaluate-import-equals-declaration.ts","../../src/interpreter/error/policy-error/max-op-duration-exceeded-error/max-op-duration-exceeded-error.ts","../../src/interpreter/evaluator/evaluate-await-expression.ts","../../src/interpreter/evaluator/evaluate-conditional-expression.ts","../../src/interpreter/util/static/in-static-context.ts","../../src/interpreter/evaluator/evaluate-method-declaration.ts","../../src/interpreter/evaluator/evaluate-property-declaration.ts","../../src/interpreter/evaluator/evaluate-get-accessor-declaration.ts","../../src/interpreter/evaluator/evaluate-node.ts","../../src/interpreter/stack/traversal-stack/statement-traversal-stack.ts","../../src/interpreter/evaluator/evaluate-statement.ts","../../src/interpreter/evaluator/evaluate-expression.ts","../../src/interpreter/evaluator/evaluate-declaration.ts","../../src/interpreter/evaluator/evaluate-binding-name.ts","../../src/interpreter/evaluator/evaluate-set-accessor-declaration.ts","../../src/interpreter/evaluator/evaluate-property-assignment.ts","../../src/interpreter/evaluator/evaluate-parameter-declaration.ts","../../src/interpreter/evaluator/evaluate-shorthand-property-assignment.ts","../../src/interpreter/evaluator/evaluate-spread-assignment.ts","../../src/interpreter/evaluator/evaluate-array-binding-pattern.ts","../../src/interpreter/evaluator/evaluate-binding-element.ts","../../src/interpreter/evaluator/evaluate-object-binding-pattern.ts","../../src/interpreter/evaluator/evaluate-case-block.ts","../../src/interpreter/evaluator/evaluate-case-clause.ts","../../src/interpreter/evaluator/evaluate-default-clause.ts","../../src/interpreter/evaluator/evaluate-catch-clause.ts","../../src/interpreter/evaluator/evaluate-omitted-expression.ts","../../src/interpreter/evaluator/evaluate-decorator.ts","../../src/interpreter/evaluator/evaluate-enum-member.ts","../../src/interpreter/evaluator/evaluate-node-with-argument.ts","../../src/interpreter/evaluator/evaluate-property-name.ts","../../src/interpreter/evaluator/evaluate-node-with-value.ts","../../src/interpreter/util/reporting/report-error.ts","../../src/interpreter/evaluator/node-evaluator/create-node-evaluator.ts","../../src/interpreter/util/syntax-kind/stringify-syntax-kind.ts","../../src/interpreter/logger/logger.ts","../../src/interpreter/util/expression/is-expression.ts","../../src/interpreter/util/statement/is-statement.ts","../../src/interpreter/stack/stack.ts","../../src/interpreter/util/declaration/is-declaration.ts","../../src/interpreter/reporting/reported-error-set.ts","../../src/interpreter/evaluate.ts"],"sourcesContent":["/**\n * Returns true if the provided value is ObjectLike\n * @param {T} value\n * @returns {boolean}\n */\nexport function isObjectLike<T> (value: T): boolean {\n\treturn value != null && (typeof value === \"function\" || typeof value === \"object\");\n}\n\n/**\n * Returns true if the given value can be observed\n * @param {T} value\n * @returns {boolean}\n */\nexport function canBeObserved<T> (value: T): boolean {\n\treturn isObjectLike(value);\n}","import {getFromLexicalEnvironment, LexicalEnvironment} from \"../../lexical-environment/lexical-environment\";\n\n/**\n * Returns true if the given function is either Function.prototype.bind, Function.prototype.call, or Function.prototype.apply\n * @param {Function} func\n * @param {LexicalEnvironment} [environment]\n * @return {boolean}\n */\nexport function isBindCallApply (func: Function, environment?: LexicalEnvironment): boolean {\n\tswitch (func) {\n\t\tcase Function.prototype.bind:\n\t\tcase Function.prototype.call:\n\t\tcase Function.prototype.apply:\n\t\t\treturn true;\n\t}\n\n\tif (environment != null) {\n\t\tconst _Function = getFromLexicalEnvironment(undefined, environment, \"Function\")!.literal as Function;\n\t\tswitch (func) {\n\t\t\tcase _Function.prototype.bind:\n\t\t\tcase _Function.prototype.call:\n\t\t\tcase _Function.prototype.apply:\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}","import {canBeObserved} from \"../util/proxy/can-be-observed\";\nimport {ICreatePolicyProxyOptions} from \"./i-create-policy-proxy-options\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply\";\nimport {PolicyTrapKind} from \"../policy/policy-trap-kind\";\n\n/**\n * Stringifies the given PropertyKey path\n * @param {PropertyKey[]} path\n * @return {string}\n */\nfunction stringifyPath (path: PropertyKey[]): string {\n\treturn path\n\t\t.map(part => typeof part === \"symbol\" ? part.description : part)\n\t\t.join(\".\");\n}\n\n/**\n * Creates a proxy with hooks to check the given policy\n * @param {ICreatePolicyProxyOptions<T>} options\n * @return {T}\n */\nexport function createPolicyProxy<T extends object> ({hook, item, scope, policy}: ICreatePolicyProxyOptions<T, object>): T {\n\n\t/**\n\t * Creates a trap that captures function invocation\n\t * @param {string[]} inputPath\n\t * @param {U} currentItem\n\t * @return {U}\n\t */\n\tfunction createAccessTrap<U extends object> (inputPath: PropertyKey[], currentItem: U): U {\n\t\treturn !canBeObserved(currentItem) || isBindCallApply(currentItem as Function) ? currentItem : new Proxy(currentItem, {\n\n\t\t\t/**\n\t\t\t * Constructs a new instance of the given target\n\t\t\t * @param {U} target\n\t\t\t * @param {unknown[]} argArray\n\t\t\t * @param newTarget\n\t\t\t * @return {object}\n\t\t\t */\n\t\t\tconstruct (target: U, argArray: unknown[], newTarget?: unknown): object {\n\t\t\t\t// Don't proceed if the hook says no\n\t\t\t\tif (!hook({\n\t\t\t\t\tkind: PolicyTrapKind.CONSTRUCT,\n\t\t\t\t\tpolicy,\n\t\t\t\t\tnewTarget,\n\t\t\t\t\targArray,\n\t\t\t\t\ttarget,\n\t\t\t\t\tpath: stringifyPath(inputPath)\n\t\t\t\t})) return {};\n\n\t\t\t\treturn Reflect.construct(<Function>target, argArray, newTarget);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * A trap for a function call. Used to create new proxies for methods on the retrieved module objects\n\t\t\t * @param {NodeRequire} target\n\t\t\t * @param thisArg\n\t\t\t * @param {unknown[]} argArray\n\t\t\t * @return {unknown}\n\t\t\t */\n\t\t\tapply (target: U, thisArg: unknown, argArray: unknown[] = []): unknown {\n\t\t\t\t// Don't proceed if the hook says no\n\t\t\t\tif (!hook({\n\t\t\t\t\tkind: PolicyTrapKind.APPLY,\n\t\t\t\t\tpolicy,\n\t\t\t\t\tthisArg,\n\t\t\t\t\targArray,\n\t\t\t\t\ttarget,\n\t\t\t\t\tpath: stringifyPath(inputPath)\n\t\t\t\t})) return;\n\n\t\t\t\treturn Reflect.apply(target as Function, thisArg, argArray);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Gets a trap for 'get' accesses\n\t\t\t * @param {U} target\n\t\t\t * @param {string} property\n\t\t\t * @param receiver\n\t\t\t * @return {unknown}\n\t\t\t */\n\t\t\tget (target: U, property: string, receiver: unknown): unknown {\n\t\t\t\tconst newPath = [...inputPath, property];\n\n\t\t\t\t// Don't proceed if the hook says no\n\t\t\t\tif (!hook({\n\t\t\t\t\tkind: PolicyTrapKind.GET,\n\t\t\t\t\tpolicy,\n\t\t\t\t\tpath: stringifyPath(newPath),\n\t\t\t\t\ttarget\n\t\t\t\t})) return;\n\n\t\t\t\tconst match = Reflect.get(target, property, receiver);\n\n\t\t\t\tconst config = Reflect.getOwnPropertyDescriptor(currentItem, property);\n\t\t\t\tif (config != null && config.configurable === false && config.writable === false) {\n\t\t\t\t\treturn currentItem[property as keyof U];\n\t\t\t\t}\n\t\t\t\treturn createAccessTrap(newPath, match);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn !canBeObserved(item) ? item : createAccessTrap([scope], item);\n}","export const enum PolicyTrapKind {\n\tGET = \"__$$_PROXY_GET\",\n\tAPPLY = \"__$$_PROXY_APPLY\",\n\tCONSTRUCT = \"__$$_PROXY_CONSTRUCT\"\n}\n\n/**\n * Stringifies the given PolicyTrapKind on the given path\n * @param {PolicyTrapKind} kind\n * @param {string} path\n * @return {string}\n */\nexport function stringifyPolicyTrapKindOnPath (kind: PolicyTrapKind, path: string): string {\n\tswitch (kind) {\n\t\tcase PolicyTrapKind.GET:\n\t\t\treturn `get ${path}`;\n\n\t\tcase PolicyTrapKind.APPLY:\n\t\t\treturn `${path}(...)`;\n\n\t\tcase PolicyTrapKind.CONSTRUCT:\n\t\t\treturn `new ${path}(...)`;\n\t}\n}","import {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}\n */\nexport const NETWORK_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\thttp2: {\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateSecureServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\n\thttps: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\trequest: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tget: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tglobalAgent: {\n\t\t\tdestroy: {\n\t\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t\t}\n\t\t},\n\t\tAgent: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\thttp: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\trequest: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tget: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tClientRequest: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tglobalAgent: {\n\t\t\tdestroy: {\n\t\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t\t}\n\t\t},\n\t\tAgent: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\n\tdgram: {\n\t\tcreateSocket: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\tdns: {\n\t\tlookup: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tlookupService: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve4: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolve6: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveAny: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveCname: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveMx: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveNaptr: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveNs: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolvePtr: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveSoa: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveSrv: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tresolveTxt: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\treverse: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tResolver: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\tnet: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateConnection: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t},\n\ttls: {\n\t\tcreateServer: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tcreateSecureContext: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tconnect: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\tServer: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t},\n\t\tTLSSocket: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: true\n\t\t}\n\t}\n};","import {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {NETWORK_MAP} from \"../network/network-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in identifiers and the members that produce non-deterministic results.\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}\n */\nexport const NONDETERMINISTIC_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\t// Any network operation will always be non-deterministic\n\t...NETWORK_MAP,\n\tMath: {\n\t\trandom: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t}\n\t},\n\tDate: {\n\t\tnow: {\n\t\t\t[PolicyTrapKind.APPLY]: true\n\t\t},\n\t\t// Dates that receive no arguments are nondeterministic since they care about \"now\" and will evaluate to a new value for each invocation\n\t\t[PolicyTrapKind.CONSTRUCT]: (...args) => args.length === 0 && !(args[0] instanceof Date)\n\t}\n};","import {PolicyTrapKind} from \"./policy-trap-kind\";\n\nexport type TrapConditionFunction<ConditionType> = (...args: unknown[]) => ConditionType;\nexport type TrapCondition<ConditionType> = ConditionType|TrapConditionFunction<ConditionType>;\n\nexport type PolicyTrapKindToTrapConditionMap<ConditionType> = {\n\t[key in PolicyTrapKind]?: TrapCondition<ConditionType>;\n};\n\nexport type TrapConditionMap<T, ConditionType = boolean> = {\n\t[Key in keyof T]?: TrapConditionMapValue<T[Key], ConditionType>;\n};\n\nexport type TrapConditionMemberMap<T, ConditionType> = {\n\t[Key in keyof T]?: TrapConditionMapValue<T[Key], ConditionType>;\n};\n\nexport type TrapConditionMapValue<T, ConditionType> = TrapCondition<ConditionType>|TrapConditionMemberMap<T, ConditionType>|PolicyTrapKindToTrapConditionMap<ConditionType>|undefined;\n\n/**\n * Returns true if the given item is a TrapCondition\n * @param {TrapConditionMapValue<T>>} item\n * @param {ConditionType} condition\n * @return {item is TrapCondition}\n */\nexport function isTrapCondition<ConditionType> (item: unknown, condition: ConditionType): item is TrapCondition<ConditionType> {\n\t// noinspection SuspiciousTypeOfGuard\n\treturn typeof item === (typeof condition) || typeof item === \"function\";\n}\n\n/**\n * Returns true if the given item is a TrapCondition\n * @param {TrapConditionMapValue<T>>} item\n * @return {item is TrapCondition}\n */\nexport function isTrapConditionFunction<T, ConditionType = boolean> (item: TrapConditionMapValue<T, ConditionType>): item is TrapConditionFunction<ConditionType> {\n\treturn typeof item === \"function\";\n}","import {isTrapCondition, isTrapConditionFunction, PolicyTrapKindToTrapConditionMap, TrapCondition, TrapConditionMap, TrapConditionMemberMap} from \"./trap-condition-map\";\nimport {IPolicyProxyApplyHookOptions, IPolicyProxyConstructHookOptions, PolicyProxyHookOptions} from \"../proxy/policy-proxy-hook\";\n\n/**\n * Returns true if the given path represents something that is nondeterministic.\n * @param {TrapConditionMap<T, ConditionType>} map\n * @param {ConditionType} condition\n * @param {PolicyProxyHookOptions<T>} item\n * @returns {boolean}\n */\nexport function isTrapConditionMet<T extends object, ConditionType = boolean> (map: TrapConditionMap<T, ConditionType>, condition: ConditionType, item: PolicyProxyHookOptions<T>): boolean {\n\tconst atoms = item.path.split(\".\") as (keyof T)[];\n\treturn walkAtoms(map, condition, item, atoms);\n}\n\n/**\n * Walks all atoms of the given item path\n * @param {TrapConditionMap<T, ConditionType>} map\n * @param {ConditionType} matchCondition\n * @param {PolicyProxyHookOptions<T>} item\n * @param {(keyof T)[]} atoms\n * @return {boolean}\n */\nfunction walkAtoms<T extends object, ConditionType = boolean> (map: TrapConditionMap<T, ConditionType>|TrapConditionMemberMap<T, ConditionType>, matchCondition: ConditionType, item: PolicyProxyHookOptions<T>, atoms: (keyof T)[]): boolean {\n\tconst [head, ...tail] = atoms;\n\tif (head == null) return false;\n\n\tconst mapEntry = map[head];\n\n\t// If nothing was matched within the namespace, the trap wasn't matched\n\tif (mapEntry == null) return false;\n\n\tif (isTrapCondition<ConditionType>(mapEntry, matchCondition)) {\n\t\treturn handleTrapCondition(mapEntry, matchCondition, item);\n\t}\n\n\telse {\n\t\tconst trapMapMatch = (mapEntry as PolicyTrapKindToTrapConditionMap<ConditionType>)[item.kind];\n\t\tif (trapMapMatch != null) {\n\t\t\treturn handleTrapCondition(trapMapMatch, matchCondition, item);\n\t\t}\n\n\t\telse {\n\t\t\treturn walkAtoms(mapEntry as TrapConditionMap<T, ConditionType>|TrapConditionMemberMap<T, ConditionType>, matchCondition, item, tail);\n\t\t}\n\t}\n}\n\n/**\n * Handles a TrapCondition\n * @param {TrapCondition<ConditionType>} trapCondition\n * @param {ConditionType} matchCondition\n * @param {PolicyProxyHookOptions<T>} item\n * @return {boolean}\n */\nfunction handleTrapCondition<T extends object, ConditionType> (trapCondition: TrapCondition<ConditionType>, matchCondition: ConditionType, item: PolicyProxyHookOptions<T>): boolean {\n\t// If matching the condition depends on the provided arguments, pass them in\n\tif (isTrapConditionFunction(trapCondition)) {\n\t\tconst castItem = item as IPolicyProxyApplyHookOptions<T>|IPolicyProxyConstructHookOptions<T>;\n\t\treturn trapCondition(...castItem.argArray) === matchCondition;\n\t}\n\n\t// Otherwise, evaluate the truthiness of the condition\n\telse {\n\t\treturn trapCondition === matchCondition;\n\t}\n}","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {NONDETERMINISTIC_MAP} from \"./nondeterministic-map\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given path represents something that is nondeterministic.\n * @param {PolicyProxyHookOptions<NodeBuiltInsAndGlobals>} item\n * @returns {boolean}\n */\nexport function isNonDeterministic (item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(NONDETERMINISTIC_MAP, true, item);\n}","import {IEvaluationErrorOptions} from \"./i-evaluation-error-options\";\nimport {Node} from \"typescript\";\n\n/**\n * A Base class for EvaluationErrors\n */\nexport class EvaluationError extends Error {\n\t/**\n\t * The node that caused or thew the error\n\t */\n\tpublic readonly node: Node;\n\n\tconstructor ({node, message}: IEvaluationErrorOptions) {\n\t\tsuper(message);\n\t\tError.captureStackTrace(this, this.constructor);\n\t\tthis.node = node;\n\t}\n}","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IPolicyErrorOptions} from \"./i-policy-error-options\";\nimport {IEvaluatePolicySanitized} from \"../../policy/i-evaluate-policy\";\n\n/**\n * An Error that can be thrown when a policy is violated\n */\nexport class PolicyError extends EvaluationError {\n\t/**\n\t * The kind of policy violation encountered\n\t * @type {string}\n\t */\n\tpublic readonly violation: keyof IEvaluatePolicySanitized;\n\n\tconstructor ({violation, node, message}: IPolicyErrorOptions) {\n\t\tsuper({node, message: `[${violation}]: ${message}`});\n\t\tthis.violation = violation;\n\t}\n}","import {INonDeterministicErrorOptions} from \"./i-non-deterministic-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when something nondeterministic is attempted to be evaluated and has been disallowed to be so\n */\nexport class NonDeterministicError extends PolicyError {\n\n\t/**\n\t * The kind of operation that was attempted to be performed but was in violation of the policy\n\t * @type {string}\n\t */\n\tpublic readonly operation: string;\n\n\tconstructor ({operation, node, message = `The operation: '${operation}' is nondeterministic. That is in violation of the policy`}: INonDeterministicErrorOptions) {\n\t\tsuper({violation: \"deterministic\", message, node});\n\n\t\tthis.operation = operation;\n\t}\n}","import {TrapConditionMap} from \"../trap-condition-map\";\nimport {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {IEvaluateIOPolicy} from \"../i-evaluate-policy\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals, \"read\"|\"write\">}\n */\nexport const IO_MAP: TrapConditionMap<NodeBuiltInsAndGlobals, keyof IEvaluateIOPolicy> = {\n\tfs: {\n\t\treadFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treadFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treaddir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treaddirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tread: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\treadSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\texists: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\texistsSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\taccess: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\taccessSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tclose: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcloseSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcreateReadStream: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tstat: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tstatSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\twatch: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\twatchFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tunwatchFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\trealpath: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\trealpathSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tfstat: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tfstatSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"read\"\n\t\t},\n\t\tcreateWriteStream: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tcopyFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tcopyFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tunlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tunlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trmdir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trmdirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tsymlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tsymlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\ttruncate: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\ttruncateSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tutimes: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tutimesSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tappendFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tappendFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twrite: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteFile: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\twriteFileSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchown: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tchownSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdir: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdirSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trename: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\trenameSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfutimes: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfutimesSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlink: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlinkSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tmkdtemp: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\topen: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\topenSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchown: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfchownSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tftruncate: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tftruncateSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfsync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfsyncSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfdatasync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tfdatasyncSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlchmod: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t},\n\t\tlchmodSync: {\n\t\t\t[PolicyTrapKind.APPLY]: \"write\"\n\t\t}\n\t}\n};","import {IO_MAP} from \"./io-map\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given member represents a READ operation from IO\n * @param {PolicyProxyHookOptions<NodeBuiltInsAndGlobals>} item\n * @returns {boolean}\n */\nexport function isIoRead (item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(IO_MAP, \"read\", item);\n}","import {IIoErrorOptions} from \"./i-io-error-options\";\nimport {PolicyError} from \"../policy-error\";\nimport {IEvaluateIOPolicy} from \"../../../policy/i-evaluate-policy\";\n\n/**\n * An Error that can be thrown when an IO operation is attempted to be executed that is in violation of the context policy\n */\nexport class IoError extends PolicyError {\n\t/**\n\t * The kind of IO operation that was violated\n\t * @type {keyof IEvaluateIOPolicy}\n\t */\n\tpublic readonly kind: keyof IEvaluateIOPolicy;\n\n\tconstructor ({node, kind, message = `${kind} operations are in violation of the policy`}: IIoErrorOptions) {\n\t\tsuper({violation: \"io\", message, node});\n\t\tthis.kind = kind;\n\t}\n}","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {IO_MAP} from \"./io-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given member represents a WRITE operation from IO\n * @param {PolicyProxyHookOptions<NodeBuiltInsAndGlobals>} item\n * @returns {boolean}\n */\nexport function isIoWrite (item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(IO_MAP, \"write\", item);\n}","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {NETWORK_MAP} from \"./network-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents a network operation\n * @param {PolicyProxyHookOptions<NodeBuiltInsAndGlobals>} item\n * @returns {boolean}\n */\nexport function isNetworkOperation (item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(NETWORK_MAP, true, item);\n}","import {INetworkErrorOptions} from \"./i-network-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when a network operation is attempted to be executed that is in violation of the context policy\n */\nexport class NetworkError extends PolicyError {\n\t/**\n\t * The kind of operation that was attempted to be performed but was in violation of the policy\n\t * @type {string}\n\t */\n\tpublic readonly operation: string;\n\n\tconstructor ({operation, node, message = `The operation: '${operation}' is performing network activity. That is in violation of the policy`}: INetworkErrorOptions) {\n\t\tsuper({violation: \"deterministic\", message, node});\n\n\t\tthis.operation = operation;\n\t}\n}","import {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {IEvaluateProcessPolicy} from \"../i-evaluate-policy\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules (as well as 'process' and the kind of IO operations their members performs\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals, string>}\n */\nexport const PROCESS_MAP: TrapConditionMap<NodeBuiltInsAndGlobals, keyof IEvaluateProcessPolicy> = {\n\tprocess: {\n\t\texit: {\n\t\t\t[PolicyTrapKind.APPLY]: \"exit\"\n\t\t}\n\t},\n\t// Everything inside child_process is just one big violation of this policy\n\tchild_process: {\n\t\t[PolicyTrapKind.APPLY]: \"spawnChild\"\n\t},\n\tcluster: {\n\t\tfork: {\n\t\t\t[PolicyTrapKind.APPLY]: \"spawnChild\"\n\t\t},\n\t\tworker: {\n\t\t\t[PolicyTrapKind.GET]: \"spawnChild\"\n\t\t},\n\t\tWorker: {\n\t\t\t[PolicyTrapKind.CONSTRUCT]: \"spawnChild\"\n\t\t},\n\t\tworkers: {\n\t\t\t[PolicyTrapKind.GET]: \"spawnChild\"\n\t\t}\n\n\t}\n};","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {PROCESS_MAP} from \"./process-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents a process operation that exits the process\n * @param {PolicyProxyHookOptions<NodeBuiltInsAndGlobals>} item\n * @returns {boolean}\n */\nexport function isProcessExitOperation (item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(PROCESS_MAP, \"exit\", item);\n}","import {IProcessErrorOptions} from \"./i-process-error-options\";\nimport {PolicyError} from \"../policy-error\";\nimport {IEvaluateProcessPolicy} from \"../../../policy/i-evaluate-policy\";\n\n/**\n * An Error that can be thrown when a Process operation is attempted to be executed that is in violation of the context policy\n */\nexport class ProcessError extends PolicyError {\n\t/**\n\t * The kind of process operation that was violated\n\t * @type {keyof IEvaluateProcessPolicy}\n\t */\n\tpublic readonly kind: keyof IEvaluateProcessPolicy;\n\n\tconstructor ({kind, node, message = `${kind} operations are in violation of the policy`}: IProcessErrorOptions) {\n\t\tsuper({violation: \"process\", message, node});\n\t\tthis.kind = kind;\n\t}\n}","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {PROCESS_MAP} from \"./process-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents a process operation that spawns a child\n * @param {PolicyProxyHookOptions<NodeBuiltInsAndGlobals>} item\n * @returns {boolean}\n */\nexport function isProcessSpawnChildOperation (item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(PROCESS_MAP, \"spawnChild\", item);\n}","import {PolicyTrapKind} from \"../policy-trap-kind\";\nimport {TrapConditionMap} from \"../trap-condition-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * A Map between built-in modules (as well as 'console' and the operations that print to console\n * @type {TrapConditionMap<NodeBuiltInsAndGlobals>}\n */\nexport const CONSOLE_MAP: TrapConditionMap<NodeBuiltInsAndGlobals> = {\n\tconsole: {\n\t\t[PolicyTrapKind.APPLY]: true\n\t}\n};","import {PolicyProxyHookOptions} from \"../../proxy/policy-proxy-hook\";\nimport {isTrapConditionMet} from \"../is-trap-condition-met\";\nimport {CONSOLE_MAP} from \"./console-map\";\nimport {NodeBuiltInsAndGlobals} from \"../../environment/node/node-built-ins-and-globals\";\n\n/**\n * Returns true if the given item represents an operation that prints to console\n * @param {PolicyProxyHookOptions<NodeBuiltInsAndGlobals>} item\n * @returns {boolean}\n */\nexport function isConsoleOperation (item: PolicyProxyHookOptions<NodeBuiltInsAndGlobals>): boolean {\n\treturn isTrapConditionMet(CONSOLE_MAP, true, item);\n}","import {IndexLiteral} from \"../literal/literal\";\nimport {createPolicyProxy} from \"../proxy/create-policy-proxy\";\nimport {stringifyPolicyTrapKindOnPath} from \"../policy/policy-trap-kind\";\nimport {isNonDeterministic} from \"../policy/nondeterministic/is-nondeterministic\";\nimport {NonDeterministicError} from \"../error/policy-error/non-deterministic-error/non-deterministic-error\";\nimport {PolicyProxyHookOptions} from \"../proxy/policy-proxy-hook\";\nimport {isIoRead} from \"../policy/io/is-io-read\";\nimport {IoError} from \"../error/policy-error/io-error/io-error\";\nimport {isIoWrite} from \"../policy/io/is-io-write\";\nimport {isNetworkOperation} from \"../policy/network/is-network-operation\";\nimport {NetworkError} from \"../error/policy-error/network-error/network-error\";\nimport {isProcessExitOperation} from \"../policy/process/is-process-exit-operation\";\nimport {ProcessError} from \"../error/policy-error/process-error/process-error\";\nimport {isProcessSpawnChildOperation} from \"../policy/process/is-process-spawn-child-operation\";\nimport {ICreateSanitizedEnvironmentOptions} from \"./i-create-sanitized-environment-options\";\nimport {isConsoleOperation} from \"../policy/console/is-console-operation\";\n\n// tslint:disable:no-any\n\n/**\n * Creates an environment that provide hooks into policy checks\n * @param {ICreateSanitizedEnvironmentOptions} options\n * @return {IndexLiteral}\n */\nexport function createSanitizedEnvironment ({policy, env, getCurrentNode}: ICreateSanitizedEnvironmentOptions): IndexLiteral {\n\n\tconst hook = (item: PolicyProxyHookOptions<any>) => {\n\n\t\tif (!policy.console && isConsoleOperation(item)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!policy.io.read && isIoRead(item)) {\n\t\t\tthrow new IoError({kind: \"read\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.io.write && isIoWrite(item)) {\n\t\t\tthrow new IoError({kind: \"write\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.process.exit && isProcessExitOperation(item)) {\n\t\t\tthrow new ProcessError({kind: \"exit\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.process.exit && isProcessSpawnChildOperation(item)) {\n\t\t\tthrow new ProcessError({kind: \"spawnChild\", node: getCurrentNode()});\n\t\t}\n\n\t\tif (!policy.network && isNetworkOperation(item)) {\n\t\t\tthrow new NetworkError({operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode()});\n\t\t}\n\n\t\tif (policy.deterministic && isNonDeterministic(item)) {\n\t\t\tthrow new NonDeterministicError({operation: stringifyPolicyTrapKindOnPath(item.kind, item.path), node: getCurrentNode()});\n\t\t}\n\n\t\treturn true;\n\t};\n\n\tconst descriptors = Object.entries(Object.getOwnPropertyDescriptors(env));\n\tconst gettersAndSetters = Object.assign({}, ...descriptors\n\t\t.filter(([_, descriptor]) => !(\"value\" in descriptor))\n\t\t.map(([name, descriptor]) => ({[name]: descriptor}))\n\t);\n\n\tconst values = Object.assign({}, ...descriptors\n\t\t.filter(([_, descriptor]) => \"value\" in descriptor)\n\t\t.map(([name, descriptor]) => ({\n\t\t\t[name]: name === \"require\" ? new Proxy(descriptor.value as NodeRequire, {\n\n\t\t\t\t\t/**\n\t\t\t\t\t * A trap for a function call. Used to create new proxies for methods on the retrieved module objects\n\t\t\t\t\t * @param {NodeRequire} target\n\t\t\t\t\t * @param thisArg\n\t\t\t\t\t * @param {unknown[]} argArray\n\t\t\t\t\t * @return {unknown}\n\t\t\t\t\t */\n\t\t\t\t\tapply (target: NodeRequire, thisArg: unknown, argArray: unknown[] = []): unknown {\n\t\t\t\t\t\tconst [moduleName] = argArray as string[];\n\n\t\t\t\t\t\treturn createPolicyProxy({\n\t\t\t\t\t\t\tpolicy,\n\t\t\t\t\t\t\titem: Reflect.apply(target, thisArg, argArray),\n\t\t\t\t\t\t\tscope: moduleName,\n\t\t\t\t\t\t\thook\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t: createPolicyProxy({\n\t\t\t\t\tpolicy,\n\t\t\t\t\titem: descriptor.value as object,\n\t\t\t\t\tscope: name,\n\t\t\t\t\thook\n\t\t\t\t})\n\t\t})));\n\n\treturn Object.defineProperties(values, {\n\t\t...gettersAndSetters\n\t});\n}","import {IndexLiteral} from \"../../literal/literal\";\n\nexport const ECMA_GLOBALS = () => {\n\tconst base: IndexLiteral = {\n\t\tInfinity,\n\t\tNaN,\n\t\tundefined,\n\t\tisNaN,\n\t\tparseFloat,\n\t\tparseInt,\n\t\tdecodeURI,\n\t\tdecodeURIComponent,\n\t\tencodeURI,\n\t\tencodeURIComponent,\n\t\tArray,\n\t\tBoolean,\n\t\tDate,\n\t\tError,\n\t\tEvalError,\n\t\tNumber,\n\t\tObject,\n\t\tRangeError,\n\t\tReferenceError,\n\t\tRegExp,\n\t\tString,\n\t\tSyntaxError,\n\t\tTypeError,\n\t\tURIError,\n\t\tJSON,\n\t\tMath,\n\t\tescape,\n\t\tunescape,\n\t\teval,\n\t\tFunction\n\t};\n\n\ttry {\n\t\tbase.BigInt = BigInt;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Reflect = Reflect;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.WeakMap = WeakMap;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.WeakSet = WeakSet;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Set = Set;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Map = Map;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Uint8Array = Uint8Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Uint8ClampedArray = Uint8ClampedArray;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Uint16Array = Uint16Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Uint32Array = Uint32Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Intl = Intl;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Int8Array = Int8Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Int16Array = Int16Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Int32Array = Int32Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Float32Array = Float32Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Float64Array = Float64Array;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.ArrayBuffer = ArrayBuffer;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.DataView = DataView;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.isFinite = isFinite;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Promise = Promise;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Proxy = Proxy;\n\t} catch {\n\t}\n\n\ttry {\n\t\tbase.Symbol = Symbol;\n\t} catch {\n\t}\n\n\treturn base;\n};","/**\n * Merges all of the given descriptors\n * @param {A} a\n * @return {A}\n */\nexport function mergeDescriptors<A extends object> (a: A): A;\nexport function mergeDescriptors<A extends object, B extends object> (a: A, b: B): A & B;\nexport function mergeDescriptors<A extends object, B extends object, C extends object> (a: A, b: B, c: C): A & B & C;\nexport function mergeDescriptors<A extends object, B extends object, C extends object> (a: A, b?: B, c?: C): A & B & C {\n\tconst newObj = {} as A & B & C;\n\tconst normalizedB = b == null ? {} : b;\n\tconst normalizedC = c == null ? {} : c;\n\t[a, normalizedB, normalizedC].forEach(item => Object.defineProperties(newObj, Object.getOwnPropertyDescriptors(item)));\n\treturn newObj;\n}","export type Subtract<T, K extends Partial<T>> = {\n\t[Key in Exclude<keyof T, keyof K>]: T[Key];\n};\n\n/**\n * Excludes the properties of B from A\n * @param {A} a\n * @param {B} b\n * @return {Exclude<A, B>}\n */\nexport function subtract<A extends object, B extends Partial<A>> (a: A, b: B): Subtract<A, B> {\n\tconst newA = {} as Exclude<A, keyof B>;\n\tObject.getOwnPropertyNames(a).forEach((name) => {\n\t\tif (!(name in b)) {\n\t\t\tObject.defineProperty(newA, name, Object.getOwnPropertyDescriptor(a, name)!);\n\t\t}\n\t});\n\treturn newA;\n}","import {mergeDescriptors} from \"../../util/descriptor/merge-descriptors\";\nimport {ECMA_GLOBALS} from \"../ecma/ecma-globals\";\nimport {subtract} from \"../../util/object/subtract\";\nimport {dirname} from \"path\";\n\nexport const NODE_GLOBALS = () => {\n\tconst ecmaGlobals = ECMA_GLOBALS();\n\tconst merged = mergeDescriptors(\n\t\tsubtract(global, ecmaGlobals),\n\t\tecmaGlobals,\n\t\t{\n\t\t\trequire,\n\t\t\t__dirname: (fileName: string) => dirname(fileName),\n\t\t\t__filename: (fileName: string) => fileName\n\t\t}\n\t);\n\n\tObject.defineProperties(merged, {\n\t\tglobal: {\n\t\t\tget (): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t},\n\t\tglobalThis: {\n\t\t\tget (): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn merged;\n};","export enum EnvironmentPresetKind {\n\tNONE = \"NONE\",\n\tECMA = \"ECMA\",\n\tBROWSER = \"BROWSER\",\n\tNODE = \"NODE\"\n}","export interface IRafImplementationNamespace {\n\trequestAnimationFrame (callback: FrameRequestCallback): number;\n\tcancelAnimationFrame (handle: number): void;\n}\n\n/**\n * Returns an object containing the properties that are relevant to 'requestAnimationFrame' and 'requestIdleCallback'\n * @param {typeof window} global\n */\nexport function rafImplementation (global: typeof window): IRafImplementationNamespace {\n\tlet lastTime = 0;\n\n\tconst _requestAnimationFrame = function requestAnimationFrame (callback: FrameRequestCallback): number {\n\n\t\tconst currTime = new Date().getTime();\n\n\t\tconst timeToCall = Math.max(0, 16 - (currTime - lastTime));\n\n\t\tconst id = global.setTimeout(function () {\n\t\t\tcallback(currTime + timeToCall);\n\t\t}, timeToCall);\n\n\t\tlastTime = currTime + timeToCall;\n\n\t\treturn id;\n\n\t};\n\n\tconst _cancelAnimationFrame = function cancelAnimationFrame (id: number): void {\n\t\tclearTimeout(id);\n\t};\n\n\treturn {\n\t\trequestAnimationFrame: _requestAnimationFrame,\n\t\tcancelAnimationFrame: _cancelAnimationFrame\n\t};\n\n}","import {DOMWindow, JSDOM} from \"jsdom\";\nimport {mergeDescriptors} from \"../../util/descriptor/merge-descriptors\";\nimport {ECMA_GLOBALS} from \"../ecma/ecma-globals\";\nimport {subtract} from \"../../util/object/subtract\";\nimport {rafImplementation} from \"./lib/raf\";\n\nexport const BROWSER_GLOBALS = () => {\n\tconst {window} = new JSDOM(\"\", {url: \"https://example.com\"});\n\tconst ecmaGlobals = ECMA_GLOBALS();\n\tconst raf = rafImplementation(window as unknown as Window & typeof globalThis);\n\tconst merged = mergeDescriptors(\n\t\tsubtract(window, ecmaGlobals as Partial<DOMWindow>),\n\t\tsubtract(raf, window),\n\t\tecmaGlobals\n\t);\n\n\tObject.defineProperties(merged, {\n\t\twindow: {\n\t\t\tget (): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t},\n\t\tglobalThis: {\n\t\t\tget (): typeof merged {\n\t\t\t\treturn merged;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn merged;\n};","export const RETURN_SYMBOL = \"[return]\";","export const BREAK_SYMBOL = \"[break]\";","export const CONTINUE_SYMBOL = \"[continue]\";","export const THIS_SYMBOL = \"this\";","export const SUPER_SYMBOL = \"super\";","import {IndexLiteral, Literal, LiteralMatch} from \"../literal/literal\";\nimport {del, get, has, set} from \"object-path\";\nimport {createSanitizedEnvironment} from \"../environment/create-sanitized-environment\";\nimport {ECMA_GLOBALS} from \"../environment/ecma/ecma-globals\";\nimport {NODE_GLOBALS} from \"../environment/node/node-globals\";\nimport {EnvironmentPresetKind} from \"../environment/environment-preset-kind\";\nimport {BROWSER_GLOBALS} from \"../environment/browser/browser-globals\";\nimport {mergeDescriptors} from \"../util/descriptor/merge-descriptors\";\nimport {ISetInLexicalEnvironmentOptions} from \"./i-set-in-lexical-environment-options\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {Node} from \"typescript\";\nimport {ICreateLexicalEnvironmentOptions} from \"./i-create-lexical-environment-options\";\n\nexport interface LexicalEnvironment {\n\tparentEnv: LexicalEnvironment|undefined;\n\tenv: IndexLiteral;\n\tpreset?: EnvironmentPresetKind;\n}\n\n/**\n * Gets a value from a Lexical Environment\n * @param {LexicalEnvironment} env\n * @param {string} path\n * @returns {LexicalEnvironment[\"env]|undefined}\n */\nexport function getRelevantDictFromLexicalEnvironment (env: LexicalEnvironment, path: string): LexicalEnvironment[\"env\"]|undefined {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding)) return env.env;\n\tif (env.parentEnv != null) return getRelevantDictFromLexicalEnvironment(env.parentEnv, path);\n\treturn undefined;\n}\n\n/**\n * Gets the EnvironmentPresetKind for the given LexicalEnvironment\n * @param {LexicalEnvironment} env\n * @return {EnvironmentPresetKind}\n */\nexport function getPresetForLexicalEnvironment (env: LexicalEnvironment): EnvironmentPresetKind {\n\tif (env.preset != null) return env.preset;\n\telse if (env.parentEnv != null) return getPresetForLexicalEnvironment(env.parentEnv);\n\telse return EnvironmentPresetKind.NONE;\n}\n\n/**\n * Gets a value from a Lexical Environment\n * @param {Node?} node\n * @param {LexicalEnvironment} env\n * @param {string} path\n * @returns {LiteralMatch?}\n */\nexport function getFromLexicalEnvironment (node: Node|undefined, env: LexicalEnvironment, path: string): LiteralMatch|undefined {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding)) {\n\t\tconst literal = get(env.env, path);\n\t\tswitch (path) {\n\t\t\t// If we're in a Node environment, the \"__dirname\" and \"__filename\" meta-properties should report the current directory or file of the SourceFile and not the parent process\n\t\t\tcase \"__dirname\":\n\t\t\tcase \"__filename\":\n\t\t\t\tconst preset = getPresetForLexicalEnvironment(env);\n\t\t\t\treturn preset === EnvironmentPresetKind.NODE && typeof literal === \"function\" && node != null\n\t\t\t\t\t? {literal: literal(node.getSourceFile().fileName)}\n\t\t\t\t\t: {literal};\n\t\t\tdefault:\n\t\t\t\treturn {literal};\n\t\t}\n\t}\n\n\tif (env.parentEnv != null) return getFromLexicalEnvironment(node, env.parentEnv, path);\n\treturn undefined;\n}\n\n/**\n * Returns true if the given lexical environment contains a value on the given path that equals the given literal\n * @param {Node} node\n * @param {LexicalEnvironment} env\n * @param {Literal} equals\n * @param {string[]} matchPaths\n * @returns {boolean}\n */\nexport function pathInLexicalEnvironmentEquals (node: Node, env: LexicalEnvironment, equals: Literal, ...matchPaths: string[]): boolean {\n\treturn matchPaths.some(path => {\n\t\tconst match = getFromLexicalEnvironment(node, env, path);\n\t\treturn match == null ? false : match.literal === equals;\n\t});\n}\n\n/**\n * Returns true if the given value represents an internal symbol\n * @param {Literal} value\n * @return {boolean}\n */\nexport function isInternalSymbol (value: Literal): boolean {\n\tswitch (value) {\n\t\tcase RETURN_SYMBOL:\n\t\tcase BREAK_SYMBOL:\n\t\tcase CONTINUE_SYMBOL:\n\t\tcase THIS_SYMBOL:\n\t\tcase SUPER_SYMBOL:\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Gets a value from a Lexical Environment\n * @param {ISetInLexicalEnvironmentOptions} options\n * @param {boolean} [newBinding=false]\n */\nexport function setInLexicalEnvironment ({env, path, value, reporting, node, newBinding = false}: ISetInLexicalEnvironmentOptions): void {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding) || newBinding || env.parentEnv == null) {\n\t\t// If the value didn't change, do no more\n\t\tif (has(env.env, path) && get(env.env, path) === value) return;\n\n\t\t// Otherwise, mutate it\n\t\tset(env.env, path, value);\n\n\t\t// Inform reporting hooks if any is given\n\t\tif (reporting.reportBindings != null && !isInternalSymbol(path)) {\n\t\t\treporting.reportBindings({path, value, node});\n\t\t}\n\t}\n\n\telse {\n\t\tlet currentParentEnv: LexicalEnvironment|undefined = env.parentEnv;\n\t\twhile (currentParentEnv != null) {\n\t\t\tif (has(currentParentEnv.env, firstBinding)) {\n\t\t\t\t// If the value didn't change, do no more\n\t\t\t\tif (has(currentParentEnv.env, path) && get(currentParentEnv.env, path) === value) return;\n\n\t\t\t\t// Otherwise, mutate it\n\t\t\t\tset(currentParentEnv.env, path, value);\n\n\t\t\t\t// Inform reporting hooks if any is given\n\t\t\t\tif (reporting.reportBindings != null && !isInternalSymbol(path)) {\n\t\t\t\t\treporting.reportBindings({path, value, node});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrentParentEnv = currentParentEnv.parentEnv;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Clears a binding from a Lexical Environment\n * @param {LexicalEnvironment} env\n * @param {string} path\n */\nexport function clearBindingFromLexicalEnvironment (env: LexicalEnvironment, path: string): void {\n\tconst [firstBinding] = path.split(\".\");\n\tif (has(env.env, firstBinding)) {\n\t\tdel(env.env, path);\n\t}\n\n\telse {\n\t\tlet currentParentEnv: LexicalEnvironment|undefined = env.parentEnv;\n\t\twhile (currentParentEnv != null) {\n\t\t\tif (has(currentParentEnv.env, firstBinding)) {\n\t\t\t\tdel(currentParentEnv.env, path);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcurrentParentEnv = currentParentEnv.parentEnv;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Creates a Lexical Environment\n * @param {ICreateLexicalEnvironmentOptions} options\n * @returns {Promise<LexicalEnvironment>}\n */\nexport function createLexicalEnvironment ({inputEnvironment: {extra, preset}, policy, getCurrentNode}: ICreateLexicalEnvironmentOptions): LexicalEnvironment {\n\n\tlet envInput: IndexLiteral;\n\n\tswitch (preset) {\n\t\tcase EnvironmentPresetKind.NONE:\n\t\t\tenvInput = mergeDescriptors(extra);\n\t\t\tbreak;\n\n\t\tcase EnvironmentPresetKind.ECMA:\n\t\t\tenvInput = mergeDescriptors(ECMA_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tcase EnvironmentPresetKind.NODE:\n\t\t\tenvInput = mergeDescriptors(NODE_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tcase EnvironmentPresetKind.BROWSER:\n\t\t\tenvInput = mergeDescriptors(BROWSER_GLOBALS(), extra);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tenvInput = {};\n\t\t\tbreak;\n\t}\n\n\treturn {\n\t\tpreset,\n\t\tparentEnv: undefined,\n\t\tenv: createSanitizedEnvironment({\n\t\t\tpolicy,\n\t\t\tenv: envInput,\n\t\t\tgetCurrentNode\n\t\t})\n\t};\n}","import {SyntaxKind, Token} from \"typescript\";\n\n/**\n * Returns true if the given node is a BooleanLiteral\n * @param {*} node\n * @returns {node is ts.Token<ts.SyntaxKind.TrueKeyword | ts.SyntaxKind.FalseKeyword>}\n */\nexport function isBooleanLiteral (node: { kind: SyntaxKind }): node is Token<SyntaxKind.TrueKeyword|SyntaxKind.FalseKeyword> {\n\treturn node.kind === SyntaxKind.TrueKeyword || node.kind === SyntaxKind.FalseKeyword;\n}","import {Node, NullLiteral, SyntaxKind} from \"typescript\";\n\n/**\n * Returns true if the given node is a NullLiteral\n * @param {Node} node\n * @returns {node is SuperExpression}\n */\nexport function isNullLiteral (node: Node): node is NullLiteral {\n\treturn node.kind === SyntaxKind.NullKeyword;\n}","import {isBigIntLiteral, isIdentifier, isNumericLiteral, isRegularExpressionLiteral, isStringLiteralLike, Node, SyntaxKind} from \"typescript\";\nimport {EvaluateSimpleLiteralResult} from \"./evaluate-simple-literal-result\";\nimport {isBooleanLiteral} from \"../../util/node/is-boolean-literal\";\nimport {isNullLiteral} from \"../../util/node/is-null-literal\";\n\n/**\n * This is a tiny function that avoids the costs of building up an evaluation environment\n * for the interpreter. If the node is a simple literal, it will return its' value.\n * @param {Node} node\n * @returns {EvaluateSimpleLiteralResult}\n */\nexport function evaluateSimpleLiteral (node: Node): EvaluateSimpleLiteralResult {\n\tif (isStringLiteralLike(node)) return {success: true, value: node.text};\n\telse if (isBooleanLiteral(node)) return {success: true, value: node.kind === SyntaxKind.TrueKeyword};\n\telse if (isRegularExpressionLiteral(node)) return {success: true, value: new Function(`return ${node.text}`)()};\n\telse if (isNumericLiteral(node)) return {success: true, value: Number(node.text)};\n\telse if (isBigIntLiteral(node)) return {success: true, value: BigInt(node.text)};\n\telse if (isIdentifier(node) && node.text === \"Infinity\") return {success: true, value: Infinity};\n\telse if (isIdentifier(node) && node.text === \"NaN\") return {success: true, value: NaN};\n\telse if (isIdentifier(node) && node.text === \"null\") return {success: true, value: null};\n\telse if (isIdentifier(node) && node.text === \"undefined\") return {success: true, value: undefined};\n\telse if (isNullLiteral(node)) return {success: true, value: null};\n\telse return {success: false};\n}","import {IMaxOpsExceededErrorOptions} from \"./i-max-ops-exceeded-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded\n */\nexport class MaxOpsExceededError extends PolicyError {\n\t/**\n\t * The amount of operations performed before creating this error instance\n\t */\n\tpublic readonly ops: number;\n\n\tconstructor ({ops, node, message = `Maximum ops exceeded: ${ops}`}: IMaxOpsExceededErrorOptions) {\n\t\tsuper({violation: \"maxOps\", message, node});\n\t\tthis.ops = ops;\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {isIdentifier, VariableDeclaration} from \"typescript\";\nimport {EvaluationError} from \"../error/evaluation-error/evaluation-error\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableDeclaration\n * @param {IEvaluatorOptions<VariableDeclaration>} options\n * @param {Literal} [initializer\n */\nexport function evaluateVariableDeclaration ({node, environment, evaluate, stack, statementTraversalStack}: IEvaluatorOptions<VariableDeclaration>, initializer?: Literal): void {\n\n\tconst initializerResult = initializer != null ? initializer : node.initializer == null\n\t\t// A VariableDeclaration with no initializer is implicitly bound to 'undefined'\n\t\t? undefined\n\t\t: evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\t// There's no way of destructuring a nullable value\n\tif (initializerResult == null && !isIdentifier(node.name)) {\n\t\tthrow new EvaluationError({node});\n\t}\n\n\t// Evaluate the binding name\n\tevaluate.nodeWithArgument(node.name, environment, initializerResult, statementTraversalStack);\n\tstack.push(initializerResult);\n}","import {SyntaxKind, ThisExpression, Node} from \"typescript\";\n\n/**\n * Returns true if the given node is a ThisExpression\n * @param {Node} node\n * @returns {node is ThisExpression}\n */\nexport function isThisExpression (node: Node): node is ThisExpression {\n\treturn node.kind === SyntaxKind.ThisKeyword;\n}","import {Node, SuperExpression, SyntaxKind} from \"typescript\";\n\n/**\n * Returns true if the given node is a SuperExpression\n * @param {Node} node\n * @returns {node is SuperExpression}\n */\nexport function isSuperExpression (node: Node): node is SuperExpression {\n\treturn node.kind === SyntaxKind.SuperKeyword;\n}","import {isElementAccessExpression, isFunctionDeclaration, isIdentifier, isParenthesizedExpression, isPropertyAccessExpression, isTypeAssertion, Node} from \"typescript\";\nimport {isThisExpression} from \"../util/node/is-this-expression\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {isSuperExpression} from \"../util/node/is-super-expression\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {IEvaluatorOptions} from \"../evaluator/i-evaluator-options\";\n\n/**\n * Gets the path to \"dot\" into an object with based on the node. For example, if the node is a simple identifier, say, 'foo', the dot path is simply \"foo\".\n * And, if it is a PropertyAccessExpression, that path may be \"console.log\" for example\n * @param {IEvaluatorOptions<Node>} options\n * @returns {Promise<string?>}\n */\nexport function getDotPathFromNode<T extends Node> ({node, evaluate, ...rest}: IEvaluatorOptions<T>): string|undefined {\n\tif (isIdentifier(node)) {\n\t\treturn node.text;\n\t}\n\n\telse if (isThisExpression(node)) {\n\t\treturn THIS_SYMBOL;\n\t}\n\n\telse if (isSuperExpression(node)) {\n\t\treturn SUPER_SYMBOL;\n\t}\n\n\telse if (isParenthesizedExpression(node)) {\n\t\treturn getDotPathFromNode({node: node.expression, evaluate, ...rest});\n\t}\n\telse if (isTypeAssertion(node)) {\n\t\treturn getDotPathFromNode({node: node.expression, evaluate, ...rest});\n\t}\n\n\telse if (isPropertyAccessExpression(node)) {\n\t\tlet leftHand = getDotPathFromNode({node: node.expression, evaluate, ...rest});\n\t\tif (leftHand == null) leftHand = (evaluate.expression(node.expression, rest.environment, rest.statementTraversalStack)) as string;\n\t\tlet rightHand = getDotPathFromNode({node: node.name, evaluate, ...rest});\n\t\tif (rightHand == null) rightHand = (evaluate.expression(node.name, rest.environment, rest.statementTraversalStack)) as string;\n\n\t\tif (leftHand == null || rightHand == null) return undefined;\n\t\treturn `${leftHand}.${rightHand}`;\n\t}\n\n\telse if (isElementAccessExpression(node)) {\n\t\tlet leftHand = getDotPathFromNode({node: node.expression, evaluate, ...rest});\n\t\tif (leftHand == null) leftHand = (evaluate.expression(node.expression, rest.environment, rest.statementTraversalStack)) as string;\n\t\tconst rightHand = (evaluate.expression(node.argumentExpression, rest.environment, rest.statementTraversalStack)) as string;\n\n\t\tif (leftHand == null || rightHand == null) return undefined;\n\t\treturn `${leftHand}.${rightHand}`;\n\t}\n\n\telse if (isFunctionDeclaration(node)) {\n\t\tif (node.name == null) return undefined;\n\t\treturn node.name.text;\n\t}\n\n\treturn undefined;\n}","import {SyntaxKind} from \"typescript\";\nimport {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IUnexpectedNodeErrorOptions} from \"./i-unexpected-node-error-options\";\n\n/**\n * An Error that can be thrown when an unexpected node is encountered\n */\nexport class UnexpectedNodeError extends EvaluationError {\n\n\tconstructor ({node, message = `Unexpected Node: '${SyntaxKind[node.kind]}'`}: IUnexpectedNodeErrorOptions) {\n\t\tsuper({message, node});\n\t}\n}","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IUndefinedLeftValueErrorOptions} from \"./i-undefined-left-value-error-options\";\n\n/**\n * An Error that can be thrown when an undefined leftValue is encountered\n */\nexport class UndefinedLeftValueError extends EvaluationError {\n\n\tconstructor ({node, message = `'No leftValue could be determined'`}: IUndefinedLeftValueErrorOptions) {\n\t\tsuper({message, node});\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {BinaryExpression, SyntaxKind} from \"typescript\";\nimport {getDotPathFromNode} from \"../lexical-environment/get-dot-path-from-node\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {UndefinedLeftValueError} from \"../error/undefined-left-value-error/undefined-left-value-error\";\n\n// tslint:disable:strict-boolean-expressions\n\n/**\n * Evaluates, or attempts to evaluate, a BinaryExpression\n * @param {IEvaluatorOptions<BinaryExpression>} options\n * @returns {Literal}\n */\nexport function evaluateBinaryExpression ({node, environment, evaluate, logger, statementTraversalStack, reporting, ...rest}: IEvaluatorOptions<BinaryExpression>): Literal {\n\tconst leftValue = (evaluate.expression(node.left, environment, statementTraversalStack)) as number;\n\tconst rightValue = (evaluate.expression(node.right, environment, statementTraversalStack)) as number;\n\tconst leftIdentifier = getDotPathFromNode({node: node.left, environment, evaluate, logger, statementTraversalStack, reporting, ...rest});\n\n\tconst operator = node.operatorToken.kind;\n\tswitch (operator) {\n\n\t\tcase SyntaxKind.AmpersandToken: {\n\t\t\treturn leftValue & rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.AmpersandAmpersandToken: {\n\t\t\treturn leftValue && rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.AmpersandEqualsToken:\n\t\tcase SyntaxKind.CaretEqualsToken:\n\t\tcase SyntaxKind.BarEqualsToken:\n\t\tcase SyntaxKind.MinusEqualsToken:\n\t\tcase SyntaxKind.PlusEqualsToken:\n\t\tcase SyntaxKind.PercentEqualsToken:\n\t\tcase SyntaxKind.SlashEqualsToken:\n\t\tcase SyntaxKind.AsteriskEqualsToken:\n\t\tcase SyntaxKind.AsteriskAsteriskEqualsToken:\n\t\tcase SyntaxKind.LessThanLessThanEqualsToken:\n\t\tcase SyntaxKind.GreaterThanGreaterThanEqualsToken:\n\t\tcase SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken: {\n\n\t\t\t// There's nothing in the engine restricting you from applying this kind of arithmetic operation on non-numeric data types\n\t\t\tlet computedValue = leftValue;\n\t\t\tswitch (operator) {\n\t\t\t\tcase SyntaxKind.AmpersandEqualsToken:\n\t\t\t\t\tcomputedValue &= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.CaretEqualsToken:\n\t\t\t\t\tcomputedValue ^= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.BarEqualsToken:\n\t\t\t\t\tcomputedValue |= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.AsteriskEqualsToken:\n\t\t\t\t\tcomputedValue *= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.AsteriskAsteriskEqualsToken:\n\t\t\t\t\tcomputedValue **= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.LessThanLessThanEqualsToken:\n\t\t\t\t\tcomputedValue <<= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.GreaterThanGreaterThanEqualsToken:\n\t\t\t\t\tcomputedValue >>= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:\n\t\t\t\t\tcomputedValue >>>= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.MinusEqualsToken:\n\t\t\t\t\tcomputedValue -= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.PlusEqualsToken:\n\t\t\t\t\tcomputedValue += rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.PercentEqualsToken:\n\t\t\t\t\tcomputedValue %= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t\tcase SyntaxKind.SlashEqualsToken:\n\t\t\t\t\tcomputedValue /= rightValue;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Update to the left-value within the environment if it exists there and has been updated\n\t\t\tif (leftIdentifier != null) {\n\t\t\t\tsetInLexicalEnvironment({env: environment, path: leftIdentifier, value: computedValue, reporting, node});\n\t\t\t}\n\n\t\t\t// Return the computed value\n\t\t\treturn computedValue;\n\t\t}\n\n\t\tcase SyntaxKind.AsteriskToken: {\n\t\t\treturn leftValue * rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.AsteriskAsteriskToken: {\n\t\t\treturn leftValue ** rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.BarToken: {\n\t\t\treturn leftValue | rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.BarBarToken: {\n\t\t\treturn leftValue || rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.CaretToken: {\n\t\t\treturn leftValue ^ rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.CommaToken: {\n\t\t\treturn rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.MinusToken:\n\t\t\treturn leftValue - rightValue;\n\n\t\tcase SyntaxKind.PlusToken:\n\t\t\tlogger.logResult(leftValue + rightValue, \"BinaryExpression (PlusToken)\");\n\t\t\treturn leftValue + rightValue;\n\n\t\tcase SyntaxKind.PercentToken:\n\t\t\treturn leftValue % rightValue;\n\n\t\tcase SyntaxKind.SlashToken:\n\t\t\treturn leftValue / rightValue;\n\n\t\tcase SyntaxKind.EqualsToken: {\n\t\t\t// Update to the left-value within the environment if it exists there and has been updated\n\t\t\tif (leftIdentifier != null) {\n\t\t\t\tsetInLexicalEnvironment({env: environment, path: leftIdentifier, value: rightValue, reporting, node});\n\t\t\t\tlogger.logBinding(leftIdentifier, rightValue, \"Assignment\");\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tthrow new UndefinedLeftValueError({node: node.left});\n\t\t\t}\n\n\t\t\t// The return value of an assignment is always the assigned value\n\t\t\treturn rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.EqualsEqualsToken: {\n\t\t\t// tslint:disable:triple-equals\n\t\t\treturn leftValue == rightValue;\n\t\t\t// tslint:enable:triple-equals\n\t\t}\n\n\t\tcase SyntaxKind.EqualsEqualsEqualsToken: {\n\t\t\treturn leftValue === rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.ExclamationEqualsToken: {\n\t\t\t// tslint:disable:triple-equals\n\t\t\treturn leftValue != rightValue;\n\t\t\t// tslint:enable:triple-equals\n\t\t}\n\n\t\tcase SyntaxKind.ExclamationEqualsEqualsToken: {\n\t\t\treturn leftValue !== rightValue;\n\t\t}\n\n\t\tcase SyntaxKind.GreaterThanToken:\n\t\t\treturn leftValue > rightValue;\n\n\t\tcase SyntaxKind.GreaterThanEqualsToken:\n\t\t\treturn leftValue >= rightValue;\n\n\t\tcase SyntaxKind.LessThanToken:\n\t\t\treturn leftValue < rightValue;\n\n\t\tcase SyntaxKind.LessThanEqualsToken:\n\t\t\treturn leftValue <= rightValue;\n\n\t\tcase SyntaxKind.InKeyword: {\n\t\t\treturn leftValue in (rightValue as unknown as object);\n\t\t}\n\n\t\t// Nullish coalescing (A ?? B)\n\t\tcase SyntaxKind.QuestionQuestionToken:\n\t\t\treturn leftValue != null ? leftValue : rightValue;\n\n\t\tcase SyntaxKind.InstanceOfKeyword: {\n\t\t\treturn leftValue as unknown as object instanceof (rightValue as unknown as Function);\n\t\t}\n\t}\n\n\t// Throw if the operator couldn't be handled\n\tthrow new UnexpectedNodeError({node: node.operatorToken});\n}","// tslint:disable:no-any\n\nexport const enum LiteralFlag {\n\tCALL\n}\n\nexport const LAZY_CALL_FLAG = \"___lazyCallFlag\";\n\nexport interface LazyCall {\n\t[LAZY_CALL_FLAG]: LiteralFlag;\n\tinvoke (...args: Literal[]): Literal;\n}\n\n/**\n * Returns true if the given literal is a lazy call\n * @param {Literal} literal\n * @return {literal is LazyCall}\n */\nexport function isLazyCall (literal: Literal): literal is LazyCall {\n\treturn literal != null && typeof literal === \"object\" && LAZY_CALL_FLAG in literal;\n}\n\nexport type Literal = object|Function|string|number|boolean|symbol|bigint|null|undefined;\nexport interface LiteralMatch {\n\tliteral: Literal;\n}\nexport type IndexLiteralKey = string;\nexport interface IndexLiteral {\n\t[key: string]: Literal;\n}\n\n/**\n * Stringifies the given literal\n * @param {Literal} literal\n * @return {string}\n */\nexport function stringifyLiteral (literal: Literal): string {\n\tif (literal === undefined) return \"undefined\";\n\telse if (literal === null) return \"null\";\n\telse if (typeof literal === \"string\") return `\"${literal}\"`;\n\treturn literal.toString();\n}","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {INotCallableErrorOptions} from \"./i-not-callable-error-options\";\nimport {Literal, stringifyLiteral} from \"../../literal/literal\";\n\n/**\n * An Error that can be thrown when a value is attempted to be called, but isn't callable\n */\nexport class NotCallableError extends EvaluationError {\n\t/**\n\t * The non-callable value\n\t * @type {Literal}\n\t */\n\tpublic readonly value: Literal;\n\n\tconstructor ({value, node, message = `${stringifyLiteral(value)} is not a function'`}: INotCallableErrorOptions) {\n\t\tsuper({message, node});\n\t\tthis.value = value;\n\t}\n}","import {Expression, isAsExpression, isElementAccessExpression, isParenthesizedExpression, isPropertyAccessExpression, isTypeAssertion} from \"typescript\";\nimport {isSuperExpression} from \"../node/is-super-expression\";\nimport {isThisExpression} from \"../node/is-this-expression\";\n\n/**\n * Returns true if the given expression contains a 'super' keyword\n * @param {ts.Expression} expression\n * @return {boolean}\n */\nexport function expressionContainsSuperKeyword (expression: Expression): boolean {\n\tif (isSuperExpression(expression)) return true;\n\n\telse if (isPropertyAccessExpression(expression)) {\n\t\treturn expressionContainsSuperKeyword(expression.expression) || expressionContainsSuperKeyword(expression.name);\n\t}\n\n\telse if (isElementAccessExpression(expression)) {\n\t\treturn expressionContainsSuperKeyword(expression.expression) || expressionContainsSuperKeyword(expression.argumentExpression);\n\t}\n\n\telse if (isParenthesizedExpression(expression)) return expressionContainsSuperKeyword(expression.expression);\n\telse if (isAsExpression(expression)) return expressionContainsSuperKeyword(expression.expression);\n\telse if (isTypeAssertion(expression)) return expressionContainsSuperKeyword(expression.expression);\n\telse {\n\t\treturn false;\n\t}\n}\n\n/**\n * Returns true if the given expression contains a 'this' keyword\n * @param {ts.Expression} expression\n * @return {boolean}\n */\nexport function expressionContainsThisKeyword (expression: Expression): boolean {\n\n\tif (isThisExpression(expression)) return true;\n\n\telse if (isPropertyAccessExpression(expression)) {\n\t\treturn expressionContainsThisKeyword(expression.expression) || expressionContainsThisKeyword(expression.name);\n\t}\n\n\telse if (isElementAccessExpression(expression)) {\n\t\treturn expressionContainsThisKeyword(expression.expression) || expressionContainsThisKeyword(expression.argumentExpression);\n\t}\n\n\telse if (isParenthesizedExpression(expression)) return expressionContainsThisKeyword(expression.expression);\n\telse if (isAsExpression(expression)) return expressionContainsThisKeyword(expression.expression);\n\telse if (isTypeAssertion(expression)) return expressionContainsThisKeyword(expression.expression);\n\telse {\n\t\treturn false;\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {CallExpression} from \"typescript\";\nimport {isLazyCall, Literal} from \"../literal/literal\";\nimport {NotCallableError} from \"../error/not-callable-error/not-callable-error\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {expressionContainsSuperKeyword} from \"../util/expression/expression-contains-super-keyword\";\n\n/**\n * Evaluates, or attempts to evaluate, a CallExpression\n * @param {IEvaluatorOptions<CallExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateCallExpression ({node, environment, evaluate, statementTraversalStack, logger}: IEvaluatorOptions<CallExpression>): Literal {\n\n\tconst evaluatedArgs: Literal[] = [];\n\n\tfor (let i = 0; i < node.arguments.length; i++) {\n\t\tevaluatedArgs[i] = evaluate.expression(node.arguments[i], environment, statementTraversalStack);\n\t}\n\n\t// Evaluate the expression\n\tconst expressionResult = (evaluate.expression(node.expression, environment, statementTraversalStack)) as Function|undefined;\n\n\tif (isLazyCall(expressionResult)) {\n\t\tconst currentThisBinding = expressionContainsSuperKeyword(node.expression) ? getFromLexicalEnvironment(node, environment, THIS_SYMBOL) : undefined;\n\t\tconst value = expressionResult.invoke(\n\t\t\tcurrentThisBinding != null\n\t\t\t\t? currentThisBinding.literal\n\t\t\t\t: undefined,\n\t\t\t...evaluatedArgs\n\t\t);\n\t\tlogger.logResult(value, \"CallExpression\");\n\t\treturn value;\n\t}\n\n\t// Otherwise, assume that the expression still needs calling\n\telse {\n\t\t// Unless optional chaining is being used, throw a NotCallableError\n\t\tif (node.questionDotToken == null && typeof expressionResult !== \"function\") {\n\t\t\tthrow new NotCallableError({value: expressionResult, node: node.expression});\n\t\t}\n\n\t\tconst value = typeof expressionResult !== \"function\" ? undefined : expressionResult(...evaluatedArgs);\n\t\tlogger.logResult(value, \"CallExpression\");\n\t\treturn value;\n\t}\n\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ParenthesizedExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a ParenthesizedExpression\n * @param {IEvaluatorOptions<ParenthesizedExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateParenthesizedExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<ParenthesizedExpression>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}","import {LexicalEnvironment} from \"./lexical-environment\";\n\n/**\n * Clones the given LexicalEnvironment\n * @param {LexicalEnvironment} environment\n * @returns {LexicalEnvironment}\n */\nexport function cloneLexicalEnvironment (environment: LexicalEnvironment): LexicalEnvironment {\n\treturn {\n\t\tparentEnv: environment,\n\t\tenv: {}\n\t};\n}","import {Modifier, Node} from \"typescript\";\n\n/**\n * Returns true if the given Node has the given kind of Modifier\n * @param {Node|Modifier[]} node\n * @param {Modifier[\"kind\"]} modifier\n * @returns {boolean}\n */\nexport function hasModifier (node: Node|Modifier[], modifier: Modifier[\"kind\"]): boolean {\n\tconst modifiers = Array.isArray(node) ? node : <ReadonlyArray<Modifier>|undefined> node.modifiers;\n\treturn modifiers != null && modifiers.some(m => m.kind === modifier);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {isIdentifier, NodeArray, ParameterDeclaration, SyntaxKind} from \"typescript\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, a NodeArray of ParameterDeclarations\n * @param {IEvaluatorOptions<NodeArray<ParameterDeclaration>>} options\n * @param {Literal[]} boundArguments\n * @param {IndexLiteral} [context]\n */\nexport function evaluateParameterDeclarations ({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<NodeArray<ParameterDeclaration>>, boundArguments: Literal[], context?: IndexLiteral): void {\n\t// 'this' is a special parameter which is removed from the emitted results\n\tconst parameters = node.filter(param => !(isIdentifier(param.name) && param.name.text === \"this\"));\n\n\tfor (let i = 0; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\n\t\t// It it is a spread element, it should receive all arguments from the current index.\n\t\tif (parameter.dotDotDotToken != null) {\n\t\t\tevaluate.nodeWithArgument(parameter, environment, boundArguments.slice(i), statementTraversalStack);\n\t\t\t// Spread elements must always be the last parameter\n\t\t\tbreak;\n\t\t}\n\n\t\telse {\n\t\t\tevaluate.nodeWithArgument(parameter, environment, boundArguments[i], statementTraversalStack);\n\n\t\t\t// If a context is given, and if a [public|protected|private] keyword is in front of the parameter, the initialized value should be\n\t\t\t// set on the context as an instance property\n\t\t\tif (context != null && isIdentifier(parameter.name) && (\n\t\t\t\thasModifier(parameter, SyntaxKind.PublicKeyword) ||\n\t\t\t\thasModifier(parameter, SyntaxKind.ProtectedKeyword) ||\n\t\t\t\thasModifier(parameter, SyntaxKind.PrivateKeyword)\n\t\t\t)\n\t\t\t) {\n\t\t\t\tconst value = getFromLexicalEnvironment(parameter, environment, parameter.name.text);\n\t\t\t\tif (value != null) {\n\t\t\t\t\tcontext[parameter.name.text] = value.literal;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ArrowFunction, isBlock, SyntaxKind} from \"typescript\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\n\n// tslint:disable:no-identical-functions\n\n/**\n * Evaluates, or attempts to evaluate, an ArrowFunction\n * @param {IEvaluatorOptions<ArrowFunction>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateArrowFunctionExpression ({node, environment, evaluate, stack, statementTraversalStack, reporting, ...rest}: IEvaluatorOptions<ArrowFunction>): Literal {\n\n\tconst arrowFunctionExpression = hasModifier(node, SyntaxKind.AsyncKeyword)\n\t\t? async (...args: Literal[]) => {\n\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\tstatementTraversalStack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (isBlock(node.body)) {\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t\t}\n\n\t\t\t// Otherwise, the body is itself an expression\n\t\t\telse {\n\t\t\t\treturn evaluate.expression(node.body, localLexicalEnvironment, statementTraversalStack);\n\t\t\t}\n\t\t}\n\t\t: (...args: Literal[]) => {\n\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\tstatementTraversalStack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (isBlock(node.body)) {\n\t\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\t\treturn stack.pop();\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\t\telse return undefined;\n\t\t\t}\n\n\t\t\t// Otherwise, the body is itself an expression\n\t\t\telse {\n\t\t\t\treturn evaluate.expression(node.body, localLexicalEnvironment, statementTraversalStack);\n\t\t\t}\n\t\t};\n\n\tarrowFunctionExpression.toString = () => `[Function: anonymous]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(\n\t\tarrowFunctionExpression,\n\t\tgetFromLexicalEnvironment(node, environment, \"Function\")!.literal as Function\n\t);\n\n\treturn arrowFunctionExpression;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {StringLiteralLike} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a StringLiteralLike\n * @param {IEvaluatorOptions<StringLiteralLike>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateStringLiteral ({node}: IEvaluatorOptions<StringLiteralLike>): Literal {\n\treturn node.text;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {NumericLiteral} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a NumericLiteral\n * @param {IEvaluatorOptions<NumericLiteral>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateNumericLiteral ({node}: IEvaluatorOptions<NumericLiteral>): Literal {\n\treturn Number(node.text);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {SyntaxKind, Token} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a BooleanLiteral\n * @param {IEvaluatorOptions<BooleanLiteral>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateBooleanLiteral ({node}: IEvaluatorOptions<Token<SyntaxKind.TrueKeyword|SyntaxKind.FalseKeyword>>): Literal {\n\treturn node.kind === SyntaxKind.TrueKeyword;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {RegularExpressionLiteral} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, a RegularExpressionLiteral\n * @param {IEvaluatorOptions<RegularExpressionLiteral>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateRegularExpressionLiteral ({node, environment}: IEvaluatorOptions<RegularExpressionLiteral>): Literal {\n\tconst functionCtor = getFromLexicalEnvironment(node, environment, \"Function\")!.literal as FunctionConstructor;\n\treturn (new functionCtor(`return ${node.text}`)());\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ObjectLiteralExpression} from \"typescript\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a ObjectLiteralExpression\n * @param {IEvaluatorOptions<ObjectLiteralExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateObjectLiteralExpression ({node, evaluate, environment, reporting, statementTraversalStack}: IEvaluatorOptions<ObjectLiteralExpression>): Literal {\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst value: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\n\t// Mark the object as the 'this' value of the scope\n\tsetInLexicalEnvironment({env: environment, path: THIS_SYMBOL, value, newBinding: true, reporting, node});\n\n\tfor (const property of node.properties) {\n\t\tevaluate.nodeWithArgument(property, environment, value, statementTraversalStack);\n\t}\n\n\treturn value;\n}","import {Literal} from \"../../literal/literal\";\n\n/**\n * Returns true if the given item is an Iterable\n * @param {Literal} item\n * @return {item is Iterable<Literal>}\n */\nexport function isIterable (item: Literal): item is Iterable<Literal> {\n\treturn item != null && (item as Iterable<Literal>)[Symbol.iterator] != null;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ArrayLiteralExpression, isSpreadElement} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {isIterable} from \"../util/iterable/is-iterable\";\n\n/**\n * Evaluates, or attempts to evaluate, a ArrayLiteralExpression\n * @param {IEvaluatorOptions<ArrayLiteralExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateArrayLiteralExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<ArrayLiteralExpression>): Literal {\n\t// Get the Array constructor from the realm - not that of the executing context. Otherwise, instanceof checks would fail\n\tconst arrayCtor = getFromLexicalEnvironment(node, environment, \"Array\")!.literal as ArrayConstructor;\n\tconst value: Literal[] = arrayCtor.of();\n\n\tfor (const element of node.elements) {\n\t\tconst nextValue = evaluate.expression(element, environment, statementTraversalStack);\n\t\tif (isSpreadElement(element) && isIterable(nextValue)) {\n\t\t\tvalue.push(...nextValue);\n\t\t}\n\n\t\telse {\n\t\t\tvalue.push(nextValue);\n\t\t}\n\t}\n\n\treturn value;\n}","import {Identifier} from \"typescript\";\nimport {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IUndefinedIdentifierErrorOptions} from \"./i-undefined-identifier-error-options\";\n\n/**\n * An Error that can be thrown when an undefined identifier is encountered\n */\nexport class UndefinedIdentifierError extends EvaluationError {\n\t/**\n\t * The identifier that is undefined in the context that created this error\n\t * @type {Identifier}\n\t */\n\tpublic readonly node: Identifier;\n\n\tconstructor ({node, message = `'${node.text}' is not defined'`}: IUndefinedIdentifierErrorOptions) {\n\t\tsuper({message, node});\n\t}\n}","import {NodeFlags, VariableDeclarationList} from \"typescript\";\n\n/**\n * Returns true if the given VariableDeclarationList is declared with a 'var' keyword\n * @param {VariableDeclarationList} declarationList\n * @return {boolean}\n */\nexport function isVarDeclaration (declarationList: VariableDeclarationList): boolean {\n\treturn declarationList.flags !== NodeFlags.Const && declarationList.flags !== NodeFlags.Let;\n}","import {getCombinedNodeFlags, isSourceFile, Node, NodeFlags, SyntaxKind} from \"typescript\";\n\n/**\n * Finds the nearest parent node of the given kind from the given Node\n * @param {Node} from\n * @param {SyntaxKind} kind\n * @return {T?}\n */\nexport function findNearestParentNodeOfKind<T extends Node> (from: Node, kind: SyntaxKind): T|undefined {\n\tlet currentParent = from;\n\twhile (true) {\n\t\tcurrentParent = currentParent.parent;\n\t\tif (currentParent == null) return undefined;\n\t\tif (currentParent.kind === kind) {\n\t\t\tconst combinedNodeFlags = getCombinedNodeFlags(currentParent);\n\t\t\tconst isNamespace = (\n\t\t\t\t((combinedNodeFlags & NodeFlags.Namespace) !== 0) ||\n\t\t\t\t((combinedNodeFlags & NodeFlags.NestedNamespace) !== 0)\n\t\t\t);\n\t\t\tif (!isNamespace) return <T>currentParent;\n\t\t}\n\n\t\tif (isSourceFile(currentParent)) return undefined;\n\t}\n}","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IModuleNotFoundErrorOptions} from \"./i-module-not-found-error-options\";\n\n/**\n * An Error that can be thrown when a moduleSpecifier couldn't be resolved\n */\nexport class ModuleNotFoundError extends EvaluationError {\n\n\t/**\n\t * The path/moduleName that could not be resolved\n\t * @type {string}\n\t */\n\tpublic readonly path: string;\n\n\tconstructor ({path, node, message = `Module '${path}' could not be resolved'`}: IModuleNotFoundErrorOptions) {\n\t\tsuper({message, node});\n\t\tthis.path = path;\n\t}\n}","import {Declaration, getNameOfDeclaration, isComputedPropertyName, isIdentifier, isNumericLiteral, isStringLiteralLike} from \"typescript\";\nimport {IEvaluatorOptions} from \"../../evaluator/i-evaluator-options\";\nimport {UnexpectedNodeError} from \"../../error/unexpected-node-error/unexpected-node-error\";\n\n/**\n * Gets the name of the given declaration\n * @param {IEvaluatorOptions<Declaration>} options\n * @return {Promise<string|number?>}\n */\nexport function getDeclarationName ({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<Declaration>): string|number|undefined {\n\tconst name = getNameOfDeclaration(node);\n\tif (name == null) return undefined;\n\n\tif (isIdentifier(name)) {\n\t\treturn name.text;\n\t}\n\n\telse if (isStringLiteralLike(name)) {\n\t\treturn name.text;\n\t}\n\n\telse if (isNumericLiteral(name)) {\n\t\treturn Number(name.text);\n\t}\n\n\telse if (isComputedPropertyName(name)) {\n\t\treturn (evaluate.expression(name.expression, environment, statementTraversalStack)) as ReturnType<typeof getDeclarationName>;\n\t}\n\n\telse {\n\t\tthrow new UnexpectedNodeError({node: name});\n\t}\n\n}","import {Declaration, isModuleDeclaration, ModuleDeclaration, SyntaxKind} from \"typescript\";\nimport {findNearestParentNodeOfKind} from \"../node/find-nearest-parent-node-of-kind\";\nimport {Literal} from \"../../literal/literal\";\nimport {ModuleNotFoundError} from \"../../error/module-not-found-error/module-not-found-error\";\nimport {UnexpectedNodeError} from \"../../error/unexpected-node-error/unexpected-node-error\";\nimport {IEvaluatorOptions} from \"../../evaluator/i-evaluator-options\";\nimport {getDeclarationName} from \"../declaration/get-declaration-name\";\nimport {EvaluationError} from \"../../error/evaluation-error/evaluation-error\";\nimport {getFromLexicalEnvironment} from \"../../lexical-environment/lexical-environment\";\n\n/**\n * Gets an implementation for the given declaration that lives within a declaration file\n * @param {IEvaluatorOptions<Declaration>} options\n * @return {Promise<Literal>}\n */\nexport function getImplementationForDeclarationWithinDeclarationFile (options: IEvaluatorOptions<Declaration>): Literal {\n\tconst {node} = options;\n\tconst name = getDeclarationName(options);\n\n\tif (name == null) {\n\t\tthrow new UnexpectedNodeError({node});\n\t}\n\n\t// First see if it lives within the lexical environment\n\tconst matchInLexicalEnvironment = getFromLexicalEnvironment(node, options.environment, name as string);\n\t// If so, return it\n\tif (matchInLexicalEnvironment != null && matchInLexicalEnvironment.literal != null) {\n\t\treturn matchInLexicalEnvironment.literal;\n\t}\n\n\t// Otherwise, expect it to be something that is require'd on demand\n\tconst require = getFromLexicalEnvironment(node, options.environment, \"require\")!.literal as NodeRequire;\n\n\tconst moduleDeclaration = isModuleDeclaration(node) ? node : findNearestParentNodeOfKind<ModuleDeclaration>(node, SyntaxKind.ModuleDeclaration);\n\tif (moduleDeclaration == null) {\n\t\tthrow new UnexpectedNodeError({node});\n\t}\n\n\ttry {\n\t\tconst module = require(moduleDeclaration.name.text);\n\t\treturn isModuleDeclaration(node)\n\t\t\t? module\n\t\t\t: module[name];\n\t} catch (ex) {\n\t\tif (ex instanceof EvaluationError) throw ex;\n\t\telse throw new ModuleNotFoundError({node: moduleDeclaration, path: moduleDeclaration.name.text});\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Declaration, Identifier, isVariableDeclaration, isVariableDeclarationList} from \"typescript\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {UndefinedIdentifierError} from \"../error/undefined-identifier-error/undefined-identifier-error\";\nimport {isVarDeclaration} from \"../util/flags/is-var-declaration\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file\";\n\n/**\n * Evaluates, or attempts to evaluate, an Identifier\n * @param {IEvaluatorOptions<Identifier>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateIdentifier ({node, environment, typeChecker, evaluate, stack, logger, reporting, statementTraversalStack, ...rest}: IEvaluatorOptions<Identifier>): Literal {\n\n\t// Otherwise, try to resolve it. Maybe it exists in the environment already?\n\tconst environmentMatch = getFromLexicalEnvironment(node, environment, node.text);\n\tif (environmentMatch != null) {\n\t\tlogger.logBinding(node.text, environmentMatch.literal, \"Lexical Environment match\");\n\t\t// Return the existing evaluated value from the environment\n\t\treturn environmentMatch.literal;\n\t}\n\n\t// Try to get a symbol for whatever the identifier points to and take its value declaration.\n\t// It may not have a symbol, for example if it is an inlined expression such as an initializer or a Block\n\tconst symbol = typeChecker.getSymbolAtLocation(node);\n\tlet valueDeclaration: Declaration|undefined = symbol == null ? undefined : symbol.valueDeclaration;\n\n\tif (symbol != null && valueDeclaration == null) {\n\t\ttry {\n\t\t\t// The symbol may be aliasing another one - which may have a value declaration\n\t\t\tconst aliasedSymbol = typeChecker.getAliasedSymbol(symbol);\n\t\t\tvalueDeclaration = aliasedSymbol.valueDeclaration;\n\t\t} catch {\n\t\t\t// OK, it didn't alias anything\n\t\t}\n\t}\n\n\t// If it has a value declaration, go forward with that one\n\tif (valueDeclaration != null) {\n\t\tif (valueDeclaration.getSourceFile().isDeclarationFile) {\n\n\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile({node: valueDeclaration, statementTraversalStack, environment, evaluate, logger, reporting, typeChecker, stack, ...rest});\n\t\t\t// Bind the value placed on the top of the stack to the local environment\n\t\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: implementation, reporting, node: valueDeclaration});\n\t\t\tlogger.logBinding(node.text, implementation, `Discovered declaration value${valueDeclaration.getSourceFile() === node.getSourceFile() ? \"\" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`}`);\n\t\t\treturn implementation;\n\n\t\t}\n\n\t\t// If the value is a variable declaration and is located *after* the current node within the SourceFile\n\t\t// It is potentially a SyntaxError unless it is hoisted (if the 'var' keyword is being used) in which case the variable is defined, but initialized to 'undefined'\n\t\tif (isVariableDeclaration(valueDeclaration) && valueDeclaration.getSourceFile().fileName === node.getSourceFile().fileName && valueDeclaration.pos > node.pos) {\n\n\t\t\t// The 'var' keyword declares a variable that is defined, but which rvalue is still undefined\n\t\t\tif (isVariableDeclarationList(valueDeclaration.parent) && isVarDeclaration(valueDeclaration.parent)) {\n\t\t\t\tconst returnValue = undefined;\n\t\t\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: returnValue, newBinding: true, reporting, node: valueDeclaration});\n\t\t\t\tlogger.logBinding(node.text, returnValue, \"Hoisted var declaration\");\n\t\t\t\treturn returnValue;\n\t\t\t}\n\n\t\t\t// In all other cases, both the identifier and the rvalue is still undefined\n\t\t\telse {\n\t\t\t\tthrow new UndefinedIdentifierError({node});\n\t\t\t}\n\n\t\t}\n\n\t\tevaluate.declaration(valueDeclaration, environment, statementTraversalStack);\n\t\tconst stackValue = stack.pop();\n\n\t\t// Bind the value placed on the top of the stack to the local environment\n\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: stackValue, reporting, node: valueDeclaration});\n\t\tlogger.logBinding(node.text, stackValue, `Discovered declaration value${valueDeclaration.getSourceFile() === node.getSourceFile() ? \"\" : ` (imported into '${node.getSourceFile().fileName}' from '${valueDeclaration.getSourceFile().fileName}')`}`);\n\t\treturn stackValue;\n\t}\n\n\t// Otherwise throw. The identifier is unknown\n\tthrow new UndefinedIdentifierError({node});\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Block, isCallExpression, isConstructorDeclaration, isExpressionStatement} from \"typescript\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {isSuperExpression} from \"../util/node/is-super-expression\";\n\n/**\n * Evaluates, or attempts to evaluate, a Block\n * @param {IEvaluatorOptions<Block>} options\n */\nexport function evaluateBlock ({node, environment, evaluate}: IEvaluatorOptions<Block>): void {\n\t// Prepare a lexical environment for the Block context\n\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\tfor (let i = 0; i < node.statements.length; i++) {\n\t\tconst statement = node.statements[i];\n\n\t\t// Don't execute 'super()' within Constructor Blocks since this is handled in another level\n\t\tif (isConstructorDeclaration(node.parent) && i === 0 && isExpressionStatement(statement) && isCallExpression(statement.expression) && isSuperExpression(statement.expression.expression)) continue;\n\n\t\tevaluate.statement(statement, localLexicalEnvironment);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ReturnStatement} from \"typescript\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a ReturnStatement\n * @param {IEvaluatorOptions<ReturnStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateReturnStatement ({node, environment, evaluate, stack, reporting, statementTraversalStack}: IEvaluatorOptions<ReturnStatement>): void {\n\tsetInLexicalEnvironment({env: environment, path: RETURN_SYMBOL, value: true, reporting, node});\n\n\t// If it is a simple 'return', return undefined\n\tif (node.expression == null) {\n\t\tstack.push(undefined);\n\t}\n\n\telse {\n\t\tstack.push(evaluate.expression(node.expression, environment, statementTraversalStack));\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {VariableDeclarationList} from \"typescript\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableDeclarationList\n * @param {IEvaluatorOptions<VariableDeclarationList>} options\n * @returns {Promise<void>}\n */\nexport function evaluateVariableDeclarationList ({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<VariableDeclarationList>): void {\n\tfor (const declaration of node.declarations) {\n\t\tevaluate.declaration(declaration, environment, statementTraversalStack);\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {VariableStatement} from \"typescript\";\nimport {evaluateVariableDeclarationList} from \"./evaluate-variable-declaration-list\";\n\n/**\n * Evaluates, or attempts to evaluate, a VariableStatement\n * @param {IEvaluatorOptions<VariableStatement>} options\n */\nexport function evaluateVariableStatement ({node, ...rest}: IEvaluatorOptions<VariableStatement>): void {\n\tevaluateVariableDeclarationList({node: node.declarationList, ...rest});\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {isIdentifier, PrefixUnaryExpression, SyntaxKind} from \"typescript\";\nimport {getRelevantDictFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {Literal} from \"../literal/literal\";\n\n// tslint:disable:strict-boolean-expressions\n\n/**\n * Evaluates, or attempts to evaluate, a PrefixUnaryExpression\n * @param {IEvaluatorOptions<PrefixUnaryExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluatePrefixUnaryExpression ({node, environment, evaluate, reporting, statementTraversalStack}: IEvaluatorOptions<PrefixUnaryExpression>): Literal {\n\tconst operandValue = (evaluate.expression(node.operand, environment, statementTraversalStack)) as number;\n\n\tswitch (node.operator) {\n\t\tcase SyntaxKind.PlusToken: {\n\t\t\treturn +operandValue;\n\t\t}\n\n\t\tcase SyntaxKind.MinusToken: {\n\t\t\treturn -operandValue;\n\t\t}\n\n\t\tcase SyntaxKind.TildeToken: {\n\t\t\treturn ~operandValue;\n\t\t}\n\n\t\tcase SyntaxKind.ExclamationToken: {\n\t\t\treturn !operandValue;\n\t\t}\n\n\t\tcase SyntaxKind.PlusPlusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!isIdentifier(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text)!;\n\t\t\tconst value = ++(dict[node.operand.text]! as number);\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tcase SyntaxKind.MinusMinusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!isIdentifier(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst dict = getRelevantDictFromLexicalEnvironment(environment, node.operand.text)!;\n\t\t\tconst value = --(dict[node.operand.text]! as number);\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {PropertyAccessExpression, SyntaxKind} from \"typescript\";\nimport {IndexLiteral, LAZY_CALL_FLAG, LazyCall, Literal, LiteralFlag} from \"../literal/literal\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyAccessExpression\n * @param {IEvaluatorOptions<PropertyAccessExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluatePropertyAccessExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<PropertyAccessExpression>): Literal {\n\tconst expressionResult = (evaluate.expression(node.expression, environment, statementTraversalStack)) as IndexLiteral;\n\n\tconst match = node.questionDotToken != null && expressionResult == null\n\t\t// If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'\n\t\t? undefined\n\t\t: expressionResult[node.name.text];\n\n\t// If it is a function, wrap it in a lazy call to preserve implicit 'this' bindings. This is to avoid losing the 'this' binding or having to\n\t// explicitly bind a 'this' value\n\tif (typeof match === \"function\" && statementTraversalStack.includes(SyntaxKind.CallExpression)) {\n\t\treturn {\n\t\t\t[LAZY_CALL_FLAG]: LiteralFlag.CALL,\n\t\t\tinvoke: (overriddenThis: object|Function|undefined, ...args: Literal[]) => {\n\t\t\t\treturn overriddenThis != null && !isBindCallApply(match, environment)\n\t\t\t\t\t? (expressionResult[node.name.text] as Function).call(overriddenThis, ...args)\n\t\t\t\t\t: (expressionResult[node.name.text] as Function)(...args);\n\t\t\t}\n\t\t} as LazyCall;\n\t}\n\n\telse return match;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ElementAccessExpression, SyntaxKind} from \"typescript\";\nimport {IndexLiteral, IndexLiteralKey, LAZY_CALL_FLAG, LazyCall, Literal, LiteralFlag} from \"../literal/literal\";\nimport {isBindCallApply} from \"../util/function/is-bind-call-apply\";\n\n/**\n * Evaluates, or attempts to evaluate, a ElementAccessExpression\n * @param {IEvaluatorOptions<ElementAccessExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateElementAccessExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<ElementAccessExpression>): Literal {\n\tconst expressionResult = (evaluate.expression(node.expression, environment, statementTraversalStack)) as IndexLiteral;\n\tconst argumentExpressionResult = (evaluate.expression(node.argumentExpression, environment, statementTraversalStack)) as IndexLiteralKey;\n\n\n\tconst match = node.questionDotToken != null && expressionResult == null\n\t\t// If optional chaining are being used and the expressionResult is undefined or null, assign undefined to 'match'\n\t\t? undefined\n\t\t: expressionResult[argumentExpressionResult];\n\n\t// If it is a function, wrap it in a lazy call to preserve implicit this bindings. This is to avoid losing the this binding or having to\n\t// explicitly bind a 'this' value\n\tif (typeof match === \"function\" && statementTraversalStack.includes(SyntaxKind.CallExpression)) {\n\t\treturn {\n\t\t\t[LAZY_CALL_FLAG]: LiteralFlag.CALL,\n\t\t\tinvoke: (overriddenThis: object|Function|undefined, ...args: Literal[]) => overriddenThis != null && !isBindCallApply(match, environment)\n\t\t\t\t? (expressionResult[argumentExpressionResult] as Function).call(overriddenThis, ...args)\n\t\t\t\t: (expressionResult[argumentExpressionResult] as Function)(...args)\n\t\t} as LazyCall;\n\t}\n\n\telse return match;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ComputedPropertyName} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a ComputedPropertyName\n * @param {IEvaluatorOptions<ComputedPropertyName>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateComputedPropertyName ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<ComputedPropertyName>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {FunctionDeclaration, SyntaxKind} from \"typescript\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\n\n// tslint:disable:no-identical-functions\n\n/**\n * Evaluates, or attempts to evaluate, a FunctionDeclaration\n * @param {IEvaluatorOptions<FunctionDeclaration>} options\n * @returns {Promise<void>}\n */\nexport function evaluateFunctionDeclaration (options: IEvaluatorOptions<FunctionDeclaration>): void {\n\tconst {node, environment, evaluate, stack, reporting, ...rest} = options;\n\n\tconst nameResult = node.name == null ? undefined : node.name.text;\n\n\tconst _functionDeclaration = hasModifier(node, SyntaxKind.AsyncKeyword)\n\t\t? async function functionDeclaration (this: Literal, ...args: Literal[]) {\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\tif (this != null) {\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t}\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\tconst sourceFile = node.getSourceFile();\n\t\t\tif (nameResult != null && sourceFile.isDeclarationFile) {\n\t\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile(options);\n\t\t\t\treturn (implementation as Function)(...args);\n\t\t\t}\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (node.body == null) return;\n\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\treturn stack.pop();\n\t\t\t}\n\n\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\telse {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t\t: function functionDeclaration (this: Literal, ...args: Literal[]) {\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\tif (this != null) {\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t}\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\tconst sourceFile = node.getSourceFile();\n\t\t\tif (nameResult != null && sourceFile.isDeclarationFile) {\n\t\t\t\tconst implementation = getImplementationForDeclarationWithinDeclarationFile(options);\n\t\t\t\treturn (implementation as Function)(...args);\n\t\t\t}\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (node.body == null) return;\n\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\treturn stack.pop();\n\t\t\t}\n\n\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\telse return undefined;\n\t\t};\n\n\tif (nameResult != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: nameResult, value: _functionDeclaration.bind(_functionDeclaration), reporting, node});\n\t}\n\n\t_functionDeclaration.toString = () => `[Function${nameResult == null ? \"\" : `: ${nameResult}`}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(\n\t\t_functionDeclaration,\n\t\tgetFromLexicalEnvironment(node, environment, \"Function\")!.literal as Function\n\t);\n\n\tstack.push(_functionDeclaration);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IfStatement} from \"typescript\";\n\n// tslint:disable:strict-boolean-expressions\n\n/**\n * Evaluates, or attempts to evaluate, an IfStatement\n * @param {IEvaluatorOptions<IfStatement>} options\n */\nexport function evaluateIfStatement ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<IfStatement>): void {\n\n\tconst expressionValue = evaluate.expression(node.expression, environment, statementTraversalStack);\n\n\t// We have to perform a loose boolean expression here to conform with actual spec behavior\n\tif (expressionValue) {\n\t\t// Proceed with the truthy branch\n\t\tevaluate.statement(node.thenStatement, environment);\n\t}\n\n\t// Proceed with the falsy branch\n\telse if (node.elseStatement != null) {\n\t\treturn evaluate.statement(node.elseStatement, environment);\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ExpressionStatement} from \"typescript\";\n\n/**\n * Evaluates, or attempts to evaluate, an ExpressionStatement\n * @param {IEvaluatorOptions<ExpressionStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateExpressionStatement ({node, environment, evaluate, stack, statementTraversalStack}: IEvaluatorOptions<ExpressionStatement>): void {\n\tstack.push(evaluate.expression(node.expression, environment, statementTraversalStack));\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TemplateExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a TemplateExpression\n * @param {IEvaluatorOptions<TemplateExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateTemplateExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TemplateExpression>): Literal {\n\tlet str = \"\";\n\tstr += node.head.text;\n\tfor (const span of node.templateSpans) {\n\t\tconst expression = (evaluate.expression(span.expression, environment, statementTraversalStack)) as string;\n\t\tstr += expression;\n\t\tstr += span.literal.text;\n\t}\n\treturn str;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TypeAssertion} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeAssertion\n * @param {IEvaluatorOptions<TypeAssertion>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateTypeAssertion ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TypeAssertion>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {isIdentifier, PostfixUnaryExpression, SyntaxKind} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {getRelevantDictFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\n\n/**\n * Evaluates, or attempts to evaluate, a PostfixUnaryExpression\n * @param {IEvaluatorOptions<PostfixUnaryExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluatePostfixUnaryExpression ({node, evaluate, environment, reporting, statementTraversalStack}: IEvaluatorOptions<PostfixUnaryExpression>): Literal {\n\t// Make sure to evaluate the operand to ensure that it is found in the lexical environment\n\tevaluate.expression(node.operand, environment, statementTraversalStack);\n\n\tswitch (node.operator) {\n\t\tcase SyntaxKind.PlusPlusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!isIdentifier(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst value = (getRelevantDictFromLexicalEnvironment(environment, node.operand.text)![node.operand.text]! as number)++;\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tcase SyntaxKind.MinusMinusToken: {\n\t\t\t// If the Operand isn't an identifier, this will be a SyntaxError\n\t\t\tif (!isIdentifier(node.operand)) {\n\t\t\t\tthrow new UnexpectedNodeError({node: node.operand});\n\t\t\t}\n\n\t\t\t// Find the value associated with the identifier within the environment.\n\t\t\tconst value = (getRelevantDictFromLexicalEnvironment(environment, node.operand.text)![node.operand.text]! as number)--;\n\n\t\t\t// Inform reporting hooks if any is given\n\t\t\tif (reporting.reportBindings != null) {\n\t\t\t\treporting.reportBindings({path: node.operand.text, value, node});\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {NewExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a NewExpression\n * @param {IEvaluatorOptions<NewExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateNewExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<NewExpression>): Literal {\n\n\tconst evaluatedArgs: Literal[] = [];\n\n\tif (node.arguments != null) {\n\t\tfor (let i = 0; i < node.arguments.length; i++) {\n\t\t\tevaluatedArgs[i] = evaluate.expression(node.arguments[i], environment, statementTraversalStack);\n\t\t}\n\t}\n\n\t// Evaluate the expression\n\tconst expressionResult = (evaluate.expression(node.expression, environment, statementTraversalStack)) as (new (...args: Literal[]) => Literal);\n\n\treturn (new expressionResult(...evaluatedArgs));\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {NonNullExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a NonNullExpression\n * @param {IEvaluatorOptions<NonNullExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateNonNullExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<NonNullExpression>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {AsExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, an AsExpression\n * @param {IEvaluatorOptions<AsExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateAsExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<AsExpression>): Literal {\n\treturn evaluate.expression(node.expression, environment, statementTraversalStack);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {SwitchStatement} from \"typescript\";\n\n/**\n * Evaluates, or attempts to evaluate, a SwitchStatement\n * @param {IEvaluatorOptions<SwitchStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateSwitchStatement ({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<SwitchStatement>): void {\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack);\n\tevaluate.nodeWithArgument(node.caseBlock, environment, expressionResult, statementTraversalStack);\n}","import {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IAsyncNotSupportedErrorOptions} from \"./i-async-not-supported-error-options\";\nimport {createEmptyStatement} from \"typescript\";\n\n/**\n * An Error that can be thrown when an async operation is attempted but can't be computed\n */\nexport class AsyncNotSupportedError extends EvaluationError {\n\n\tconstructor ({message = `It is not possible to evaluate asynchronously: Optional dependency 'deasync' must be installed.'`}: IAsyncNotSupportedErrorOptions) {\n\t\tsuper({message, node: createEmptyStatement()});\n\t}\n}","import {AsyncNotSupportedError} from \"../../error/async-not-supported-error/async-not-supported-error\";\n\nlet loopWhile: (typeof import(\"deasync\").loopWhile)|undefined;\n\ntry {\n\t// tslint:disable-next-line:no-require-imports no-var-requires\n\tconst importedModule = require(\"deasync\") as typeof import(\"deasync\");\n\tloopWhile = importedModule.loopWhile;\n} catch {\n\t// This is OK\n}\n\n/**\n * A synchronous way to await a result\n * @param {Promise<T>} promise\n * @return {T}\n */\nexport function syncAwait<T> (promise: Promise<T>): T {\n\tif (loopWhile === undefined) {\n\t\t// Throw this error if for some reason the deasync module wasn't installed\n\t\tthrow new AsyncNotSupportedError({});\n\t}\n\tlet done = false;\n\tlet rejected = false;\n\tlet resolveResult: unknown;\n\tlet rejectResult: unknown;\n\n\tpromise.then(function (resolve) {\n\t\tdone = true;\n\t\tresolveResult = resolve;\n\t})\n\t\t.catch(function (e) {\n\t\t\tdone = true;\n\t\t\trejected = true;\n\t\t\trejectResult = e;\n\t\t});\n\n\tloopWhile(() => !done);\n\n\tif (rejected) {\n\t\tthrow rejectResult;\n\t}\n\treturn resolveResult as T;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ForOfStatement, isVariableDeclarationList} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {syncAwait} from \"../util/await/sync-await\";\n\n// tslint:disable:no-redundant-jump\n\n/**\n * Evaluates, or attempts to evaluate, a ForOfStatement\n * @param {IEvaluatorOptions<ForOfStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateForOfStatement ({node, environment, evaluate, logger, reporting, statementTraversalStack}: IEvaluatorOptions<ForOfStatement>): void {\n\n\t// Compute the 'of' part\n\tconst expressionResult = (evaluate.expression(node.expression, environment, statementTraversalStack)) as Iterable<Literal>;\n\n\t// Ensure that the initializer is a proper VariableDeclarationList\n\tif (!isVariableDeclarationList(node.initializer)) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer});\n\t}\n\n\t// Only 1 declaration is allowed in a ForOfStatement\n\telse if (node.initializer.declarations.length > 1) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer.declarations[1]});\n\t}\n\n\tif (node.awaitModifier != null) {\n\t\tfor (const literal of expressionResult) {\n\t\t\t// Prepare a lexical environment for the current iteration\n\t\t\tconst localEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a break symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for a continue symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Evaluate the VariableDeclaration and manually pass in the current literal as the initializer for the variable assignment\n\t\t\tevaluate.nodeWithArgument(node.initializer.declarations[0], localEnvironment, literal, statementTraversalStack);\n\n\t\t\t// Evaluate the Statement\n\t\t\tevaluate.statement(node.statement, localEnvironment);\n\n\t\t\t// Check if a 'break' statement has been encountered and break if so\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL)) {\n\t\t\t\tlogger.logBreak(node);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telse if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\t\tlogger.logContinue(node);\n\t\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\tlogger.logReturn(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\telse {\n\t\tfor (let literal of expressionResult) {\n\t\t\tif (node.awaitModifier != null) {\n\t\t\t\tliteral = syncAwait(literal as Promise<Literal>);\n\t\t\t}\n\n\t\t\t// Prepare a lexical environment for the current iteration\n\t\t\tconst localEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a break symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for a continue symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Evaluate the VariableDeclaration and manually pass in the current literal as the initializer for the variable assignment\n\t\t\tevaluate.nodeWithArgument(node.initializer.declarations[0], localEnvironment, literal, statementTraversalStack);\n\n\t\t\t// Evaluate the Statement\n\t\t\tevaluate.statement(node.statement, localEnvironment);\n\n\t\t\t// Check if a 'break' statement has been encountered and break if so\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL)) {\n\t\t\t\tlogger.logBreak(node);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\telse if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\t\tlogger.logContinue(node);\n\t\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\tlogger.logReturn(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ThisExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a ThisExpression\n * @param {IEvaluatorOptions<ThisExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateThisExpression ({node, environment}: IEvaluatorOptions<ThisExpression>): Literal {\n\tconst match = getFromLexicalEnvironment(node, environment, THIS_SYMBOL);\n\treturn match == null ? undefined : match.literal;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {BreakStatement} from \"typescript\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a BreakStatement\n * @param {IEvaluatorOptions<BreakStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateBreakStatement ({environment, reporting, node}: IEvaluatorOptions<BreakStatement>): void {\n\tsetInLexicalEnvironment({env: environment, path: BREAK_SYMBOL, value: true, reporting, node});\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ContinueStatement} from \"typescript\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a ContinueStatement\n * @param {IEvaluatorOptions<ContinueStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateContinueStatement ({node, environment, reporting}: IEvaluatorOptions<ContinueStatement>): void {\n\tsetInLexicalEnvironment({env: environment, path: CONTINUE_SYMBOL, value: true, reporting, node});\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ForStatement, isVariableDeclarationList} from \"typescript\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\n\n// tslint:disable:no-redundant-jump\n\n/**\n * Evaluates, or attempts to evaluate, a ForStatement\n * @param {IEvaluatorOptions<ForStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateForStatement ({node, environment, evaluate, reporting, statementTraversalStack}: IEvaluatorOptions<ForStatement>): void {\n\n\t// Prepare a lexical environment for the ForStatement\n\tconst forEnvironment = cloneLexicalEnvironment(environment);\n\n\t// Evaluate the initializer if it is given\n\tif (node.initializer !== undefined) {\n\t\tif (isVariableDeclarationList(node.initializer)) {\n\t\t\tfor (const declaration of node.initializer.declarations) {\n\t\t\t\tevaluate.declaration(declaration, forEnvironment, statementTraversalStack);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tevaluate.expression(node.initializer, forEnvironment, statementTraversalStack);\n\t\t}\n\t}\n\n\twhile (true) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst iterationEnvironment = cloneLexicalEnvironment(forEnvironment);\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Evaluate the condition. It may be truthy always\n\t\tconst conditionResult = node.condition == null\n\t\t\t? true\n\t\t\t: (evaluate.expression(node.condition, forEnvironment, statementTraversalStack)) as boolean;\n\n\t\t// If the condition doesn't hold, return immediately\n\t\tif (!conditionResult) return;\n\n\t\t// Execute the Statement\n\t\tevaluate.statement(node.statement, iterationEnvironment);\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Run the incrementor\n\t\tif (node.incrementor != null) {\n\t\t\tevaluate.expression(node.incrementor, forEnvironment, statementTraversalStack);\n\t\t}\n\n\t\t// Always run the incrementor before continuing\n\t\telse if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t}\n\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {WhileStatement} from \"typescript\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\n\n// tslint:disable:no-redundant-jump\n\n/**\n * Evaluates, or attempts to evaluate, a WhileStatement\n * @param {IEvaluatorOptions<WhileStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateWhileStatement ({node, environment, evaluate, logger, reporting, statementTraversalStack}: IEvaluatorOptions<WhileStatement>): void {\n\n\tlet condition = (evaluate.expression(node.expression, environment, statementTraversalStack)) as boolean;\n\n\twhile (condition) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst iterationEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({env: iterationEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Execute the Statement\n\t\tevaluate.statement(node.statement, iterationEnvironment);\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tlogger.logBreak(node);\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, RETURN_SYMBOL)) {\n\t\t\tlogger.logReturn(node);\n\t\t\treturn;\n\t\t}\n\n\t\tcondition = (evaluate.expression(node.expression, environment, statementTraversalStack)) as boolean;\n\n\t\t// Always re-evaluate the condition before continuing\n\t\tif (pathInLexicalEnvironmentEquals(node, iterationEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\tlogger.logContinue(node);\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ForInStatement, isVariableDeclarationList} from \"typescript\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\n\n// tslint:disable:no-redundant-jump\n\n/**\n * Evaluates, or attempts to evaluate, a ForInStatement\n * @param {IEvaluatorOptions<ForInStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateForInStatement ({node, environment, evaluate, logger, reporting, statementTraversalStack}: IEvaluatorOptions<ForInStatement>): void {\n\n\t// Compute the 'of' part\n\tconst expressionResult = (evaluate.expression(node.expression, environment, statementTraversalStack)) as IndexLiteral;\n\n\t// Ensure that the initializer is a proper VariableDeclarationList\n\tif (!isVariableDeclarationList(node.initializer)) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer});\n\t}\n\n\t// Only 1 declaration is allowed in a ForOfStatement\n\telse if (node.initializer.declarations.length > 1) {\n\t\tthrow new UnexpectedNodeError({node: node.initializer.declarations[1]});\n\t}\n\n\tfor (const literal in expressionResult) {\n\t\t// Prepare a lexical environment for the current iteration\n\t\tconst localEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a break symbol within the environment\n\t\tsetInLexicalEnvironment({env: localEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for a continue symbol within the environment\n\t\tsetInLexicalEnvironment({env: localEnvironment, path: CONTINUE_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Evaluate the VariableDeclaration and manually pass in the current literal as the initializer for the variable assignment\n\t\tevaluate.nodeWithArgument(node.initializer.declarations[0], localEnvironment, literal, statementTraversalStack);\n\n\t\t// Evaluate the Statement\n\t\tevaluate.statement(node.statement, localEnvironment);\n\n\t\t// Check if a 'break' statement has been encountered and break if so\n\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL)) {\n\t\t\tlogger.logBreak(node);\n\t\t\tbreak;\n\t\t}\n\n\t\telse if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, CONTINUE_SYMBOL)) {\n\t\t\tlogger.logContinue(node);\n\t\t\t// noinspection UnnecessaryContinueJS\n\t\t\tcontinue;\n\t\t}\n\n\t\telse if (pathInLexicalEnvironmentEquals(node, localEnvironment, true, RETURN_SYMBOL)) {\n\t\t\tlogger.logReturn(node);\n\t\t\treturn;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {FunctionExpression, SyntaxKind} from \"typescript\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\n\n// tslint:disable:no-identical-functions\n\n/**\n * Evaluates, or attempts to evaluate, a FunctionExpression\n * @param {IEvaluatorOptions<FunctionExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateFunctionExpression ({node, environment, evaluate, stack, reporting, ...rest}: IEvaluatorOptions<FunctionExpression>): Literal {\n\n\tconst nameResult = node.name == null ? undefined : node.name.text;\n\n\tconst _functionExpression = hasModifier(node, SyntaxKind.AsyncKeyword)\n\t\t? async function functionExpression (this: Literal, ...args: Literal[]) {\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\tif (this != null) {\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t}\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (node.body == null) return;\n\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\treturn stack.pop();\n\t\t\t}\n\n\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\telse return undefined;\n\t\t}\n\t\t: function functionExpression (this: Literal, ...args: Literal[]) {\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\tif (this != null) {\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t\t}\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (node.body == null) return;\n\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\treturn stack.pop();\n\t\t\t}\n\n\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\telse return undefined;\n\t\t};\n\n\tif (nameResult != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: nameResult, value: _functionExpression.bind(_functionExpression), reporting, node});\n\t}\n\n\t_functionExpression.toString = () => `[Function${nameResult == null ? \"\" : `: ${nameResult}`}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(\n\t\t_functionExpression,\n\t\tgetFromLexicalEnvironment(node, environment, \"Function\")!.literal as Function\n\t);\n\n\treturn _functionExpression;\n}","import {TryStatement} from \"typescript\";\nimport {EvaluationError} from \"../evaluation-error/evaluation-error\";\nimport {IMissingCatchOrFinallyAfterTryErrorOptions} from \"./i-missing-catch-or-finally-after-try-error-options\";\n\n/**\n * An Error that can be thrown when a TryStatement is encountered without neither a catch {...} nor a finally {...} block\n */\nexport class MissingCatchOrFinallyAfterTryError extends EvaluationError {\n\t/**\n\t * The TryStatement that lacks a catch/finally block\n\t * @type {TryStatement}\n\t */\n\tpublic readonly node: TryStatement;\n\n\tconstructor ({node, message = `Missing catch or finally after try`}: IMissingCatchOrFinallyAfterTryErrorOptions) {\n\t\tsuper({node, message});\n\t}\n}","export const TRY_SYMBOL = \"[try]\";","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TryStatement} from \"typescript\";\nimport {MissingCatchOrFinallyAfterTryError} from \"../error/missing-catch-or-finally-after-try-error/missing-catch-or-finally-after-try-error\";\nimport {clearBindingFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {TRY_SYMBOL} from \"../util/try/try-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a TryStatement\n * @param {IEvaluatorOptions<TryStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateTryStatement ({node, evaluate, environment, reporting, statementTraversalStack}: IEvaluatorOptions<TryStatement>): void {\n\tconst executeTry = () => {\n\t\tsetInLexicalEnvironment({env: environment, reporting, newBinding: true, node, path: TRY_SYMBOL, value: true});\n\t\t// The Block will declare an environment of its own\n\t\tevaluate.statement(node.tryBlock, environment);\n\t};\n\n\tconst executeCatch = (ex: Error) => {\n\t\tclearBindingFromLexicalEnvironment(environment, TRY_SYMBOL);\n\t\t// The CatchClause will declare an environment of its own\n\t\tevaluate.nodeWithArgument(node.catchClause!, environment, ex, statementTraversalStack);\n\t};\n\n\tconst executeFinally = () => {\n\t\tclearBindingFromLexicalEnvironment(environment, TRY_SYMBOL);\n\t\t// The Block will declare an environment of its own\n\t\tevaluate.statement(node.finallyBlock!, environment);\n\t};\n\n\t// A TryStatement must have either a catch or a finally block\n\tif (node.catchClause == null && node.finallyBlock == null) {\n\t\tthrow new MissingCatchOrFinallyAfterTryError({node});\n\t}\n\n\t// Follows the form: try {...} catch {...}\n\telse if (node.catchClause != null && node.finallyBlock == null) {\n\t\ttry {\n\t\t\texecuteTry();\n\t\t} catch (ex) {\n\t\t\texecuteCatch(ex);\n\t\t}\n\t}\n\n\t// Follows the form: try {...} catch {...} finally {...}\n\telse if (node.catchClause != null && node.finallyBlock != null) {\n\t\ttry {\n\t\t\texecuteTry();\n\t\t} catch (ex) {\n\t\t\texecuteCatch(ex);\n\t\t} finally {\n\t\t\texecuteFinally();\n\t\t}\n\t}\n\n\t// Follows the form: try {...} finally {...}\n\telse if (node.catchClause == null && node.finallyBlock != null) {\n\t\ttry {\n\t\t\texecuteTry();\n\t\t} finally {\n\t\t\texecuteFinally();\n\t\t}\n\t}\n}","import {IGenerateClassDeclarationOptions} from \"./i-generate-class-declaration-options\";\n\n/**\n * A function that uses 'new Function' to auto-generate a class with a dynamic name and extended type\n * @param {string} name\n * @param {Literal} extendedType\n * @param {() => void} ctor\n * @return {Function}\n */\nexport function generateClassDeclaration ({name, extendedType, ctor = () => {}}: Partial<IGenerateClassDeclarationOptions>): Function {\n\tif (extendedType == null) {\n\t\treturn new Function(\"ctor\", `return class ${name == null ? \"\" : name} {constructor () {const ctorReturnValue = ctor.call(this, ...arguments); if (ctorReturnValue != null) return ctorReturnValue;}}`)(ctor);\n\t}\n\n\telse {\n\t\treturn new Function(\"extendedType\", \"ctor\", `return class ${name == null ? \"\" : name} extends extendedType {constructor () {super(...arguments); const ctorReturnValue = ctor.call(this, ...arguments); if (ctorReturnValue != null) return ctorReturnValue;}}`)(extendedType, ctor);\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ClassDeclaration, isConstructorDeclaration, SyntaxKind} from \"typescript\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {generateClassDeclaration} from \"../util/class/generate-class-declaration\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\n\n/**\n * Evaluates, or attempts to evaluate, a ClassDeclaration\n * @param {IEvaluatorOptions<FunctionDeclaration>} options\n */\nexport function evaluateClassDeclaration ({node, environment, evaluate, stack, logger, reporting, statementTraversalStack}: IEvaluatorOptions<ClassDeclaration>): void {\n\tlet extendedType: Function|undefined;\n\tconst ctorMember = node.members.find(isConstructorDeclaration);\n\tconst otherMembers = node.members.filter(member => !isConstructorDeclaration(member));\n\n\tlet ctor: Function|undefined;\n\tif (ctorMember != null) {\n\t\tevaluate.declaration(ctorMember, environment, statementTraversalStack);\n\t\tctor = stack.pop() as Function;\n\t}\n\n\tif (node.heritageClauses != null) {\n\t\tconst extendsClause = node.heritageClauses.find(clause => clause.token === SyntaxKind.ExtendsKeyword);\n\t\tif (extendsClause != null) {\n\t\t\tconst [firstExtendedType] = extendsClause.types;\n\t\t\tif (firstExtendedType != null) {\n\t\t\t\textendedType = (evaluate.expression(firstExtendedType.expression, environment, statementTraversalStack)) as Function;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst name = node.name == null ? undefined : node.name.text;\n\tlet classDeclaration = generateClassDeclaration({name, extendedType, ctor});\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [classDeclaration], statementTraversalStack);\n\t\t\tclassDeclaration = stack.pop() as Function;\n\t\t}\n\t}\n\n\tclassDeclaration.toString = () => `[Class${name == null ? \"\" : `: ${name}`}]`;\n\n\tif (name != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: name, value: classDeclaration, newBinding: true, reporting, node});\n\t}\n\n\t// Walk through all of the class members\n\tfor (const member of otherMembers) {\n\t\tevaluate.nodeWithArgument(\n\t\t\tmember,\n\t\t\tenvironment,\n\t\t\thasModifier(member, SyntaxKind.StaticKeyword)\n\t\t\t\t? classDeclaration\n\t\t\t\t: classDeclaration.prototype,\n\t\t\tstatementTraversalStack\n\t\t);\n\t}\n\n\tlogger.logHeritage(classDeclaration);\n\tstack.push(classDeclaration);\n\tlogger.logStack(stack);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ConstructorDeclaration} from \"typescript\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a ConstructorDeclaration\n * @param {IEvaluatorOptions<ConstructorDeclaration>} options\n * @returns {Promise<void>}\n */\nexport function evaluateConstructorDeclaration ({node, environment, evaluate, stack, reporting, ...rest}: IEvaluatorOptions<ConstructorDeclaration>): void {\n\n\t/**\n\t * An implementation of a constructor function\n\t * @param {Literal} args\n\t */\n\tfunction constructor (this: IndexLiteral, ...args: Literal[]) {\n\t\t// Don't concern yourself with calling super here as this constructor is called immediately after calling super() in another memory representation of a class\n\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\t\t}\n\n\t\t// Evaluate the parameters based on the given arguments\n\t\tevaluateParameterDeclarations({\n\t\t\t\tnode: node.parameters,\n\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\tevaluate,\n\t\t\t\tstack,\n\t\t\t\treporting,\n\t\t\t\t...rest\n\t\t\t}, args, this\n\t\t);\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null) return;\n\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn stack.pop();\n\t\t}\n\n\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\telse return undefined;\n\t}\n\n\tconstructor.toString = () => \"[Function: constructor]\";\n\tstack.push(constructor);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {SuperExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a SuperExpression\n * @param {IEvaluatorOptions<SuperExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateSuperExpression ({node, environment}: IEvaluatorOptions<SuperExpression>): Literal {\n\tconst match = getFromLexicalEnvironment(node, environment, SUPER_SYMBOL);\n\treturn match == null ? undefined : match.literal;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {SpreadElement} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a SpreadElement, before applying it on the given parent\n * @param {IEvaluatorOptions<SpreadElement>} options\n * @returns {Promise<Literal[]>}\n */\nexport function evaluateSpreadElement ({environment, node, evaluate, statementTraversalStack}: IEvaluatorOptions<SpreadElement>): Literal[] {\n\treturn (evaluate.expression(node.expression, environment, statementTraversalStack)) as Literal[];\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ClassExpression, isConstructorDeclaration, SyntaxKind} from \"typescript\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {generateClassDeclaration} from \"../util/class/generate-class-declaration\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a ClassExpression\n * @param {IEvaluatorOptions<ClassExpression>} options\n * @returns {Literal}\n */\nexport function evaluateClassExpression ({node, environment, evaluate, stack, logger, reporting, statementTraversalStack}: IEvaluatorOptions<ClassExpression>): Literal {\n\tlet extendedType: Function|undefined;\n\tconst ctorMember = node.members.find(isConstructorDeclaration);\n\tconst otherMembers = node.members.filter(member => !isConstructorDeclaration(member));\n\n\tlet ctor: Function|undefined;\n\tif (ctorMember != null) {\n\t\tevaluate.declaration(ctorMember, environment, statementTraversalStack);\n\t\tctor = stack.pop() as Function;\n\t}\n\n\tif (node.heritageClauses != null) {\n\t\tconst extendsClause = node.heritageClauses.find(clause => clause.token === SyntaxKind.ExtendsKeyword);\n\t\tif (extendsClause != null) {\n\t\t\tconst [firstExtendedType] = extendsClause.types;\n\t\t\tif (firstExtendedType != null) {\n\t\t\t\textendedType = (evaluate.expression(firstExtendedType.expression, environment, statementTraversalStack)) as Function;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst name = node.name == null ? undefined : node.name.text;\n\tlet classExpression = generateClassDeclaration({name, extendedType, ctor});\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [classExpression], statementTraversalStack);\n\t\t\tclassExpression = stack.pop() as Function;\n\t\t}\n\t}\n\n\tclassExpression.toString = () => `[Class${name == null ? \"\" : `: ${name}`}]`;\n\n\tif (name != null) {\n\t\tsetInLexicalEnvironment({env: environment, path: name, value: classExpression, newBinding: true, reporting, node});\n\t}\n\n\t// Walk through all of the class members\n\tfor (const member of otherMembers) {\n\t\tevaluate.nodeWithArgument(\n\t\t\tmember,\n\t\t\tenvironment,\n\t\t\thasModifier(member, SyntaxKind.StaticKeyword)\n\t\t\t\t? classExpression\n\t\t\t\t: classExpression.prototype,\n\t\t\tstatementTraversalStack\n\t\t);\n\t}\n\n\tlogger.logHeritage(classExpression);\n\treturn classExpression;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {NullLiteral} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a NullLiteral\n * @param {IEvaluatorOptions<NullLiteral>} _options\n * @returns {Promise<Literal>}\n */\nexport function evaluateNullLiteral (_options: IEvaluatorOptions<NullLiteral>): Literal {\n\treturn null;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {VoidExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a VoidExpression\n * @param {IEvaluatorOptions<VoidExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateVoidExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<VoidExpression>): Literal {\n\tevaluate.expression(node.expression, environment, statementTraversalStack);\n\t// The void operator evaluates the expression and then returns undefined\n\treturn undefined;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {TypeOfExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a TypeOfExpression\n * @param {IEvaluatorOptions<TypeOfExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateTypeOfExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<TypeOfExpression>): Literal {\n\treturn typeof (evaluate.expression(node.expression, environment, statementTraversalStack));\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {BigIntLiteral} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, a BigIntLiteral\n * @param {IEvaluatorOptions<BigIntLiteral>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateBigIntLiteral ({node, environment}: IEvaluatorOptions<BigIntLiteral>): Literal {\n\t// Use BigInt from the Realm instead of the executing context such that instanceof checks won't fail, etc.\n\tconst _BigInt = getFromLexicalEnvironment(node, environment, \"BigInt\")!.literal as BigIntConstructor;\n\n\t// BigInt allows taking in strings, but they must appear as BigInt literals (e.g. \"2n\" is not allowed, but \"2\" is)\n\treturn _BigInt(node.text.endsWith(\"n\")\n\t\t? node.text.slice(0, -1)\n\t\t: node.text\n\t);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {EnumDeclaration} from \"typescript\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {getFromLexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, an EnumDeclaration\n * @param {IEvaluatorOptions<EnumDeclaration>} options\n * @returns {Promise<void>}\n */\nexport function evaluateEnumDeclaration ({node, environment, evaluate, statementTraversalStack, reporting, stack}: IEvaluatorOptions<EnumDeclaration>): void {\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst enumDeclaration: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\tconst name = node.name.text;\n\n\t// Bind the Enum to the lexical environment as a new binding\n\tsetInLexicalEnvironment({env: environment, path: name, value: enumDeclaration, newBinding: true, reporting, node});\n\n\tfor (const member of node.members) {\n\t\tevaluate.nodeWithArgument(member, environment, enumDeclaration, statementTraversalStack);\n\t}\n\n\tenumDeclaration.toString = () => `[Enum: ${name}]`;\n\n\t// Push the Enum declaration on to the Stack\n\tstack.push(enumDeclaration);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {SourceFile, Symbol} from \"typescript\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, a SourceFile as a namespace object\n * @param {IEvaluatorOptions<SourceFile>} options\n * @returns {Promise<void>}\n */\nexport function evaluateSourceFileAsNamespaceObject ({node, environment, evaluate, typeChecker, stack, statementTraversalStack}: IEvaluatorOptions<SourceFile>): void {\n\t// Create a new ObjectLiteral based on the Object implementation from the Realm since this must not be the same as in the parent executing context\n\t// Otherwise, instanceof checks would fail\n\tconst objectCtor = getFromLexicalEnvironment(node, environment, \"Object\")!.literal as ObjectConstructor;\n\tconst namespaceObject: IndexLiteral = objectCtor.create(objectCtor.prototype);\n\n\tconst moduleSymbol = typeChecker.getSymbolAtLocation(node);\n\tif (moduleSymbol != null) {\n\t\tconst exports = moduleSymbol.exports;\n\t\tif (exports != null) {\n\t\t\tfor (const [identifier, symbol] of (exports.entries() as IterableIterator<[string, Symbol]>)) {\n\n\t\t\t\tconst valueDeclaration = symbol.valueDeclaration;\n\t\t\t\tif (valueDeclaration == null) return;\n\n\t\t\t\tevaluate.declaration(valueDeclaration, environment, statementTraversalStack);\n\t\t\t\tnamespaceObject[identifier] = stack.pop();\n\t\t\t}\n\t\t}\n\t}\n\tstack.push(namespaceObject);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ModuleDeclaration} from \"typescript\";\nimport {getImplementationForDeclarationWithinDeclarationFile} from \"../util/module/get-implementation-for-declaration-within-declaration-file\";\n\n/**\n * Evaluates, or attempts to evaluate, a ModuleDeclaration\n * @param {IEvaluatorOptions<ModuleDeclaration>} options\n * @returns {Promise<void>}\n */\nexport function evaluateModuleDeclaration (options: IEvaluatorOptions<ModuleDeclaration>): void {\n\toptions.stack.push(\n\t\tgetImplementationForDeclarationWithinDeclarationFile(options)\n\t);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ImportDeclaration} from \"typescript\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportDeclaration (which is actually a Statement).\n * It will be a noop, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n * @param {IEvaluatorOptions<ImportDeclaration>} _options\n * @returns {Promise<void>}\n */\nexport function evaluateImportDeclaration (_options: IEvaluatorOptions<ImportDeclaration>): void {\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ThrowStatement} from \"typescript\";\n\n/**\n * Evaluates, or attempts to evaluate, a ThrowStatement\n * @param {IEvaluatorOptions<ThrowStatement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateThrowStatement ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<ThrowStatement>): void {\n\tthrow (evaluate.expression(node.expression!, environment, statementTraversalStack));\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ImportEqualsDeclaration} from \"typescript\";\n\n/**\n * Evaluates, or attempts to evaluate, an ImportEqualsDeclaration (which is actually a Statement).\n * It will be a noop, since we rely on the TypeChecker to resolve symbols across SourceFiles,\n * rather than manually parsing and resolving imports/exports\n * @param {IEvaluatorOptions<ImportEqualsDeclaration>} _options\n * @returns {Promise<void>}\n */\nexport function evaluateImportEqualsDeclaration (_options: IEvaluatorOptions<ImportEqualsDeclaration>): void {\n}","import {IMaxOpDurationExceededErrorOptions} from \"./i-max-op-duration-exceeded-error-options\";\nimport {PolicyError} from \"../policy-error\";\n\n/**\n * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded\n */\nexport class MaxOpDurationExceededError extends PolicyError {\n\t/**\n\t * The total duration of an operation that was being performed before exceeding the limit\n\t */\n\tpublic readonly duration: number;\n\n\tconstructor ({duration, node, message = `Maximum operation duration exceeded: ${duration}`}: IMaxOpDurationExceededErrorOptions) {\n\t\tsuper({violation: \"maxOpDuration\", message, node});\n\t\tthis.duration = duration;\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {AwaitExpression} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {syncAwait} from \"../util/await/sync-await\";\nimport {MaxOpDurationExceededError} from \"../error/policy-error/max-op-duration-exceeded-error/max-op-duration-exceeded-error\";\n\n/**\n * Evaluates, or attempts to evaluate, an AwaitExpression\n * @param {IEvaluatorOptions<AwaitExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateAwaitExpression ({node, environment, evaluate, policy, statementTraversalStack}: IEvaluatorOptions<AwaitExpression>): Literal {\n\t// If a maximum duration for any operation is given, set a timeout that will throw a PolicyError when and if the duration is exceeded.\n\tconst timeout = policy.maxOpDuration === Infinity\n\t\t? undefined\n\t\t: setTimeout(() => {\n\t\t\tthrow new MaxOpDurationExceededError({duration: policy.maxOpDuration, node});\n\t\t}, policy.maxOpDuration);\n\n\tconst result = syncAwait(evaluate.expression(node.expression, environment, statementTraversalStack) as Promise<Literal>);\n\n\t// Make sure to clear the timeout if it exists to avoid throwing unnecessarily\n\tif (timeout != null) clearTimeout(timeout);\n\n\t// Return the evaluated result\n\treturn result;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {ConditionalExpression} from \"typescript\";\n\n// tslint:disable:strict-boolean-expressions\n\n/**\n * Evaluates, or attempts to evaluate, a ConditionalExpression\n * @param {IEvaluatorOptions<ConditionalExpression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateConditionalExpression ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<ConditionalExpression>): Literal {\n\tconst conditionValue = evaluate.expression(node.condition, environment, statementTraversalStack);\n\n\t// We have to perform a loose boolean expression here to conform with actual spec behavior\n\tif (conditionValue) {\n\t\t// Proceed with the truthy branch\n\t\treturn evaluate.expression(node.whenTrue, environment, statementTraversalStack);\n\t}\n\n\t// Proceed with the falsy branch\n\treturn evaluate.expression(node.whenFalse, environment, statementTraversalStack);\n}","import {isSourceFile, Node, SyntaxKind} from \"typescript\";\nimport {hasModifier} from \"../modifier/has-modifier\";\n\n/**\n * Returns true if the given Node exists within a static context\n * @param {Node} node\n * @return {boolean}\n */\nexport function inStaticContext (node: Node): boolean {\n\tlet currentNode = node;\n\twhile (currentNode != null && !isSourceFile(currentNode)) {\n\t\tif (hasModifier(currentNode, SyntaxKind.StaticKeyword)) return true;\n\t\tcurrentNode = currentNode.parent;\n\t}\n\treturn false;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {isClassLike, isIdentifier, MethodDeclaration, SyntaxKind} from \"typescript\";\nimport {getFromLexicalEnvironment, LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\nimport {hasModifier} from \"../util/modifier/has-modifier\";\n\n// tslint:disable:no-identical-functions\n\n/**\n * Evaluates, or attempts to evaluate, a MethodDeclaration, before setting it on the given parent\n * @param {IEvaluatorOptions<MethodDeclaration>} options\n * @param {IndexLiteral} [parent]\n */\nexport function evaluateMethodDeclaration ({node, environment, evaluate, stack, statementTraversalStack, reporting, ...rest}: IEvaluatorOptions<MethodDeclaration>, parent?: IndexLiteral): void {\n\tconst nameResult = (evaluate.nodeWithValue(node.name, environment, statementTraversalStack)) as IndexLiteralKey;\n\tconst isStatic = inStaticContext(node);\n\n\tif (parent == null) {\n\t\tlet updatedParent: Function & IndexLiteral;\n\t\tif (isClassLike(node.parent)) {\n\t\t\tevaluate.declaration(node.parent, environment, statementTraversalStack);\n\t\t\tupdatedParent = stack.pop() as Function & IndexLiteral;\n\t\t}\n\t\telse {\n\t\t\tupdatedParent = evaluate.expression(node.parent, environment, statementTraversalStack) as Function & IndexLiteral;\n\t\t}\n\t\tstack.push(isStatic ? updatedParent[nameResult] : updatedParent.prototype[nameResult]);\n\t\treturn;\n\t}\n\n\tconst _methodDeclaration = hasModifier(node, SyntaxKind.AsyncKeyword)\n\t\t? async function methodDeclaration (this: Literal, ...args: Literal[]) {\n\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\tif (this != null) {\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\t\tsetInLexicalEnvironment({\n\t\t\t\t\tenv: localLexicalEnvironment, path: SUPER_SYMBOL, value: isStatic\n\t\t\t\t\t\t? Object.getPrototypeOf(this)\n\t\t\t\t\t\t: Object.getPrototypeOf((this as Function).constructor).prototype,\n\t\t\t\t\tnewBinding: true,\n\t\t\t\t\treporting,\n\t\t\t\t\tnode\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\tstatementTraversalStack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (node.body == null) return;\n\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\treturn stack.pop();\n\t\t\t}\n\n\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\telse return undefined;\n\t\t}\n\t\t: function methodDeclaration (this: Literal, ...args: Literal[]) {\n\n\t\t\t// Prepare a lexical environment for the function context\n\t\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t\t// Define a new binding for a return symbol within the environment\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t\t// Define a new binding for the arguments given to the function\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\t\tif (this != null) {\n\t\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\t\tsetInLexicalEnvironment({\n\t\t\t\t\tenv: localLexicalEnvironment, path: SUPER_SYMBOL, value: isStatic\n\t\t\t\t\t\t? Object.getPrototypeOf(this)\n\t\t\t\t\t\t: Object.getPrototypeOf((this as Function).constructor).prototype,\n\t\t\t\t\tnewBinding: true,\n\t\t\t\t\treporting,\n\t\t\t\t\tnode\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Evaluate the parameters based on the given arguments\n\t\t\tevaluateParameterDeclarations({\n\t\t\t\t\tnode: node.parameters,\n\t\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\t\tevaluate,\n\t\t\t\t\tstack,\n\t\t\t\t\tstatementTraversalStack,\n\t\t\t\t\treporting,\n\t\t\t\t\t...rest\n\t\t\t\t}, args\n\t\t\t);\n\n\t\t\t// If the body is a block, evaluate it as a statement\n\t\t\tif (node.body == null) return;\n\t\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\n\t\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\t\treturn stack.pop();\n\t\t\t}\n\n\t\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\t\telse return undefined;\n\t\t};\n\n\t_methodDeclaration.toString = () => `[Method: ${nameResult}]`;\n\n\t// Make sure to use the Function that is contained within the Realm. Otherwise, 'instanceof' checks may fail\n\t// since this particular function comes from the executing context.\n\tObject.setPrototypeOf(\n\t\t_methodDeclaration,\n\t\tgetFromLexicalEnvironment(node, environment, \"Function\")!.literal as Function\n\t);\n\n\tparent[nameResult] = _methodDeclaration;\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [parent, nameResult], statementTraversalStack);\n\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\tstack.pop();\n\t\t}\n\t}\n\n\t// Also loop through parameters to use their decorators, if any\n\tif (node.parameters != null) {\n\t\t// 'this' is a special parameter which is removed from the emitted results\n\t\tconst parameters = node.parameters.filter(param => !(isIdentifier(param.name) && param.name.text === \"this\"));\n\t\tfor (let i = 0; i < parameters.length; i++) {\n\t\t\tconst parameter = parameters[i];\n\t\t\tif (parameter.decorators != null) {\n\t\t\t\tfor (const decorator of parameter.decorators) {\n\t\t\t\t\tevaluate.nodeWithArgument(decorator, environment, [parent, nameResult, i], statementTraversalStack);\n\t\t\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {PropertyDeclaration} from \"typescript\";\nimport {IndexLiteral, IndexLiteralKey} from \"../literal/literal\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyDeclaration, before applying it on the given parent\n * @param {IEvaluatorOptions<PropertyDeclaration>} options\n * @param {IndexLiteral} [parent]\n * @returns {Promise<void>}\n */\nexport function evaluatePropertyDeclaration ({environment, node, evaluate, statementTraversalStack, stack}: IEvaluatorOptions<PropertyDeclaration>, parent?: IndexLiteral): void {\n\t// Compute the property name\n\tconst propertyNameResult = (evaluate.nodeWithValue(node.name, environment, statementTraversalStack)) as IndexLiteralKey;\n\n\tif (parent == null) {\n\t\tevaluate.declaration(node.parent, environment, statementTraversalStack);\n\t\tconst updatedParent = stack.pop() as Function&IndexLiteral;\n\t\tconst isStatic = inStaticContext(node);\n\t\tstack.push(isStatic ? updatedParent[propertyNameResult] : updatedParent.prototype[propertyNameResult]);\n\t\treturn;\n\t}\n\n\tparent[propertyNameResult] = node.initializer == null\n\t\t? undefined\n\t\t: evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\tif (node.decorators != null) {\n\t\tfor (const decorator of node.decorators) {\n\t\t\tevaluate.nodeWithArgument(decorator, environment, [parent, propertyNameResult], statementTraversalStack);\n\t\t\t// Pop the stack. We don't need the value it has left on the Stack\n\t\t\tstack.pop();\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {GetAccessorDeclaration, isClassLike} from \"typescript\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\n\n/**\n * Evaluates, or attempts to evaluate, a GetAccessorDeclaration, before setting it on the given parent\n * @param {IEvaluatorOptions<GetAccessorDeclaration>} options\n * @param {IndexLiteral} [parent]\n */\nexport function evaluateGetAccessorDeclaration ({node, environment, evaluate, stack, reporting, statementTraversalStack}: IEvaluatorOptions<GetAccessorDeclaration>, parent?: IndexLiteral): void {\n\n\tconst nameResult = (evaluate.nodeWithValue(node.name, environment, statementTraversalStack)) as IndexLiteralKey;\n\tconst isStatic = inStaticContext(node);\n\n\tif (parent == null) {\n\t\tlet updatedParent: Function & IndexLiteral;\n\t\tif (isClassLike(node.parent)) {\n\t\t\tevaluate.declaration(node.parent, environment, statementTraversalStack);\n\t\t\tupdatedParent = stack.pop() as Function & IndexLiteral;\n\t\t}\n\t\telse {\n\t\t\tupdatedParent = evaluate.expression(node.parent, environment, statementTraversalStack) as Function & IndexLiteral;\n\t\t}\n\t\tstack.push(isStatic ? updatedParent[nameResult] : updatedParent.prototype[nameResult]);\n\t\treturn;\n\t}\n\n\t/**\n\t * An implementation of the get accessor\n\t */\n\tfunction getAccessorDeclaration (this: Literal) {\n\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\tsetInLexicalEnvironment({\n\t\t\t\tenv: localLexicalEnvironment, path: SUPER_SYMBOL, value: isStatic\n\t\t\t\t\t? Object.getPrototypeOf(this)\n\t\t\t\t\t: Object.getPrototypeOf((this as Function).constructor).prototype,\n\t\t\t\tnewBinding: true,\n\t\t\t\treporting,\n\t\t\t\tnode\n\t\t\t});\n\t\t}\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null) return;\n\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\t\t// If a 'return' has occurred within the block, pop the Stack and return that value\n\t\tif (pathInLexicalEnvironmentEquals(node, localLexicalEnvironment, true, RETURN_SYMBOL)) {\n\t\t\treturn stack.pop();\n\t\t}\n\n\t\t// Otherwise, return 'undefined'. Nothing is returned from the function\n\t\telse return undefined;\n\t}\n\n\tgetAccessorDeclaration.toString = () => `[Get: ${nameResult}]`;\n\n\tlet currentPropertyDescriptor = Object.getOwnPropertyDescriptor(parent, nameResult);\n\tif (currentPropertyDescriptor == null) currentPropertyDescriptor = {};\n\n\tObject.defineProperty(parent, nameResult, {\n\t\t...currentPropertyDescriptor,\n\t\tconfigurable: true,\n\t\tget: getAccessorDeclaration\n\t});\n}","import {\n\tisArrayLiteralExpression, isArrowFunction, isAsExpression, isAwaitExpression, isBigIntLiteral, isBinaryExpression, isBlock, isBreakStatement, isCallExpression, isClassDeclaration, isClassExpression, isComputedPropertyName, isConditionalExpression, isConstructorDeclaration, isContinueStatement, isElementAccessExpression, isEnumDeclaration, isExpressionStatement, isForInStatement, isForOfStatement, isForStatement, isFunctionDeclaration, isFunctionExpression, isGetAccessorDeclaration, isIdentifier, isIfStatement, isImportDeclaration, isImportEqualsDeclaration, isMethodDeclaration, isModuleDeclaration, isNewExpression, isNonNullExpression, isNumericLiteral, isObjectLiteralExpression, isParenthesizedExpression, isPostfixUnaryExpression, isPrefixUnaryExpression, isPropertyAccessExpression, isPropertyDeclaration, isRegularExpressionLiteral, isReturnStatement, isSourceFile, isSpreadElement, isStringLiteralLike, isSwitchStatement, isTemplateExpression, isThrowStatement, isTryStatement, isTypeAssertion, isTypeOfExpression, isVariableDeclaration, isVariableDeclarationList, isVariableStatement, isVoidExpression, isWhileStatement, Node\n} from \"typescript\";\nimport {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {evaluateVariableDeclaration} from \"./evaluate-variable-declaration\";\nimport {evaluateBinaryExpression} from \"./evaluate-binary-expression\";\nimport {evaluateCallExpression} from \"./evaluate-call-expression\";\nimport {evaluateParenthesizedExpression} from \"./evaluate-parenthesized-expression\";\nimport {evaluateArrowFunctionExpression} from \"./evaluate-arrow-function-expression\";\nimport {evaluateStringLiteral} from \"./evaluate-string-literal\";\nimport {evaluateNumericLiteral} from \"./evaluate-numeric-literal\";\nimport {evaluateBooleanLiteral} from \"./evaluate-boolean-literal\";\nimport {evaluateRegularExpressionLiteral} from \"./evaluate-regular-expression-literal\";\nimport {evaluateObjectLiteralExpression} from \"./evaluate-object-literal-expression\";\nimport {evaluateArrayLiteralExpression} from \"./evaluate-array-literal-expression\";\nimport {evaluateIdentifier} from \"./evaluate-identifier\";\nimport {evaluateBlock} from \"./evaluate-block\";\nimport {evaluateReturnStatement} from \"./evaluate-return-statement\";\nimport {evaluateVariableStatement} from \"./evaluate-variable-statement\";\nimport {evaluateVariableDeclarationList} from \"./evaluate-variable-declaration-list\";\nimport {evaluatePrefixUnaryExpression} from \"./evaluate-prefix-unary-expression\";\nimport {evaluatePropertyAccessExpression} from \"./evaluate-property-access-expression\";\nimport {evaluateElementAccessExpression} from \"./evaluate-element-access-expression\";\nimport {evaluateComputedPropertyName} from \"./evaluate-computed-property-name\";\nimport {evaluateFunctionDeclaration} from \"./evaluate-function-declaration\";\nimport {evaluateIfStatement} from \"./evaluate-if-statement\";\nimport {evaluateExpressionStatement} from \"./evaluate-expression-statement\";\nimport {evaluateTemplateExpression} from \"./evaluate-template-expression\";\nimport {evaluateTypeAssertion} from \"./evaluate-type-assertion-expression\";\nimport {evaluatePostfixUnaryExpression} from \"./evaluate-postfix-unary-expression\";\nimport {evaluateNewExpression} from \"./evaluate-new-expression\";\nimport {evaluateNonNullExpression} from \"./evaluate-non-null-expression\";\nimport {evaluateAsExpression} from \"./evaluate-as-expression\";\nimport {evaluateSwitchStatement} from \"./evaluate-switch-statement\";\nimport {evaluateForOfStatement} from \"./evaluate-for-of-statement\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {isBooleanLiteral} from \"../util/node/is-boolean-literal\";\nimport {isThisExpression} from \"../util/node/is-this-expression\";\nimport {evaluateThisExpression} from \"./evaluate-this-expression\";\nimport {evaluateBreakStatement} from \"./evaluate-break-statement\";\nimport {evaluateContinueStatement} from \"./evaluate-continue-statement\";\nimport {evaluateForStatement} from \"./evaluate-for-statement\";\nimport {evaluateWhileStatement} from \"./evaluate-while-statement\";\nimport {evaluateForInStatement} from \"./evaluate-for-in-statement\";\nimport {evaluateFunctionExpression} from \"./evaluate-function-expression\";\nimport {evaluateTryStatement} from \"./evaluate-try-statement\";\nimport {evaluateClassDeclaration} from \"./evaluate-class-declaration\";\nimport {evaluateConstructorDeclaration} from \"./evaluate-constructor-declaration\";\nimport {isSuperExpression} from \"../util/node/is-super-expression\";\nimport {evaluateSuperExpression} from \"./evaluate-super-expression\";\nimport {evaluateSpreadElement} from \"./evaluate-spread-element\";\nimport {evaluateClassExpression} from \"./evaluate-class-expression\";\nimport {isNullLiteral} from \"../util/node/is-null-literal\";\nimport {evaluateNullLiteral} from \"./evaluate-null-literal\";\nimport {evaluateVoidExpression} from \"./evaluate-void-expression\";\nimport {evaluateTypeOfExpression} from \"./evaluate-type-of-expression\";\nimport {evaluateBigIntLiteral} from \"./evaluate-big-int-literal\";\nimport {evaluateEnumDeclaration} from \"./evaluate-enum-declaration\";\nimport {evaluateSourceFileAsNamespaceObject} from \"./evaluate-source-file-as-namespace-object\";\nimport {evaluateModuleDeclaration} from \"./evaluate-module-declaration\";\nimport {evaluateImportDeclaration} from \"./evaluate-import-declaration\";\nimport {evaluateThrowStatement} from \"./evaluate-throw-statement\";\nimport {evaluateImportEqualsDeclaration} from \"./evaluate-import-equals-declaration\";\nimport {evaluateAwaitExpression} from \"./evaluate-await-expression\";\nimport {evaluateConditionalExpression} from \"./evaluate-conditional-expression\";\nimport {evaluateMethodDeclaration} from \"./evaluate-method-declaration\";\nimport {evaluatePropertyDeclaration} from \"./evaluate-property-declaration\";\nimport {evaluateGetAccessorDeclaration} from \"./evaluate-get-accessor-declaration\";\n\n/**\n * Will get a literal value for the given Node. If it doesn't succeed, the value will be 'undefined'\n * @param {IEvaluatorOptions<Node>} options\n * @returns {Promise<unknown>}\n */\nexport function evaluateNode ({node, ...rest}: IEvaluatorOptions<Node>): unknown {\n\n\tif (isIdentifier(node)) {\n\t\treturn evaluateIdentifier({node, ...rest});\n\t}\n\n\telse if (isStringLiteralLike(node)) {\n\t\treturn evaluateStringLiteral({node, ...rest});\n\t}\n\n\telse if (isNumericLiteral(node)) {\n\t\treturn evaluateNumericLiteral({node, ...rest});\n\t}\n\n\telse if (isBooleanLiteral(node)) {\n\t\treturn evaluateBooleanLiteral({node, ...rest});\n\t}\n\n\telse if (isForOfStatement(node)) {\n\t\treturn evaluateForOfStatement({node, ...rest});\n\t}\n\n\telse if (isForInStatement(node)) {\n\t\treturn evaluateForInStatement({node, ...rest});\n\t}\n\n\telse if (isForStatement(node)) {\n\t\treturn evaluateForStatement({node, ...rest});\n\t}\n\n\telse if (isWhileStatement(node)) {\n\t\treturn evaluateWhileStatement({node, ...rest});\n\t}\n\n\telse if (isRegularExpressionLiteral(node)) {\n\t\treturn evaluateRegularExpressionLiteral({node, ...rest});\n\t}\n\n\telse if (isObjectLiteralExpression(node)) {\n\t\treturn evaluateObjectLiteralExpression({node, ...rest});\n\t}\n\n\telse if (isAwaitExpression(node)) {\n\t\treturn evaluateAwaitExpression({node, ...rest});\n\t}\n\n\telse if (isTypeAssertion(node)) {\n\t\treturn evaluateTypeAssertion({node, ...rest});\n\t}\n\n\telse if (isTemplateExpression(node)) {\n\t\treturn evaluateTemplateExpression({node, ...rest});\n\t}\n\n\telse if (isMethodDeclaration(node)) {\n\t\treturn evaluateMethodDeclaration({node, ...rest});\n\t}\n\n\telse if (isPropertyDeclaration(node)) {\n\t\treturn evaluatePropertyDeclaration({node, ...rest});\n\t}\n\n\telse if (isGetAccessorDeclaration(node)) {\n\t\treturn evaluateGetAccessorDeclaration({node, ...rest});\n\t}\n\n\telse if (isArrayLiteralExpression(node)) {\n\t\treturn evaluateArrayLiteralExpression({node, ...rest});\n\t}\n\n\telse if (isSourceFile(node)) {\n\t\treturn evaluateSourceFileAsNamespaceObject({node, ...rest});\n\t}\n\n\telse if (isModuleDeclaration(node)) {\n\t\treturn evaluateModuleDeclaration({node, ...rest});\n\t}\n\n\telse if (isPrefixUnaryExpression(node)) {\n\t\treturn evaluatePrefixUnaryExpression({node, ...rest});\n\t}\n\n\telse if (isPostfixUnaryExpression(node)) {\n\t\treturn evaluatePostfixUnaryExpression({node, ...rest});\n\t}\n\n\telse if (isVariableStatement(node)) {\n\t\treturn evaluateVariableStatement({node, ...rest});\n\t}\n\n\telse if (isComputedPropertyName(node)) {\n\t\treturn evaluateComputedPropertyName({node, ...rest});\n\t}\n\n\telse if (isVariableDeclarationList(node)) {\n\t\treturn evaluateVariableDeclarationList({node, ...rest});\n\t}\n\n\telse if (isImportDeclaration(node)) {\n\t\treturn evaluateImportDeclaration({node, ...rest});\n\t}\n\n\telse if (isImportEqualsDeclaration(node)) {\n\t\treturn evaluateImportEqualsDeclaration({node, ...rest});\n\t}\n\n\telse if (isThrowStatement(node)) {\n\t\treturn evaluateThrowStatement({node, ...rest});\n\t}\n\n\telse if (isVariableDeclaration(node)) {\n\t\treturn evaluateVariableDeclaration({node, ...rest});\n\t}\n\n\telse if (isEnumDeclaration(node)) {\n\t\treturn evaluateEnumDeclaration({node, ...rest});\n\t}\n\n\telse if (isConstructorDeclaration(node)) {\n\t\treturn evaluateConstructorDeclaration({node, ...rest});\n\t}\n\n\telse if (isBinaryExpression(node)) {\n\t\treturn evaluateBinaryExpression({node, ...rest});\n\t}\n\n\telse if (isParenthesizedExpression(node)) {\n\t\treturn evaluateParenthesizedExpression({node, ...rest});\n\t}\n\n\telse if (isExpressionStatement(node)) {\n\t\treturn evaluateExpressionStatement({node, ...rest});\n\t}\n\n\telse if (isArrowFunction(node)) {\n\t\treturn evaluateArrowFunctionExpression({node, ...rest});\n\t}\n\n\telse if (isFunctionDeclaration(node)) {\n\t\treturn evaluateFunctionDeclaration({node, ...rest});\n\t}\n\n\telse if (isFunctionExpression(node)) {\n\t\treturn evaluateFunctionExpression({node, ...rest});\n\t}\n\n\telse if (isClassDeclaration(node)) {\n\t\treturn evaluateClassDeclaration({node, ...rest});\n\t}\n\n\telse if (isIfStatement(node)) {\n\t\treturn evaluateIfStatement({node, ...rest});\n\t}\n\n\telse if (isConditionalExpression(node)) {\n\t\treturn evaluateConditionalExpression({node, ...rest});\n\t}\n\n\telse if (isPropertyAccessExpression(node)) {\n\t\treturn evaluatePropertyAccessExpression({node, ...rest});\n\t}\n\n\telse if (isElementAccessExpression(node)) {\n\t\treturn evaluateElementAccessExpression({node, ...rest});\n\t}\n\n\telse if (isCallExpression(node)) {\n\t\treturn evaluateCallExpression({node, ...rest});\n\t}\n\n\telse if (isSwitchStatement(node)) {\n\t\treturn evaluateSwitchStatement({node, ...rest});\n\t}\n\n\telse if (isNewExpression(node)) {\n\t\treturn evaluateNewExpression({node, ...rest});\n\t}\n\n\telse if (isNonNullExpression(node)) {\n\t\treturn evaluateNonNullExpression({node, ...rest});\n\t}\n\n\telse if (isAsExpression(node)) {\n\t\treturn evaluateAsExpression({node, ...rest});\n\t}\n\n\telse if (isBlock(node)) {\n\t\treturn evaluateBlock({node, ...rest});\n\t}\n\n\telse if (isClassExpression(node)) {\n\t\treturn evaluateClassExpression({node, ...rest});\n\t}\n\n\telse if (isSpreadElement(node)) {\n\t\treturn evaluateSpreadElement({node, ...rest});\n\t}\n\n\telse if (isTryStatement(node)) {\n\t\treturn evaluateTryStatement({node, ...rest});\n\t}\n\n\telse if (isReturnStatement(node)) {\n\t\treturn evaluateReturnStatement({node, ...rest});\n\t}\n\n\telse if (isThisExpression(node)) {\n\t\treturn evaluateThisExpression({node, ...rest});\n\t}\n\n\telse if (isVoidExpression(node)) {\n\t\treturn evaluateVoidExpression({node, ...rest});\n\t}\n\n\telse if (isTypeOfExpression(node)) {\n\t\treturn evaluateTypeOfExpression({node, ...rest});\n\t}\n\n\telse if (isSuperExpression(node)) {\n\t\treturn evaluateSuperExpression({node, ...rest});\n\t}\n\n\telse if (isNullLiteral(node)) {\n\t\treturn evaluateNullLiteral({node, ...rest});\n\t}\n\n\telse if (isBigIntLiteral(node)) {\n\t\treturn evaluateBigIntLiteral({node, ...rest});\n\t}\n\n\telse if (isBreakStatement(node)) {\n\t\treturn evaluateBreakStatement({node, ...rest});\n\t}\n\n\telse if (isContinueStatement(node)) {\n\t\treturn evaluateContinueStatement({node, ...rest});\n\t}\n\n\tthrow new UnexpectedNodeError({node});\n}","import {SyntaxKind} from \"typescript\";\n\nexport type StatementTraversalStack = SyntaxKind[];\n\n/**\n * Creates a StatementTraversalStack\n * @return {StatementTraversalStack}\n */\nexport function createStatementTraversalStack (): StatementTraversalStack {\n\treturn [];\n}","import {Statement} from \"typescript\";\nimport {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {evaluateNode} from \"./evaluate-node\";\nimport {createStatementTraversalStack} from \"../stack/traversal-stack/statement-traversal-stack\";\n\n/**\n * Will get a literal value for the given Statement. If it doesn't succeed, the value will be 'undefined'\n * @param {IEvaluatorOptions<Statement>} options\n * @returns {Promise<void>}\n */\nexport function evaluateStatement (options: IEvaluatorOptions<Statement>): void {\n\toptions.logger.logNode(options.node);\n\n\t// Create a new Statement traversal stack (since this is a new statement)\n\toptions.statementTraversalStack = createStatementTraversalStack();\n\n\tevaluateNode(options);\n}","import {Expression} from \"typescript\";\nimport {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {evaluateNode} from \"./evaluate-node\";\n\n/**\n * Will get a literal value for the given Expression. If it doesn't succeed, the value will be 'undefined'\n * @param {IEvaluatorOptions<Expression>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluateExpression (options: IEvaluatorOptions<Expression>): Literal {\n\toptions.logger.logNode(options.node);\n\tconst value = evaluateNode(options) as Promise<Literal>;\n\n\t// Report intermediate results\n\tif (options.reporting.reportIntermediateResults != null) {\n\t\toptions.reporting.reportIntermediateResults({\n\t\t\tnode: options.node,\n\t\t\tvalue\n\t\t});\n\t}\n\n\treturn value;\n}","import {Declaration} from \"typescript\";\nimport {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {evaluateNode} from \"./evaluate-node\";\n\n/**\n * Will get a literal value for the given Declaration. If it doesn't succeed, the value will be 'undefined'\n * @param {IEvaluatorOptions<Declaration>} options\n * @returns {Promise<void>}\n */\nexport function evaluateDeclaration (options: IEvaluatorOptions<Declaration>): void {\n\toptions.logger.logNode(options.node);\n\n\tevaluateNode(options);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {BindingName, isIdentifier} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, a BindingName, based on an initializer\n * @param {IEvaluatorOptions<BindingName>} options\n * @param {Literal} rightHandValue\n * @returns {Promise<void>}\n */\nexport function evaluateBindingName ({node, environment, evaluate, statementTraversalStack, reporting, logger}: IEvaluatorOptions<BindingName>, rightHandValue: Literal): void {\n\t// If the declaration binds a simple identifier, bind that text to the environment\n\tif (isIdentifier(node)) {\n\t\tsetInLexicalEnvironment({env: environment, path: node.text, value: rightHandValue, newBinding: true, reporting, node});\n\t\tlogger.logBinding(node.text, rightHandValue, \"evaluateBindingName\");\n\t}\n\n\telse {\n\t\tevaluate.nodeWithArgument(node, environment, rightHandValue, statementTraversalStack);\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {SetAccessorDeclaration} from \"typescript\";\nimport {LexicalEnvironment, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {THIS_SYMBOL} from \"../util/this/this-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {inStaticContext} from \"../util/static/in-static-context\";\nimport {SUPER_SYMBOL} from \"../util/super/super-symbol\";\nimport {evaluateParameterDeclarations} from \"./evaluate-parameter-declarations\";\n\n/**\n * Evaluates, or attempts to evaluate, a SetAccessorDeclaration, before setting it on the given parent\n * @param {IEvaluatorOptions<SetAccessorDeclaration>} options\n * @param {IndexLiteral} parent\n */\nexport function evaluateSetAccessorDeclaration ({node, environment, evaluate, statementTraversalStack, reporting, stack, ...rest}: IEvaluatorOptions<SetAccessorDeclaration>, parent: IndexLiteral): void {\n\n\tconst nameResult = (evaluate.nodeWithValue(node.name, environment, statementTraversalStack)) as IndexLiteralKey;\n\tconst isStatic = inStaticContext(node);\n\n\t/**\n\t * An implementation of the set accessor\n\t * @param {Literal} args\n\t */\n\tfunction setAccessorDeclaration (this: Literal, ...args: Literal[]) {\n\n\t\t// Prepare a lexical environment for the function context\n\t\tconst localLexicalEnvironment: LexicalEnvironment = cloneLexicalEnvironment(environment);\n\n\t\t// Define a new binding for a return symbol within the environment\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: RETURN_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\t\t// Define a new binding for the arguments given to the function\n\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: \"arguments\", value: arguments, newBinding: true, reporting, node});\n\n\t\tif (this != null) {\n\t\t\tsetInLexicalEnvironment({env: localLexicalEnvironment, path: THIS_SYMBOL, value: this, newBinding: true, reporting, node});\n\n\t\t\t// Set the 'super' binding, depending on whether or not we're inside a static context\n\t\t\tsetInLexicalEnvironment({\n\t\t\t\tenv: localLexicalEnvironment, path: SUPER_SYMBOL, value: isStatic\n\t\t\t\t\t? Object.getPrototypeOf(this)\n\t\t\t\t\t: Object.getPrototypeOf((this as Function).constructor).prototype,\n\t\t\t\tnewBinding: true,\n\t\t\t\treporting,\n\t\t\t\tnode\n\t\t\t});\n\t\t}\n\n\t\t// Evaluate the parameters based on the given arguments\n\t\tevaluateParameterDeclarations({\n\t\t\t\tnode: node.parameters,\n\t\t\t\tenvironment: localLexicalEnvironment,\n\t\t\t\tevaluate,\n\t\t\t\tstack,\n\t\t\t\tstatementTraversalStack,\n\t\t\t\treporting,\n\t\t\t\t...rest\n\t\t\t}, args\n\t\t);\n\n\t\t// If the body is a block, evaluate it as a statement\n\t\tif (node.body == null) return;\n\t\tevaluate.statement(node.body, localLexicalEnvironment);\n\t}\n\n\tsetAccessorDeclaration.toString = () => `[Set: ${nameResult}]`;\n\n\tlet currentPropertyDescriptor = Object.getOwnPropertyDescriptor(parent, nameResult);\n\tif (currentPropertyDescriptor == null) currentPropertyDescriptor = {};\n\n\tObject.defineProperty(parent, nameResult, {\n\t\t...currentPropertyDescriptor,\n\t\tconfigurable: true,\n\t\tset: setAccessorDeclaration\n\t});\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {PropertyAssignment} from \"typescript\";\nimport {IndexLiteral, IndexLiteralKey} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyAssignment, before applying it on the given parent\n * @param {IEvaluatorOptions<PropertyAssignment>} options\n * @param {IndexLiteral} parent\n * @returns {Promise<void>}\n */\nexport function evaluatePropertyAssignment ({environment, node, evaluate, statementTraversalStack}: IEvaluatorOptions<PropertyAssignment>, parent: IndexLiteral): void {\n\tconst initializer = evaluate.expression(node.initializer, environment, statementTraversalStack);\n\t// Compute the property name\n\tconst propertyNameResult = (evaluate.nodeWithValue(node.name, environment, statementTraversalStack)) as IndexLiteralKey;\n\n\tparent[propertyNameResult] = initializer;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ParameterDeclaration} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a ParameterDeclaration\n * @param {IEvaluatorOptions<ParameterDeclaration>} options\n * @param {Literal} boundArgument\n * @returns {Promise<void>}\n */\nexport function evaluateParameterDeclaration ({node, environment, evaluate, statementTraversalStack, logger}: IEvaluatorOptions<ParameterDeclaration>, boundArgument: Literal): void {\n\n\t// Use the bound argument if it is given unless it is nullable and the node itself has an initializer\n\tconst boundValue = boundArgument != null || node.initializer === undefined\n\t\t? boundArgument\n\t\t: evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\tlogger.logBinding(node.name.getText(), boundValue, \"evaluateParameterDeclaration\");\n\tevaluate.nodeWithArgument(node.name, environment, boundValue, statementTraversalStack);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ShorthandPropertyAssignment} from \"typescript\";\nimport {IndexLiteral} from \"../literal/literal\";\nimport {getFromLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {UndefinedIdentifierError} from \"../error/undefined-identifier-error/undefined-identifier-error\";\n\n/**\n * Evaluates, or attempts to evaluate, a ShorthandPropertyAssignment, before applying it on the given parent\n * @param {IEvaluatorOptions<ShorthandPropertyAssignment>} options\n * @param {IndexLiteral} parent\n * @returns {Promise<void>}\n */\nexport function evaluateShorthandPropertyAssignment ({environment, node}: IEvaluatorOptions<ShorthandPropertyAssignment>, parent: IndexLiteral): void {\n\tconst identifier = node.name.text;\n\tconst match = getFromLexicalEnvironment(node, environment, identifier);\n\n\tif (match == null) {\n\t\tthrow new UndefinedIdentifierError({node: node.name});\n\t}\n\n\tparent[identifier] = match.literal;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {SpreadAssignment} from \"typescript\";\nimport {IndexLiteral} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a SpreadAssignment, before applying it on the given parent\n * @param {IEvaluatorOptions<SpreadAssignment>} options\n * @param {IndexLiteral} parent\n * @returns {Promise<void>}\n */\nexport function evaluateSpreadAssignment ({environment, node, evaluate, statementTraversalStack}: IEvaluatorOptions<SpreadAssignment>, parent: IndexLiteral): void {\n\tconst entries = (evaluate.expression(node.expression, environment, statementTraversalStack)) as IndexLiteral;\n\tObject.assign(parent, entries);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ArrayBindingPattern} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, an ArrayBindingPattern, based on an initializer\n * @param {IEvaluatorOptions<ArrayBindingPattern>} options\n * @param {Iterable<Literal>} rightHandValue\n * @returns {Promise<void>}\n */\nexport function evaluateArrayBindingPattern ({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<ArrayBindingPattern>, rightHandValue: Iterable<Literal>): void {\n\tconst iterator = rightHandValue[Symbol.iterator]();\n\tlet elementsCursor = 0;\n\n\twhile (elementsCursor < node.elements.length) {\n\t\tconst {done, value} = iterator.next();\n\t\tif (done === true) break;\n\n\t\tevaluate.nodeWithArgument(node.elements[elementsCursor++], environment, value, statementTraversalStack);\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {BindingElement, isArrayBindingPattern, isIdentifier} from \"typescript\";\nimport {IndexLiteral, IndexLiteralKey, Literal} from \"../literal/literal\";\nimport {setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, a BindingName, based on an BindingElement\n * @param {IEvaluatorOptions<BindingElement>} options\n * @param {Literal} rightHandValue\n * @returns {Promise<void>}\n */\nexport function evaluateBindingElement ({environment, node, evaluate, logger, reporting, statementTraversalStack}: IEvaluatorOptions<BindingElement>, rightHandValue: Literal): void {\n\t// Compute the initializer value of the BindingElement, if it has any, that is\n\tconst bindingElementInitializer = node.initializer == null\n\t\t? undefined\n\t\t: evaluate.expression(node.initializer, environment, statementTraversalStack);\n\n\t// If the element is directly references a property, but then aliases, store that alias in the environment.\n\tif (isIdentifier(node.name) && node.propertyName != null) {\n\n\t\t// An element that is aliased cannot have a name that is anything other than an Identifier\n\t\tconst aliasName = node.name.text;\n\n\t\t// Compute the property name\n\t\tconst propertyNameResult = (evaluate.nodeWithValue(node.propertyName, environment, statementTraversalStack)) as IndexLiteralKey;\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = isArrayBindingPattern(node.parent)\n\t\t\t? rightHandValue\n\t\t\t: (rightHandValue as IndexLiteral)[propertyNameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null\n\t\t\t? propertyValue\n\t\t\t: bindingElementInitializer;\n\n\t\tsetInLexicalEnvironment({\n\t\t\tenv: environment,\n\t\t\tpath: aliasName,\n\t\t\tvalue: propertyValueWithInitializerFallback,\n\t\t\tnewBinding: true,\n\t\t\tnode,\n\t\t\treporting\n\t\t});\n\t}\n\n\t// If the name is a simple non-aliased identifier, it directly references, a property from the right-hand value\n\telse if (isIdentifier(node.name) && node.propertyName == null) {\n\n\t\t// Compute the literal value of the name of the node\n\t\tconst nameResult = node.name.text;\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = isArrayBindingPattern(node.parent)\n\t\t\t? rightHandValue\n\t\t\t: (rightHandValue as IndexLiteral)[nameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null\n\t\t\t? propertyValue\n\t\t\t: bindingElementInitializer;\n\n\t\tlogger.logBinding(node.name.text, propertyValueWithInitializerFallback);\n\n\t\tsetInLexicalEnvironment({\n\t\t\tenv: environment,\n\t\t\tpath: node.name.text,\n\t\t\tvalue: propertyValueWithInitializerFallback,\n\t\t\tnewBinding: true,\n\t\t\tnode,\n\t\t\treporting\n\t\t});\n\t}\n\n\t// Otherwise, the name is itself a BindingPattern, and the property it is destructuring will always be defined\n\telse if (!isIdentifier(node.name) && node.propertyName != null) {\n\t\t// Compute the property name\n\t\tconst propertyNameResult = (evaluate.nodeWithValue(node.propertyName, environment, statementTraversalStack)) as IndexLiteralKey;\n\n\t\t// Extract the property value from the initializer. If it is an ArrayBindingPattern, the rightHandValue will be assigned as-is to the identifier\n\t\tconst propertyValue = isArrayBindingPattern(node.parent)\n\t\t\t? rightHandValue\n\t\t\t: (rightHandValue as IndexLiteral)[propertyNameResult];\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = propertyValue != null\n\t\t\t? propertyValue\n\t\t\t: bindingElementInitializer;\n\n\t\t// Evaluate the BindingPattern based on the narrowed property value\n\t\tevaluate.nodeWithArgument(node.name, environment, propertyValueWithInitializerFallback, statementTraversalStack);\n\t}\n\n\t// Otherwise, the name itself is a BindingPattern. This will happen for example if an ObjectBindingPattern occurs within an ArrayBindingPattern\n\telse if (!isIdentifier(node.name) && node.propertyName == null) {\n\n\t\t// Fall back to using the initializer of the BindingElement if the property value is null-like and if it has one\n\t\tconst propertyValueWithInitializerFallback = rightHandValue != null\n\t\t\t? rightHandValue\n\t\t\t: bindingElementInitializer;\n\n\t\tevaluate.nodeWithArgument(node.name, environment, propertyValueWithInitializerFallback, statementTraversalStack);\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {ObjectBindingPattern} from \"typescript\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, an ObjectBindingPattern, based on an initializer\n * @param {IEvaluatorOptions<ObjectBindingPattern>} options\n * @param {Literal} rightHandValue\n */\nexport function evaluateObjectBindingPattern ({node, environment, evaluate, statementTraversalStack}: IEvaluatorOptions<ObjectBindingPattern>, rightHandValue: Literal): void {\n\tfor (const element of node.elements) {\n\t\tevaluate.nodeWithArgument(element, environment, rightHandValue, statementTraversalStack);\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {CaseBlock} from \"typescript\";\nimport {pathInLexicalEnvironmentEquals, setInLexicalEnvironment} from \"../lexical-environment/lexical-environment\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a CaseBlock, based on a switch expression\n * @param {IEvaluatorOptions<CaseBlock>} options\n * @param {Literal} switchExpression\n * @returns {Promise<void>}\n */\nexport function evaluateCaseBlock ({node, evaluate, environment, reporting, statementTraversalStack}: IEvaluatorOptions<CaseBlock>, switchExpression: Literal): void {\n\t// Prepare a lexical environment for the case block\n\tconst localEnvironment = cloneLexicalEnvironment(environment);\n\t// Define a new binding for a break symbol within the environment\n\tsetInLexicalEnvironment({env: localEnvironment, path: BREAK_SYMBOL, value: false, newBinding: true, reporting, node});\n\n\tfor (const clause of node.clauses) {\n\t\tevaluate.nodeWithArgument(clause, localEnvironment, switchExpression, statementTraversalStack);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, localEnvironment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {CaseClause} from \"typescript\";\nimport {pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\nimport {Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a CaseClause, based on a switch expression\n * @param {IEvaluatorOptions<CaseClause>} options\n * @param {Literal} switchExpression\n * @returns {Promise<void>}\n */\nexport function evaluateCaseClause ({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<CaseClause>, switchExpression: Literal): void {\n\tconst expressionResult = evaluate.expression(node.expression, environment, statementTraversalStack);\n\t// Stop immediately if the expression doesn't match the switch expression\n\tif (expressionResult !== switchExpression) return;\n\n\tfor (const statement of node.statements) {\n\t\tevaluate.statement(statement, environment);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, environment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {DefaultClause} from \"typescript\";\nimport {pathInLexicalEnvironmentEquals} from \"../lexical-environment/lexical-environment\";\nimport {BREAK_SYMBOL} from \"../util/break/break-symbol\";\nimport {CONTINUE_SYMBOL} from \"../util/continue/continue-symbol\";\nimport {RETURN_SYMBOL} from \"../util/return/return-symbol\";\n\n/**\n * Evaluates, or attempts to evaluate, a DefaultClause, based on a switch expression\n * @param {IEvaluatorOptions<DefaultClause>} options\n */\nexport function evaluateDefaultClause ({node, evaluate, environment}: IEvaluatorOptions<DefaultClause>): void {\n\n\tfor (const statement of node.statements) {\n\t\tevaluate.statement(statement, environment);\n\n\t\t// Check if a 'break', 'continue', or 'return' statement has been encountered, break the block\n\t\tif (pathInLexicalEnvironmentEquals(node, environment, true, BREAK_SYMBOL, CONTINUE_SYMBOL, RETURN_SYMBOL)) {\n\t\t\tbreak;\n\t\t}\n\t}\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {CatchClause} from \"typescript\";\nimport {cloneLexicalEnvironment} from \"../lexical-environment/clone-lexical-environment\";\n\n/**\n * Evaluates, or attempts to evaluate, a CatchClause, based on a given Error\n * @param {IEvaluatorOptions<CatchClause>} options\n * @param {Error} ex\n */\nexport function evaluateCatchClause ({node, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<CatchClause>, ex: Error): void {\n\t// If a catch binding is provided, we must provide a local lexical environment for the CatchBlock\n\tconst catchEnvironment = node.variableDeclaration == null ? environment : cloneLexicalEnvironment(environment);\n\n\t// Evaluate the catch binding, if any is provided\n\tif (node.variableDeclaration != null) {\n\t\tevaluate.nodeWithArgument(node.variableDeclaration, catchEnvironment, ex, statementTraversalStack);\n\t}\n\n\t// Evaluate the block\n\tevaluate.statement(node.block, catchEnvironment);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {OmittedExpression} from \"typescript\";\n\n/**\n * Evaluates, or attempts to evaluate, a OmittedExpression\n * @param {IEvaluatorOptions<OmittedExpression>} _options\n * @returns {Promise<undefined>}\n */\nexport function evaluateOmittedExpression (_options: IEvaluatorOptions<OmittedExpression>): undefined {\n\treturn undefined;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Decorator} from \"typescript\";\nimport {IndexLiteral, stringifyLiteral} from \"../literal/literal\";\nimport {NotCallableError} from \"../error/not-callable-error/not-callable-error\";\nimport {__decorate, __param} from \"tslib\";\n\n/**\n * Evaluates, or attempts to evaluate, a Decorator\n * @param {IEvaluatorOptions<Decorator>} options\n * @param {*} args\n * @param {IndexLiteral} parent\n * @returns {Promise<void>}\n */\nexport function evaluateDecorator ({node, environment, evaluate, stack, statementTraversalStack}: IEvaluatorOptions<Decorator>, [parent, propertyName, index]: [IndexLiteral, string?, number?]): void {\n\tconst decoratorImplementation = evaluate.expression(node.expression, environment, statementTraversalStack);\n\n\tif (typeof decoratorImplementation !== \"function\") {\n\t\tthrow new NotCallableError({node, value: decoratorImplementation, message: `${stringifyLiteral(decoratorImplementation)} is not a valid decorator implementation'`});\n\t}\n\n\tstack.push(\n\t\t__decorate([\n\t\t\tindex != null\n\t\t\t\t? __param(index, decoratorImplementation)\n\t\t\t\t: decoratorImplementation\n\t\t], parent, propertyName)\n\t);\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {EnumMember} from \"typescript\";\nimport {IndexLiteral, IndexLiteralKey} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, an EnumMember\n * @param {IEvaluatorOptions<EnumMember>} options\n * @param {IndexLiteral} parent\n */\nexport function evaluateEnumMember ({node, typeChecker, evaluate, environment, statementTraversalStack}: IEvaluatorOptions<EnumMember>, parent: IndexLiteral): void {\n\tconst constantValue = typeChecker.getConstantValue(node) as number|string;\n\tconst propertyName = (evaluate.nodeWithValue(node.name, environment, statementTraversalStack)) as IndexLiteralKey;\n\n\t// If it is a String enum, all keys will be initialized to strings\n\tif (typeof constantValue === \"string\") {\n\t\tparent[propertyName] = constantValue;\n\t}\n\n\telse {\n\t\tparent[parent[propertyName] = constantValue] = propertyName;\n\t}\n}","import {isArrayBindingPattern, isBindingElement, isBindingName, isCaseBlock, isCaseClause, isCatchClause, isDecorator, isDefaultClause, isEnumMember, isGetAccessorDeclaration, isMethodDeclaration, isObjectBindingPattern, isOmittedExpression, isParameter, isPropertyAssignment, isPropertyDeclaration, isSetAccessorDeclaration, isShorthandPropertyAssignment, isSpreadAssignment, isVariableDeclaration, Node} from \"typescript\";\nimport {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {IndexLiteral, Literal} from \"../literal/literal\";\nimport {evaluateBindingName} from \"./evaluate-binding-name\";\nimport {evaluateGetAccessorDeclaration} from \"./evaluate-get-accessor-declaration\";\nimport {evaluateSetAccessorDeclaration} from \"./evaluate-set-accessor-declaration\";\nimport {evaluatePropertyAssignment} from \"./evaluate-property-assignment\";\nimport {evaluateParameterDeclaration} from \"./evaluate-parameter-declaration\";\nimport {evaluateShorthandPropertyAssignment} from \"./evaluate-shorthand-property-assignment\";\nimport {evaluateSpreadAssignment} from \"./evaluate-spread-assignment\";\nimport {evaluateMethodDeclaration} from \"./evaluate-method-declaration\";\nimport {evaluateArrayBindingPattern} from \"./evaluate-array-binding-pattern\";\nimport {evaluateBindingElement} from \"./evaluate-binding-element\";\nimport {evaluateObjectBindingPattern} from \"./evaluate-object-binding-pattern\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\nimport {evaluateCaseBlock} from \"./evaluate-case-block\";\nimport {evaluateCaseClause} from \"./evaluate-case-clause\";\nimport {evaluateDefaultClause} from \"./evaluate-default-clause\";\nimport {evaluateVariableDeclaration} from \"./evaluate-variable-declaration\";\nimport {evaluateCatchClause} from \"./evaluate-catch-clause\";\nimport {evaluateOmittedExpression} from \"./evaluate-omitted-expression\";\nimport {evaluatePropertyDeclaration} from \"./evaluate-property-declaration\";\nimport {evaluateDecorator} from \"./evaluate-decorator\";\nimport {evaluateEnumMember} from \"./evaluate-enum-member\";\n\n/**\n * Evaluates a given node with the provided argument\n * @param {IEvaluatorOptions<Expression>} options\n * @param {Literal} arg\n * @returns {Promise<void>}\n */\nexport function evaluateNodeWithArgument (options: IEvaluatorOptions<Node>, arg: Literal): void {\n\toptions.logger.logNode(options.node, \"nodeWithArgument\");\n\tconst {node, ...rest} = options;\n\n\tif (isGetAccessorDeclaration(node)) {\n\t\treturn evaluateGetAccessorDeclaration({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isSetAccessorDeclaration(node)) {\n\t\treturn evaluateSetAccessorDeclaration({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isPropertyAssignment(node)) {\n\t\treturn evaluatePropertyAssignment({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isPropertyDeclaration(node)) {\n\t\treturn evaluatePropertyDeclaration({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isParameter(node)) {\n\t\treturn evaluateParameterDeclaration({node, ...rest}, arg);\n\t}\n\n\telse if (isEnumMember(node)) {\n\t\treturn evaluateEnumMember({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isShorthandPropertyAssignment(node)) {\n\t\treturn evaluateShorthandPropertyAssignment({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isDecorator(node)) {\n\t\treturn evaluateDecorator({node, ...rest}, arg as [IndexLiteral, string?]);\n\t}\n\n\telse if (isSpreadAssignment(node)) {\n\t\treturn evaluateSpreadAssignment({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isMethodDeclaration(node)) {\n\t\treturn evaluateMethodDeclaration({node, ...rest}, arg as IndexLiteral);\n\t}\n\n\telse if (isArrayBindingPattern(node)) {\n\t\treturn evaluateArrayBindingPattern({node, ...rest}, arg as Iterable<Literal>);\n\t}\n\n\telse if (isBindingElement(node)) {\n\t\treturn evaluateBindingElement({node, ...rest}, arg);\n\t}\n\n\telse if (isObjectBindingPattern(node)) {\n\t\treturn evaluateObjectBindingPattern({node, ...rest}, arg);\n\t}\n\n\telse if (isVariableDeclaration(node)) {\n\t\treturn evaluateVariableDeclaration({node, ...rest}, arg);\n\t}\n\n\telse if (isCaseBlock(node)) {\n\t\treturn evaluateCaseBlock({node, ...rest}, arg);\n\t}\n\n\telse if (isCaseClause(node)) {\n\t\treturn evaluateCaseClause({node, ...rest}, arg);\n\t}\n\n\telse if (isDefaultClause(node)) {\n\t\treturn evaluateDefaultClause({node, ...rest});\n\t}\n\n\telse if (isCatchClause(node)) {\n\t\treturn evaluateCatchClause({node, ...rest}, arg as Error);\n\t}\n\n\telse if (isBindingName(node)) {\n\t\treturn evaluateBindingName({node, ...rest}, arg);\n\t}\n\n\telse if (isOmittedExpression(node)) {\n\t\treturn evaluateOmittedExpression({node, ...rest});\n\t}\n\n\tthrow new UnexpectedNodeError({node});\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {isComputedPropertyName, isIdentifier, PropertyName} from \"typescript\";\nimport {IndexLiteralKey, Literal} from \"../literal/literal\";\n\n/**\n * Evaluates, or attempts to evaluate, a PropertyName\n * @param {IEvaluatorOptions<PropertyName>} options\n * @returns {Promise<Literal>}\n */\nexport function evaluatePropertyName ({environment, node, evaluate, statementTraversalStack}: IEvaluatorOptions<PropertyName>): Literal {\n\treturn (\n\t\tisComputedPropertyName(node)\n\t\t\t? evaluate.expression(node.expression, environment, statementTraversalStack)\n\t\t\t: isIdentifier(node)\n\t\t\t? node.text\n\t\t\t: evaluate.expression(node, environment, statementTraversalStack)\n\t) as IndexLiteralKey;\n}","import {IEvaluatorOptions} from \"./i-evaluator-options\";\nimport {Literal} from \"../literal/literal\";\nimport {NodeWithValue} from \"./node-evaluator/node-evaluator\";\nimport {isPropertyName} from \"typescript\";\nimport {evaluatePropertyName} from \"./evaluate-property-name\";\nimport {UnexpectedNodeError} from \"../error/unexpected-node-error/unexpected-node-error\";\n\n/**\n * Evaluates a given node with the provided argument\n * @param {IEvaluatorOptions<Expression>} options\n * @returns {Literal}\n */\nexport function evaluateNodeWithValue (options: IEvaluatorOptions<NodeWithValue>): Literal {\n\toptions.logger.logNode(options.node, \"nodeWithValue\");\n\tconst {node, ...rest} = options;\n\n\tif (isPropertyName(node)) {\n\t\treturn evaluatePropertyName({node, ...rest});\n\t}\n\n\tthrow new UnexpectedNodeError({node});\n}","import {Node} from \"typescript\";\nimport {ReportingOptionsSanitized} from \"../../reporting/i-reporting-options\";\nimport {EvaluationError} from \"../../error/evaluation-error/evaluation-error\";\n\n/**\n * Reports an error\n * @param {ReportingOptionsSanitized} reporting\n * @param {Error} error\n * @param {Node} node\n */\nexport function reportError (reporting: ReportingOptionsSanitized, error: Error, node: Node): void {\n\t// Report the error if a reporter is hooked up\n\tif (reporting.reportErrors != null && !reporting.reportedErrorSet.has(error)) {\n\t\treporting.reportedErrorSet.add(error);\n\t\treporting.reportErrors({\n\t\t\terror: error,\n\t\t\tnode: error instanceof EvaluationError\n\t\t\t\t? error.node\n\t\t\t\t: node\n\t\t});\n\t}\n}","import {Declaration, Expression, Node, Statement} from \"typescript\";\nimport {ICreateNodeEvaluatorOptions} from \"./i-create-node-evaluator-options\";\nimport {NodeEvaluator, NodeWithValue} from \"./node-evaluator\";\nimport {MaxOpsExceededError} from \"../../error/policy-error/max-ops-exceeded-error/max-ops-exceeded-error\";\nimport {LexicalEnvironment, pathInLexicalEnvironmentEquals} from \"../../lexical-environment/lexical-environment\";\nimport {evaluateStatement} from \"../evaluate-statement\";\nimport {Literal} from \"../../literal/literal\";\nimport {evaluateExpression} from \"../evaluate-expression\";\nimport {IEvaluatorOptions} from \"../i-evaluator-options\";\nimport {evaluateDeclaration} from \"../evaluate-declaration\";\nimport {evaluateNodeWithArgument} from \"../evaluate-node-with-argument\";\nimport {evaluateNodeWithValue} from \"../evaluate-node-with-value\";\nimport {createStatementTraversalStack, StatementTraversalStack} from \"../../stack/traversal-stack/statement-traversal-stack\";\nimport {reportError} from \"../../util/reporting/report-error\";\nimport {TRY_SYMBOL} from \"../../util/try/try-symbol\";\n\n/**\n * Creates a Node Evaluator\n * @param {ICreateNodeEvaluatorOptions} options\n * @returns {NodeEvaluator}\n */\nexport function createNodeEvaluator ({typeChecker, policy, logger, stack, reporting, nextNode}: ICreateNodeEvaluatorOptions): NodeEvaluator {\n\tlet ops = 0;\n\n\tconst handleNewNode = (node: Node, statementTraversalStack: StatementTraversalStack) => {\n\t\tnextNode(node);\n\n\t\t// Increment the amount of encountered ops\n\t\tops++;\n\n\t\t// Throw an error if the maximum amount of operations has been exceeded\n\t\tif (ops >= policy.maxOps) {\n\t\t\tthrow new MaxOpsExceededError({ops, node});\n\t\t}\n\n\t\t// Update the statementTraversalStack with the node's kind\n\t\tstatementTraversalStack.push(node.kind);\n\t\tif (reporting.reportTraversal != null) {\n\t\t\treporting.reportTraversal({node});\n\t\t}\n\t};\n\n\t/**\n\t * Wraps an evaluation action with error reporting\n\t * @param {LexicalEnvironment} environment\n\t * @param {ts.Node} node\n\t * @param {Function} action\n\t */\n\tconst wrapWithErrorReporting = (environment: LexicalEnvironment, node: Node, action: Function) => {\n\t\t// If we're already inside of a try-block, simply execute the action and do nothing else\n\t\tif (pathInLexicalEnvironmentEquals(node, environment, true, TRY_SYMBOL)) {\n\t\t\treturn action();\n\t\t}\n\n\t\ttry {\n\t\t\treturn action();\n\t\t} catch (ex) {\n\t\t\t// Report the Error\n\t\t\treportError(reporting, ex, node);\n\n\t\t\t// Re-throw the error\n\t\t\tthrow ex;\n\t\t}\n\t};\n\n\tconst nodeEvaluator: NodeEvaluator = {\n\t\texpression: (node: Expression, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): Literal => {\n\t\t\treturn wrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateExpression(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t});\n\t\t},\n\t\tstatement: (node: Statement, environment: LexicalEnvironment): void => {\n\t\t\treturn wrapWithErrorReporting(environment, node, () => {\n\t\t\t\tconst statementTraversalStack = createStatementTraversalStack();\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateStatement(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t});\n\t\t},\n\t\tdeclaration: (node: Declaration, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): void => {\n\t\t\treturn wrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateDeclaration(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t});\n\t\t},\n\t\tnodeWithArgument: (node: Node, environment: LexicalEnvironment, arg: Literal, statementTraversalStack: StatementTraversalStack): void => {\n\t\t\treturn wrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateNodeWithArgument(getEvaluatorOptions(node, environment, statementTraversalStack), arg);\n\t\t\t});\n\t\t},\n\t\tnodeWithValue: (node: NodeWithValue, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): Literal => {\n\t\t\treturn wrapWithErrorReporting(environment, node, () => {\n\t\t\t\thandleNewNode(node, statementTraversalStack);\n\t\t\t\treturn evaluateNodeWithValue(getEvaluatorOptions(node, environment, statementTraversalStack));\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * Gets an IEvaluatorOptions object ready for passing to one of the evaluation functions\n\t * @param {T} node\n\t * @param {LexicalEnvironment} environment\n\t * @param {StatementTraversalStack} statementTraversalStack\n\t * @return {IEvaluatorOptions<T>}\n\t */\n\tfunction getEvaluatorOptions<T extends Node> (node: T, environment: LexicalEnvironment, statementTraversalStack: StatementTraversalStack): IEvaluatorOptions<T> {\n\t\treturn {\n\t\t\ttypeChecker,\n\t\t\tpolicy,\n\t\t\treporting,\n\t\t\tnode,\n\t\t\tevaluate: nodeEvaluator,\n\t\t\tenvironment,\n\t\t\tstack,\n\t\t\tlogger,\n\t\t\tstatementTraversalStack\n\t\t};\n\t}\n\n\treturn nodeEvaluator;\n}","import {SyntaxKind} from \"typescript\";\n\n/**\n * Stringifies the given SyntaxKind\n * @param {SyntaxKind} kind\n * @returns {string}\n */\nexport function stringifySyntaxKind (kind: SyntaxKind): string {\n\tif (kind === SyntaxKind.NumericLiteral) return \"NumericLiteral\";\n\treturn SyntaxKind[kind];\n}","import {LogLevelKind} from \"./log-level\";\nimport {Node} from \"typescript\";\nimport chalk from \"chalk\";\nimport {stringifySyntaxKind} from \"../util/syntax-kind/stringify-syntax-kind\";\nimport {Literal, stringifyLiteral} from \"../literal/literal\";\nimport {Stack} from \"../stack/stack\";\nimport {StatementTraversalStack} from \"../stack/traversal-stack/statement-traversal-stack\";\nimport {inspect} from \"util\";\n\n/**\n * A simple logger for printing evaluation-related info\n */\nexport class Logger {\n\n\tconstructor (public readonly logLevel: LogLevelKind) {\n\t}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs info output if the log level allows it\n\t * @param {string} message\n\t */\n\tpublic logInfo (message: string): void {\n\t\tif (this.logLevel < LogLevelKind.INFO) return;\n\t\tconsole.log(message);\n\t}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs verbose output if the log level allows it\n\t * @param {string} message\n\t */\n\tpublic logVerbose (message: string): void {\n\t\tif (this.logLevel < LogLevelKind.VERBOSE) return;\n\t\tconsole.log(message);\n\t}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs debug output if the log level allows it\n\t * @param {string} message\n\t */\n\tpublic logDebug (message: string): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(message);\n\t}\n\n\t/**\n\t * Logs that a 'continue' keyword appeared within a statement\n\t * @param {Node} node\n\t */\n\tpublic logContinue (node: Node): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`${chalk.yellow(`continue`)} encountered within ${chalk.yellow(stringifySyntaxKind(node.kind))}`);\n\t}\n\n\t/**\n\t * Logs that a 'break' keyword appeared within a statement\n\t * @param {Node} node\n\t */\n\tpublic logBreak (node: Node): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`${chalk.yellow(`break`)} encountered within ${chalk.yellow(stringifySyntaxKind(node.kind))}`);\n\t}\n\n\t/**\n\t * Logs that a 'return' keyword appeared within a statement\n\t * @param {Node} node\n\t */\n\tpublic logReturn (node: Node): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`${chalk.yellow(`return`)} encountered within ${chalk.yellow(stringifySyntaxKind(node.kind))}`);\n\t}\n\n\t/**\n\t * Logs the given result\n\t * @param {Literal} result\n\t * @param {string} [intermediateContext]\n\t */\n\tpublic logResult (result: Literal, intermediateContext?: string): void {\n\t\tif (this.logLevel < LogLevelKind.INFO) return;\n\t\tif (intermediateContext != null) {\n\t\t\tconsole.log(chalk.gray(`(intermediate value from context '${intermediateContext}'): `), chalk.green(`[RESULT]:`), this.compactValue(result));\n\t\t}\n\t\telse console.log(chalk.green(`[RESULT]:`), result);\n\t}\n\n\t/**\n\t * Logs the given evaluation\n\t * @param {Node} node\n\t * @param {string} context\n\t */\n\tpublic logNode (node: Node, context?: string): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\n\t\tlet headRaw = `[${stringifySyntaxKind(node.kind)}]`.padEnd(25);\n\t\tif (context != null) headRaw += chalk.cyan(`(${context})`);\n\t\tconst tailRaw = node.getText();\n\n\t\tconst head = chalk.yellow(headRaw);\n\t\tconst tail = chalk.gray(tailRaw);\n\n\t\tconsole.log(head);\n\t\tconsole.log(tail);\n\t}\n\n\t/**\n\t * Logs the given binding\n\t * @param {string} lValue\n\t * @param {Literal} rValue\n\t * @param {string} scope\n\t */\n\tpublic logBinding (lValue: string, rValue: Literal, scope?: string): void {\n\t\tif (this.logLevel < LogLevelKind.VERBOSE) return;\n\t\tconsole.log(`${scope == null ? \"\" : chalk.green(`(${scope}): `)}${chalk.red(lValue)} ->`, this.compactValue(rValue));\n\t}\n\n\t/**\n\t * Logs the heritage of a ClassDeclaration\n\t * @param {Function} classDeclaration\n\t */\n\tpublic logHeritage (classDeclaration: Function): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconst parent = Object.getPrototypeOf(classDeclaration);\n\t\tif (parent.toString().includes(\"[Class\")) {\n\t\t\tconsole.log(`${chalk.cyan(classDeclaration.toString())} ${chalk.yellow(\"extends\")} ${chalk.cyan(parent.toString())}`);\n\t\t}\n\t}\n\n\t/**\n\t * Logs the newest value has been pushed onto the Stack\n\t * @param {Literal[]} stack\n\t */\n\tpublic logStack (stack: Stack): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`Stack value: ${chalk.blue(stringifyLiteral(this.compactValue(stack.lastItem)))}`);\n\t}\n\n\t// noinspection JSUnusedGlobalSymbols\n\t/**\n\t * Logs the entire Traversal Stack\n\t * @param {StatementTraversalStack} stack\n\t */\n\tpublic logStatementTraversalStack (stack: StatementTraversalStack): void {\n\t\tif (this.logLevel < LogLevelKind.DEBUG) return;\n\t\tconsole.log(`[${stack.map(kind => chalk.blue(stringifySyntaxKind(kind))).join(\", \")}]`);\n\t}\n\n\t/**\n\t * Makes a value compact so it is easier on the eyes when printing it\n\t * @param {T} value\n\t * @return {string}\n\t */\n\tprivate compactValue<T> (value: T): string {\n\t\treturn inspect(value, {depth: 0, colors: true, compact: true, maxArrayLength: 5});\n\t}\n}","import * as ts from \"typescript\";\n\n/**\n * Returns true if the given Node is an Expression.\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n * @param {Node} node\n * @return {node is Expression}\n */\nexport function isExpression (node: ts.Node): node is ts.Expression {\n\treturn (ts as unknown as { isExpressionNode (node: ts.Node): boolean }).isExpressionNode(node) || ts.isIdentifier(node);\n}","import * as ts from \"typescript\";\n\n/**\n * Returns true if the given Node is a Statement\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n * @param {Node} node\n * @return {node is Statement}\n */\nexport function isStatement (node: ts.Node): node is ts.Statement {\n\treturn (ts as unknown as {isStatementButNotDeclaration (node: ts.Node): boolean}).isStatementButNotDeclaration(node);\n}","import {Literal} from \"../literal/literal\";\n\nexport interface Stack {\n\treadonly length: number;\n\treadonly lastItem: StackEntry|undefined;\n\t[Symbol.iterator] (): IterableIterator<StackEntry>;\n\tpush (...values: StackEntry[]): number;\n\tpop (): StackEntry|undefined;\n}\n\nexport type StackEntry = Literal;\n\n/**\n * Creates a Stack\n * @return {Stack}\n */\nexport function createStack (): Stack {\n\tconst stack: StackEntry[] = [];\n\n\treturn {\n\t\t/**\n\t\t * Gets an iterator for the Stack\n\t\t * @return {IterableIterator<Literal>}\n\t\t */\n\t\t[Symbol.iterator] () {\n\t\t\treturn stack[Symbol.iterator]();\n\t\t},\n\n\t\t/**\n\t\t * Gets the length of the Stack\n\t\t * @return {number}\n\t\t */\n\t\tget length () {\n\t\t\treturn stack.length;\n\t\t},\n\n\t\t/**\n\t\t * Gets the last item of the Stack\n\t\t * @return {StackEntry}\n\t\t */\n\t\tget lastItem () {\n\t\t\treturn stack[stack.length - 1];\n\t\t},\n\n\t\t/**\n\t\t * Pushes the given StackEntries on to the Stack\n\t\t * @param {StackEntry} values\n\t\t * @return {number}\n\t\t */\n\t\tpush (...values: StackEntry[]) {\n\t\t\treturn stack.push(...values);\n\t\t},\n\n\t\t/**\n\t\t * Pops the last item from the stack\n\t\t * @return {StackEntry | undefined}\n\t\t */\n\t\tpop () {\n\t\t\treturn stack.pop();\n\t\t}\n\t};\n}","import * as ts from \"typescript\";\n\n/**\n * Returns true if the given Node is a Declaration\n * Uses an internal non-exposed Typescript helper to decide whether or not the Node is an Expression\n * @param {Node} node\n * @return {node is Declaration}\n */\nexport function isDeclaration (node: ts.Node): node is ts.Declaration {\n\treturn (ts as unknown as {isDeclaration (node: ts.Node): boolean}).isDeclaration(node);\n}","export type ReportedErrorSet = WeakSet<Error>;\n\n/**\n * Creates and returns a Set of Errors that has been seen and has been reported\n * @returns {WeakSet<Error>}\n */\nexport function createReportedErrorSet (): ReportedErrorSet {\n\treturn new WeakSet<Error>();\n}","import {IEvaluateOptions} from \"./i-evaluate-options\";\nimport {createLexicalEnvironment} from \"./lexical-environment/lexical-environment\";\nimport {EvaluateResult} from \"./evaluate-result\";\nimport {evaluateSimpleLiteral} from \"./evaluator/simple/evaluate-simple-literal\";\nimport {createNodeEvaluator} from \"./evaluator/node-evaluator/create-node-evaluator\";\nimport {LogLevelKind} from \"./logger/log-level\";\nimport {Logger} from \"./logger/logger\";\nimport {createStatementTraversalStack} from \"./stack/traversal-stack/statement-traversal-stack\";\nimport {isExpression} from \"./util/expression/is-expression\";\nimport {Literal} from \"./literal/literal\";\nimport {isStatement} from \"./util/statement/is-statement\";\nimport {createStack, Stack} from \"./stack/stack\";\nimport {isDeclaration} from \"./util/declaration/is-declaration\";\nimport {UnexpectedNodeError} from \"./error/unexpected-node-error/unexpected-node-error\";\nimport {IEvaluatePolicySanitized} from \"./policy/i-evaluate-policy\";\nimport {EnvironmentPresetKind} from \"./environment/environment-preset-kind\";\nimport {Node} from \"typescript\";\nimport {reportError} from \"./util/reporting/report-error\";\nimport {createReportedErrorSet} from \"./reporting/reported-error-set\";\nimport {ReportingOptionsSanitized} from \"./reporting/i-reporting-options\";\n\n/**\n * Will get a literal value for the given Expression, ExpressionStatement, or Declaration.\n * @param {IEvaluateOptions} options\n * @returns {Promise<EvaluateResult>}\n */\nexport function evaluate ({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypeChecker,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tenvironment: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpreset = EnvironmentPresetKind.NODE,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\textra = {}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} = {},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogLevel = LogLevelKind.SILENT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpolicy: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeterministic = false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnetwork = false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole = false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaxOps = Infinity,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaxOpDuration = Infinity,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tio = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tread: true,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twrite: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocess = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texit: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tspawnChild: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} = {},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treporting: reportingInput = {}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}: IEvaluateOptions): EvaluateResult {\n\t// Take the simple path first. This may be far more performant than building up an environment\n\tconst simpleLiteralResult = evaluateSimpleLiteral(node);\n\tif (simpleLiteralResult.success) return simpleLiteralResult;\n\n\t// Otherwise, build an environment and get to work\n\t// Sanitize the evaluation policy based on the input options\n\tconst policy: IEvaluatePolicySanitized = {\n\t\tdeterministic,\n\t\tmaxOps,\n\t\tmaxOpDuration,\n\t\tnetwork,\n\t\tconsole,\n\t\tio: {\n\t\t\tread: typeof io === \"boolean\" ? io : io.read,\n\t\t\twrite: typeof io === \"boolean\" ? io : io.write\n\t\t},\n\t\tprocess: {\n\t\t\texit: typeof process === \"boolean\" ? process : process.exit,\n\t\t\tspawnChild: typeof process === \"boolean\" ? process : process.spawnChild\n\t\t}\n\t};\n\n\t// Sanitize the Reporting options based on the input options\n\tconst reporting: ReportingOptionsSanitized = {\n\t\t...reportingInput,\n\t\treportedErrorSet: createReportedErrorSet()\n\t};\n\n\t// Prepare a reference to the Node that is currently being evaluated\n\tlet currentNode: Node = node;\n\n\t// Prepare a logger\n\tconst logger = new Logger(logLevel);\n\n\t// Prepare the initial environment\n\tconst initialEnvironment = createLexicalEnvironment({\n\t\tinputEnvironment: {\n\t\t\tpreset,\n\t\t\textra\n\t\t},\n\t\tpolicy,\n\t\tgetCurrentNode: () => currentNode\n\t});\n\n\t// Prepare a Stack\n\tconst stack: Stack = createStack();\n\n\t// Prepare a NodeEvaluator\n\tconst nodeEvaluator = createNodeEvaluator({\n\t\tpolicy,\n\t\ttypeChecker,\n\t\tlogger,\n\t\tstack,\n\t\treporting: reporting,\n\t\tnextNode: nextNode => currentNode = nextNode\n\t});\n\n\ttry {\n\t\tlet value: Literal;\n\t\tif (isExpression(node)) {\n\t\t\tvalue = nodeEvaluator.expression(node, initialEnvironment, createStatementTraversalStack());\n\t\t}\n\n\t\telse if (isStatement(node)) {\n\t\t\tnodeEvaluator.statement(node, initialEnvironment);\n\t\t\tvalue = stack.pop();\n\t\t}\n\n\t\telse if (isDeclaration(node)) {\n\t\t\tnodeEvaluator.declaration(node, initialEnvironment, createStatementTraversalStack());\n\t\t\tvalue = stack.pop();\n\t\t}\n\n\t\t// Otherwise, throw an UnexpectedNodeError\n\t\telse {\n\t\t\t// noinspection ExceptionCaughtLocallyJS\n\t\t\tthrow new UnexpectedNodeError({node});\n\t\t}\n\n\t\t// Log the value before returning\n\t\tlogger.logResult(value);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t\tvalue\n\t\t};\n\t} catch (reason) {\n\t\t// Report the Error\n\t\treportError(reporting, reason, node);\n\n\t\treturn {\n\t\t\tsuccess: false,\n\t\t\treason\n\t\t};\n\t}\n}"],"names":["ts.isExpressionNode","ts.isIdentifier","ts.isStatementButNotDeclaration","ts.isDeclaration"],"mappings":";;;;;;;;AAAA;;;;;AAKA,SAAgB,YAAY,CAAK,KAAQ;IACxC,OAAO,KAAK,IAAI,IAAI,KAAK,OAAO,KAAK,KAAK,UAAU,IAAI,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC;CACnF;;;;;;AAOD,SAAgB,aAAa,CAAK,KAAQ;IACzC,OAAO,YAAY,CAAC,KAAK,CAAC,CAAC;;;CAC3B,DCdD;;;;;;AAMA,SAAgB,eAAe,CAAE,IAAc,EAAE,WAAgC;IAChF,QAAQ,IAAI;QACX,KAAK,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC;QAC7B,KAAK,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC;QAC7B,KAAK,QAAQ,CAAC,SAAS,CAAC,KAAK;YAC5B,OAAO,IAAI,CAAC;KACb;IAED,IAAI,WAAW,IAAI,IAAI,EAAE;QACxB,MAAM,SAAS,GAAG,yBAAyB,CAAC,SAAS,EAAE,WAAW,EAAE,UAAU,CAAE,CAAC,OAAmB,CAAC;QACrG,QAAQ,IAAI;YACX,KAAK,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC;YAC9B,KAAK,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC;YAC9B,KAAK,SAAS,CAAC,SAAS,CAAC,KAAK;gBAC7B,OAAO,IAAI,CAAC;SACb;KACD;IACD,OAAO,KAAK,CAAC;;;CACb,DCrBD;;;;;AAKA,SAAS,aAAa,CAAE,IAAmB;IAC1C,OAAO,IAAI;SACT,GAAG,CAAC,IAAI,IAAI,OAAO,IAAI,KAAK,QAAQ,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;SAC/D,IAAI,CAAC,GAAG,CAAC,CAAC;CACZ;;;;;;AAOD,SAAgB,iBAAiB,CAAoB,EAAC,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAuC;;;;;;;IAQrH,SAAS,gBAAgB,CAAoB,SAAwB,EAAE,WAAc;QACpF,OAAO,CAAC,aAAa,CAAC,WAAW,CAAC,IAAI,eAAe,CAAC,WAAuB,CAAC,GAAG,WAAW,GAAG,IAAI,KAAK,CAAC,WAAW,EAAE;;;;;;;;YASrH,SAAS,CAAE,MAAS,EAAE,QAAmB,EAAE,SAAmB;;gBAE7D,IAAI,CAAC,IAAI,CAAC;oBACT,IAAI;oBACJ,MAAM;oBACN,SAAS;oBACT,QAAQ;oBACR,MAAM;oBACN,IAAI,EAAE,aAAa,CAAC,SAAS,CAAC;iBAC9B,CAAC;oBAAE,OAAO,EAAE,CAAC;gBAEd,OAAO,OAAO,CAAC,SAAS,CAAW,MAAM,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;aAChE;;;;;;;;YASD,KAAK,CAAE,MAAS,EAAE,OAAgB,EAAE,WAAsB,EAAE;;gBAE3D,IAAI,CAAC,IAAI,CAAC;oBACT,IAAI;oBACJ,MAAM;oBACN,OAAO;oBACP,QAAQ;oBACR,MAAM;oBACN,IAAI,EAAE,aAAa,CAAC,SAAS,CAAC;iBAC9B,CAAC;oBAAE,OAAO;gBAEX,OAAO,OAAO,CAAC,KAAK,CAAC,MAAkB,EAAE,OAAO,EAAE,QAAQ,CAAC,CAAC;aAC5D;;;;;;;;YASD,GAAG,CAAE,MAAS,EAAE,QAAgB,EAAE,QAAiB;gBAClD,MAAM,OAAO,GAAG,CAAC,GAAG,SAAS,EAAE,QAAQ,CAAC,CAAC;;gBAGzC,IAAI,CAAC,IAAI,CAAC;oBACT,IAAI;oBACJ,MAAM;oBACN,IAAI,EAAE,aAAa,CAAC,OAAO,CAAC;oBAC5B,MAAM;iBACN,CAAC;oBAAE,OAAO;gBAEX,MAAM,KAAK,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,QAAQ,EAAE,QAAQ,CAAC,CAAC;gBAEtD,MAAM,MAAM,GAAG,OAAO,CAAC,wBAAwB,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;gBACvE,IAAI,MAAM,IAAI,IAAI,IAAI,MAAM,CAAC,YAAY,KAAK,KAAK,IAAI,MAAM,CAAC,QAAQ,KAAK,KAAK,EAAE;oBACjF,OAAO,WAAW,CAAC,QAAmB,CAAC,CAAC;iBACxC;gBACD,OAAO,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;aACxC;SACD,CAAC,CAAC;KACH;IAED,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,gBAAgB,CAAC,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,CAAC;;;ACjGtE;;;;;;AAMA,SAAgB,6BAA6B,CAAE,IAAoB,EAAE,IAAY;IAChF,QAAQ,IAAI;QACX;YACC,OAAO,OAAO,IAAI,EAAE,CAAC;QAEtB;YACC,OAAO,GAAG,IAAI,OAAO,CAAC;QAEvB;YACC,OAAO,OAAO,IAAI,OAAO,CAAC;KAC3B;;;AClBF;;;;AAIA,AAAO,MAAM,WAAW,GAA6C;IACpE,KAAK,EAAE;QACN,OAAO,EAAE;YACR,kCAAwB,IAAI;SAC5B;QACD,kBAAkB,EAAE;YACnB,kCAAwB,IAAI;SAC5B;QACD,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;KACD;IAED,KAAK,EAAE;QACN,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;QACD,OAAO,EAAE;YACR,kCAAwB,IAAI;SAC5B;QACD,GAAG,EAAE;YACJ,kCAAwB,IAAI;SAC5B;QACD,MAAM,EAAE;YACP,0CAA4B,IAAI;SAChC;QACD,WAAW,EAAE;YACZ,OAAO,EAAE;gBACR,kCAAwB,IAAI;aAC5B;SACD;QACD,KAAK,EAAE;YACN,0CAA4B,IAAI;SAChC;KACD;IAED,IAAI,EAAE;QACL,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;QACD,OAAO,EAAE;YACR,kCAAwB,IAAI;SAC5B;QACD,GAAG,EAAE;YACJ,kCAAwB,IAAI;SAC5B;QACD,MAAM,EAAE;YACP,0CAA4B,IAAI;SAChC;QACD,aAAa,EAAE;YACd,0CAA4B,IAAI;SAChC;QACD,WAAW,EAAE;YACZ,OAAO,EAAE;gBACR,kCAAwB,IAAI;aAC5B;SACD;QACD,KAAK,EAAE;YACN,0CAA4B,IAAI;SAChC;KACD;IAED,KAAK,EAAE;QACN,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;KACD;IACD,GAAG,EAAE;QACJ,MAAM,EAAE;YACP,kCAAwB,IAAI;SAC5B;QACD,aAAa,EAAE;YACd,kCAAwB,IAAI;SAC5B;QACD,OAAO,EAAE;YACR,kCAAwB,IAAI;SAC5B;QACD,QAAQ,EAAE;YACT,kCAAwB,IAAI;SAC5B;QACD,QAAQ,EAAE;YACT,kCAAwB,IAAI;SAC5B;QACD,UAAU,EAAE;YACX,kCAAwB,IAAI;SAC5B;QACD,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;QACD,SAAS,EAAE;YACV,kCAAwB,IAAI;SAC5B;QACD,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;QACD,SAAS,EAAE;YACV,kCAAwB,IAAI;SAC5B;QACD,UAAU,EAAE;YACX,kCAAwB,IAAI;SAC5B;QACD,UAAU,EAAE;YACX,kCAAwB,IAAI;SAC5B;QACD,UAAU,EAAE;YACX,kCAAwB,IAAI;SAC5B;QACD,UAAU,EAAE;YACX,kCAAwB,IAAI;SAC5B;QACD,OAAO,EAAE;YACR,kCAAwB,IAAI;SAC5B;QACD,QAAQ,EAAE;YACT,0CAA4B,IAAI;SAChC;KACD;IACD,GAAG,EAAE;QACJ,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;QACD,gBAAgB,EAAE;YACjB,kCAAwB,IAAI;SAC5B;QACD,OAAO,EAAE;YACR,kCAAwB,IAAI;SAC5B;QACD,MAAM,EAAE;YACP,0CAA4B,IAAI;SAChC;KACD;IACD,GAAG,EAAE;QACJ,YAAY,EAAE;YACb,kCAAwB,IAAI;SAC5B;QACD,mBAAmB,EAAE;YACpB,kCAAwB,IAAI;SAC5B;QACD,OAAO,EAAE;YACR,kCAAwB,IAAI;SAC5B;QACD,MAAM,EAAE;YACP,0CAA4B,IAAI;SAChC;QACD,SAAS,EAAE;YACV,0CAA4B,IAAI;SAChC;KACD;CACD;;EAAC,FCvJF;;;;AAIA,AAAO,MAAM,oBAAoB,mCAE7B,WAAW,KACd,IAAI,EAAE;QACL,MAAM,EAAE;YACP,kCAAwB,IAAI;SAC5B;KACD,EACD,IAAI,EAAE;QACL,GAAG,EAAE;YACJ,kCAAwB,IAAI;SAC5B;;QAED,0CAA4B,CAAC,GAAG,IAAI,KAAK,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC;KACxF,GACD;;ACLD;;;;;;AAMA,SAAgB,eAAe,CAAiB,IAAa,EAAE,SAAwB;;IAEtF,OAAO,OAAO,IAAI,MAAM,OAAO,SAAS,CAAC,IAAI,OAAO,IAAI,KAAK,UAAU,CAAC;CACxE;;;;;;AAOD,SAAgB,uBAAuB,CAA8B,IAA6C;IACjH,OAAO,OAAO,IAAI,KAAK,UAAU,CAAC;;;CAClC,DClCD;;;;;;;AAOA,SAAgB,kBAAkB,CAA6C,GAAuC,EAAE,SAAwB,EAAE,IAA+B;IAChL,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAgB,CAAC;IAClD,OAAO,SAAS,CAAC,GAAG,EAAE,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;CAC9C;;;;;;;;;AAUD,SAAS,SAAS,CAA6C,GAAgF,EAAE,cAA6B,EAAE,IAA+B,EAAE,KAAkB;IAClO,MAAM,CAAC,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,KAAK,CAAC;IAC9B,IAAI,IAAI,IAAI,IAAI;QAAE,OAAO,KAAK,CAAC;IAE/B,MAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;;IAG3B,IAAI,QAAQ,IAAI,IAAI;QAAE,OAAO,KAAK,CAAC;IAEnC,IAAI,eAAe,CAAgB,QAAQ,EAAE,cAAc,CAAC,EAAE;QAC7D,OAAO,mBAAmB,CAAC,QAAQ,EAAE,cAAc,EAAE,IAAI,CAAC,CAAC;KAC3D;SAEI;QACJ,MAAM,YAAY,GAAI,QAA4D,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC9F,IAAI,YAAY,IAAI,IAAI,EAAE;YACzB,OAAO,mBAAmB,CAAC,YAAY,EAAE,cAAc,EAAE,IAAI,CAAC,CAAC;SAC/D;aAEI;YACJ,OAAO,SAAS,CAAC,QAAuF,EAAE,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;SACtI;KACD;CACD;;;;;;;;AASD,SAAS,mBAAmB,CAAmC,aAA2C,EAAE,cAA6B,EAAE,IAA+B;;IAEzK,IAAI,uBAAuB,CAAC,aAAa,CAAC,EAAE;QAC3C,MAAM,QAAQ,GAAG,IAA2E,CAAC;QAC7F,OAAO,aAAa,CAAC,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK,cAAc,CAAC;KAC9D;;SAGI;QACJ,OAAO,aAAa,KAAK,cAAc,CAAC;KACxC;;;CACD,DC7DD;;;;;AAKA,SAAgB,kBAAkB,CAAE,IAAoD;IACvF,OAAO,kBAAkB,CAAC,oBAAoB,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;;;ACR7D;;;AAGA,MAAa,eAAgB,SAAQ,KAAK;IAMzC,YAAa,EAAC,IAAI,EAAE,OAAO,EAA0B;QACpD,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,KAAK,CAAC,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QAChD,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KACjB;;;CACD,DCbD;;;AAGA,MAAa,WAAY,SAAQ,eAAe;IAO/C,YAAa,EAAC,SAAS,EAAE,IAAI,EAAE,OAAO,EAAsB;QAC3D,KAAK,CAAC,EAAC,IAAI,EAAE,OAAO,EAAE,IAAI,SAAS,MAAM,OAAO,EAAE,EAAC,CAAC,CAAC;QACrD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;KAC3B;;;CACD,DCfD;;;AAGA,MAAa,qBAAsB,SAAQ,WAAW;IAQrD,YAAa,EAAC,SAAS,EAAE,IAAI,EAAE,OAAO,GAAG,mBAAmB,SAAS,2DAA2D,EAAgC;QAC/J,KAAK,CAAC,EAAC,SAAS,EAAE,eAAe,EAAE,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QAEnD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;KAC3B;;;ACbF;;;;AAIA,AAAO,MAAM,MAAM,GAAsE;IACxF,EAAE,EAAE;QACH,QAAQ,EAAE;YACT,kCAAwB,MAAM;SAC9B;QACD,YAAY,EAAE;YACb,kCAAwB,MAAM;SAC9B;QACD,OAAO,EAAE;YACR,kCAAwB,MAAM;SAC9B;QACD,WAAW,EAAE;YACZ,kCAAwB,MAAM;SAC9B;QACD,IAAI,EAAE;YACL,kCAAwB,MAAM;SAC9B;QACD,QAAQ,EAAE;YACT,kCAAwB,MAAM;SAC9B;QACD,MAAM,EAAE;YACP,kCAAwB,MAAM;SAC9B;QACD,UAAU,EAAE;YACX,kCAAwB,MAAM;SAC9B;QACD,MAAM,EAAE;YACP,kCAAwB,MAAM;SAC9B;QACD,UAAU,EAAE;YACX,kCAAwB,MAAM;SAC9B;QACD,KAAK,EAAE;YACN,kCAAwB,MAAM;SAC9B;QACD,SAAS,EAAE;YACV,kCAAwB,MAAM;SAC9B;QACD,gBAAgB,EAAE;YACjB,kCAAwB,MAAM;SAC9B;QACD,IAAI,EAAE;YACL,kCAAwB,MAAM;SAC9B;QACD,QAAQ,EAAE;YACT,kCAAwB,MAAM;SAC9B;QACD,KAAK,EAAE;YACN,kCAAwB,MAAM;SAC9B;QACD,SAAS,EAAE;YACV,kCAAwB,MAAM;SAC9B;QACD,WAAW,EAAE;YACZ,kCAAwB,MAAM;SAC9B;QACD,QAAQ,EAAE;YACT,kCAAwB,MAAM;SAC9B;QACD,YAAY,EAAE;YACb,kCAAwB,MAAM;SAC9B;QACD,KAAK,EAAE;YACN,kCAAwB,MAAM;SAC9B;QACD,SAAS,EAAE;YACV,kCAAwB,MAAM;SAC9B;QACD,iBAAiB,EAAE;YAClB,kCAAwB,OAAO;SAC/B;QACD,QAAQ,EAAE;YACT,kCAAwB,OAAO;SAC/B;QACD,YAAY,EAAE;YACb,kCAAwB,OAAO;SAC/B;QACD,MAAM,EAAE;YACP,kCAAwB,OAAO;SAC/B;QACD,UAAU,EAAE;YACX,kCAAwB,OAAO;SAC/B;QACD,KAAK,EAAE;YACN,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,OAAO,EAAE;YACR,kCAAwB,OAAO;SAC/B;QACD,WAAW,EAAE;YACZ,kCAAwB,OAAO;SAC/B;QACD,QAAQ,EAAE;YACT,kCAAwB,OAAO;SAC/B;QACD,YAAY,EAAE;YACb,kCAAwB,OAAO;SAC/B;QACD,MAAM,EAAE;YACP,kCAAwB,OAAO;SAC/B;QACD,UAAU,EAAE;YACX,kCAAwB,OAAO;SAC/B;QACD,UAAU,EAAE;YACX,kCAAwB,OAAO;SAC/B;QACD,cAAc,EAAE;YACf,kCAAwB,OAAO;SAC/B;QACD,KAAK,EAAE;YACN,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,aAAa,EAAE;YACd,kCAAwB,OAAO;SAC/B;QACD,KAAK,EAAE;YACN,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,KAAK,EAAE;YACN,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,KAAK,EAAE;YACN,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,MAAM,EAAE;YACP,kCAAwB,OAAO;SAC/B;QACD,UAAU,EAAE;YACX,kCAAwB,OAAO;SAC/B;QACD,OAAO,EAAE;YACR,kCAAwB,OAAO;SAC/B;QACD,WAAW,EAAE;YACZ,kCAAwB,OAAO;SAC/B;QACD,IAAI,EAAE;YACL,kCAAwB,OAAO;SAC/B;QACD,QAAQ,EAAE;YACT,kCAAwB,OAAO;SAC/B;QACD,OAAO,EAAE;YACR,kCAAwB,OAAO;SAC/B;QACD,IAAI,EAAE;YACL,kCAAwB,OAAO;SAC/B;QACD,QAAQ,EAAE;YACT,kCAAwB,OAAO;SAC/B;QACD,MAAM,EAAE;YACP,kCAAwB,OAAO;SAC/B;QACD,UAAU,EAAE;YACX,kCAAwB,OAAO;SAC/B;QACD,MAAM,EAAE;YACP,kCAAwB,OAAO;SAC/B;QACD,UAAU,EAAE;YACX,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,aAAa,EAAE;YACd,kCAAwB,OAAO;SAC/B;QACD,KAAK,EAAE;YACN,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,SAAS,EAAE;YACV,kCAAwB,OAAO;SAC/B;QACD,aAAa,EAAE;YACd,kCAAwB,OAAO;SAC/B;QACD,MAAM,EAAE;YACP,kCAAwB,OAAO;SAC/B;QACD,UAAU,EAAE;YACX,kCAAwB,OAAO;SAC/B;KACD;CACD;;EAAC,FCnNF;;;;;AAKA,SAAgB,QAAQ,CAAE,IAAoD;IAC7E,OAAO,kBAAkB,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;;;CAChD,DCRD;;;AAGA,MAAa,OAAQ,SAAQ,WAAW;IAOvC,YAAa,EAAC,IAAI,EAAE,IAAI,EAAE,OAAO,GAAG,GAAG,IAAI,4CAA4C,EAAkB;QACxG,KAAK,CAAC,EAAC,SAAS,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QACxC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KACjB;;;CACD,DCbD;;;;;AAKA,SAAgB,SAAS,CAAE,IAAoD;IAC9E,OAAO,kBAAkB,CAAC,MAAM,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;;;CACjD,DCPD;;;;;AAKA,SAAgB,kBAAkB,CAAE,IAAoD;IACvF,OAAO,kBAAkB,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;;;CACnD,DCTD;;;AAGA,MAAa,YAAa,SAAQ,WAAW;IAO5C,YAAa,EAAC,SAAS,EAAE,IAAI,EAAE,OAAO,GAAG,mBAAmB,SAAS,sEAAsE,EAAuB;QACjK,KAAK,CAAC,EAAC,SAAS,EAAE,eAAe,EAAE,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QAEnD,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;KAC3B;;;ACZF;;;;AAIA,AAAO,MAAM,WAAW,GAA2E;IAClG,OAAO,EAAE;QACR,IAAI,EAAE;YACL,kCAAwB,MAAM;SAC9B;KACD;;IAED,aAAa,EAAE;QACd,kCAAwB,YAAY;KACpC;IACD,OAAO,EAAE;QACR,IAAI,EAAE;YACL,kCAAwB,YAAY;SACpC;QACD,MAAM,EAAE;YACP,8BAAsB,YAAY;SAClC;QACD,MAAM,EAAE;YACP,0CAA4B,YAAY;SACxC;QACD,OAAO,EAAE;YACR,8BAAsB,YAAY;SAClC;KAED;CACD;;EAAC,FC7BF;;;;;AAKA,SAAgB,sBAAsB,CAAE,IAAoD;IAC3F,OAAO,kBAAkB,CAAC,WAAW,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;;;CACrD,DCRD;;;AAGA,MAAa,YAAa,SAAQ,WAAW;IAO5C,YAAa,EAAC,IAAI,EAAE,IAAI,EAAE,OAAO,GAAG,GAAG,IAAI,4CAA4C,EAAuB;QAC7G,KAAK,CAAC,EAAC,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QAC7C,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KACjB;;;CACD,DCbD;;;;;AAKA,SAAgB,4BAA4B,CAAE,IAAoD;IACjG,OAAO,kBAAkB,CAAC,WAAW,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;;;ACP5D;;;;AAIA,AAAO,MAAM,WAAW,GAA6C;IACpE,OAAO,EAAE;QACR,kCAAwB,IAAI;KAC5B;CACD;;EAAC,FCPF;;;;;AAKA,SAAgB,kBAAkB,CAAE,IAAoD;IACvF,OAAO,kBAAkB,CAAC,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;;;CACnD,DCKD;;;;;;AAOA,SAAgB,0BAA0B,CAAE,EAAC,MAAM,EAAE,GAAG,EAAE,cAAc,EAAqC;IAE5G,MAAM,IAAI,GAAG,CAAC,IAAiC;QAE9C,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;YAChD,OAAO,KAAK,CAAC;SACb;QAED,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,IAAI,IAAI,QAAQ,CAAC,IAAI,CAAC,EAAE;YACtC,MAAM,IAAI,OAAO,CAAC,EAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,EAAC,CAAC,CAAC;SAC1D;QAED,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,IAAI,SAAS,CAAC,IAAI,CAAC,EAAE;YACxC,MAAM,IAAI,OAAO,CAAC,EAAC,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE,EAAC,CAAC,CAAC;SAC3D;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,IAAI,sBAAsB,CAAC,IAAI,CAAC,EAAE;YACzD,MAAM,IAAI,YAAY,CAAC,EAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,cAAc,EAAE,EAAC,CAAC,CAAC;SAC/D;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,IAAI,4BAA4B,CAAC,IAAI,CAAC,EAAE;YAC/D,MAAM,IAAI,YAAY,CAAC,EAAC,IAAI,EAAE,YAAY,EAAE,IAAI,EAAE,cAAc,EAAE,EAAC,CAAC,CAAC;SACrE;QAED,IAAI,CAAC,MAAM,CAAC,OAAO,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;YAChD,MAAM,IAAI,YAAY,CAAC,EAAC,SAAS,EAAE,6BAA6B,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,cAAc,EAAE,EAAC,CAAC,CAAC;SACjH;QAED,IAAI,MAAM,CAAC,aAAa,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;YACrD,MAAM,IAAI,qBAAqB,CAAC,EAAC,SAAS,EAAE,6BAA6B,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,cAAc,EAAE,EAAC,CAAC,CAAC;SAC1H;QAED,OAAO,IAAI,CAAC;KACZ,CAAC;IAEF,MAAM,WAAW,GAAG,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,yBAAyB,CAAC,GAAG,CAAC,CAAC,CAAC;IAC1E,MAAM,iBAAiB,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,WAAW;SACxD,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,KAAK,EAAE,OAAO,IAAI,UAAU,CAAC,CAAC;SACrD,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,UAAU,CAAC,MAAM,EAAC,CAAC,IAAI,GAAG,UAAU,EAAC,CAAC,CAAC,CACpD,CAAC;IAEF,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,GAAG,WAAW;SAC7C,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,KAAK,OAAO,IAAI,UAAU,CAAC;SAClD,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,UAAU,CAAC,MAAM;QAC7B,CAAC,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,IAAI,KAAK,CAAC,UAAU,CAAC,KAAoB,EAAE;;;;;;;;YAStE,KAAK,CAAE,MAAmB,EAAE,OAAgB,EAAE,WAAsB,EAAE;gBACrE,MAAM,CAAC,UAAU,CAAC,GAAG,QAAoB,CAAC;gBAE1C,OAAO,iBAAiB,CAAC;oBACxB,MAAM;oBACN,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,OAAO,EAAE,QAAQ,CAAC;oBAC9C,KAAK,EAAE,UAAU;oBACjB,IAAI;iBACJ,CAAC,CAAC;aACH;SACD,CAAC;cACA,iBAAiB,CAAC;gBACnB,MAAM;gBACN,IAAI,EAAE,UAAU,CAAC,KAAe;gBAChC,KAAK,EAAE,IAAI;gBACX,IAAI;aACJ,CAAC;KACH,CAAC,CAAC,CAAC,CAAC;IAEN,OAAO,MAAM,CAAC,gBAAgB,CAAC,MAAM,oBACjC,iBAAiB,EACnB,CAAC;;;CACH,DCjGM,MAAM,YAAY,GAAG;IAC3B,MAAM,IAAI,GAAiB;QAC1B,QAAQ;QACR,GAAG;QACH,SAAS;QACT,KAAK;QACL,UAAU;QACV,QAAQ;QACR,SAAS;QACT,kBAAkB;QAClB,SAAS;QACT,kBAAkB;QAClB,KAAK;QACL,OAAO;QACP,IAAI;QACJ,KAAK;QACL,SAAS;QACT,MAAM;QACN,MAAM;QACN,UAAU;QACV,cAAc;QACd,MAAM;QACN,MAAM;QACN,WAAW;QACX,SAAS;QACT,QAAQ;QACR,IAAI;QACJ,IAAI;QACJ,MAAM;QACN,QAAQ;QACR,IAAI;QACJ,QAAQ;KACR,CAAC;IAEF,IAAI;QACH,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;KACrB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;KACvB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;KACvB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;KACvB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;KACf;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;KACf;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;KAC7B;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;KAC3C;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;KAC/B;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;KAC/B;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KACjB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;KAC3B;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;KAC7B;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;KAC7B;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;KACjC;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;KACjC;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;KAC/B;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KACzB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KACzB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;KACvB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACnB;IAAC,WAAM;KACP;IAED,IAAI;QACH,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;KACrB;IAAC,WAAM;KACP;IAED,OAAO,IAAI,CAAC;CACZ;;EAAC,OC3Ic,gBAAgB,CAAwD,CAAI,EAAE,CAAK,EAAE,CAAK;IACzG,MAAM,MAAM,GAAG,EAAe,CAAC;IAC/B,MAAM,WAAW,GAAG,CAAC,IAAI,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC;IACvC,MAAM,WAAW,GAAG,CAAC,IAAI,IAAI,GAAG,EAAE,GAAG,CAAC,CAAC;IACvC,CAAC,CAAC,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC,OAAO,CAAC,IAAI,IAAI,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE,MAAM,CAAC,yBAAyB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACvH,OAAO,MAAM,CAAC;;;ACTf;;;;;;AAMA,SAAgB,QAAQ,CAA0C,CAAI,EAAE,CAAI;IAC3E,MAAM,IAAI,GAAG,EAAyB,CAAC;IACvC,MAAM,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI;QAC1C,IAAI,EAAE,IAAI,IAAI,CAAC,CAAC,EAAE;YACjB,MAAM,CAAC,cAAc,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,CAAC,wBAAwB,CAAC,CAAC,EAAE,IAAI,CAAE,CAAC,CAAC;SAC7E;KACD,CAAC,CAAC;IACH,OAAO,IAAI,CAAC;;;CACZ,DCbM,MAAM,YAAY,GAAG;IAC3B,MAAM,WAAW,GAAG,YAAY,EAAE,CAAC;IACnC,MAAM,MAAM,GAAG,gBAAgB,CAC9B,QAAQ,CAAC,MAAM,EAAE,WAAW,CAAC,EAC7B,WAAW,EACX;QACC,OAAO;QACP,SAAS,EAAE,CAAC,QAAgB,KAAK,OAAO,CAAC,QAAQ,CAAC;QAClD,UAAU,EAAE,CAAC,QAAgB,KAAK,QAAQ;KAC1C,CACD,CAAC;IAEF,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;QAC/B,MAAM,EAAE;YACP,GAAG;gBACF,OAAO,MAAM,CAAC;aACd;SACD;QACD,UAAU,EAAE;YACX,GAAG;gBACF,OAAO,MAAM,CAAC;aACd;SACD;KACD,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;CACd;;EAAC,EC/BU,qBAKX;AALD,WAAY,qBAAqB;IAChC,sCAAa,CAAA;IACb,sCAAa,CAAA;IACb,4CAAmB,CAAA;IACnB,sCAAa,CAAA;CACb,EALW,qBAAqB,KAArB,qBAAqB;;ACKjC;;;;AAIA,SAAgB,iBAAiB,CAAE,MAAqB;IACvD,IAAI,QAAQ,GAAG,CAAC,CAAC;IAEjB,MAAM,sBAAsB,GAAG,SAAS,qBAAqB,CAAE,QAA8B;QAE5F,MAAM,QAAQ,GAAG,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;QAEtC,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,IAAI,QAAQ,GAAG,QAAQ,CAAC,CAAC,CAAC;QAE3D,MAAM,EAAE,GAAG,MAAM,CAAC,UAAU,CAAC;YAC5B,QAAQ,CAAC,QAAQ,GAAG,UAAU,CAAC,CAAC;SAChC,EAAE,UAAU,CAAC,CAAC;QAEf,QAAQ,GAAG,QAAQ,GAAG,UAAU,CAAC;QAEjC,OAAO,EAAE,CAAC;KAEV,CAAC;IAEF,MAAM,qBAAqB,GAAG,SAAS,oBAAoB,CAAE,EAAU;QACtE,YAAY,CAAC,EAAE,CAAC,CAAC;KACjB,CAAC;IAEF,OAAO;QACN,qBAAqB,EAAE,sBAAsB;QAC7C,oBAAoB,EAAE,qBAAqB;KAC3C,CAAC;;;CAEF,DC/BM,MAAM,eAAe,GAAG;IAC9B,MAAM,EAAC,MAAM,EAAC,GAAG,IAAI,KAAK,CAAC,EAAE,EAAE,EAAC,GAAG,EAAE,qBAAqB,EAAC,CAAC,CAAC;IAC7D,MAAM,WAAW,GAAG,YAAY,EAAE,CAAC;IACnC,MAAM,GAAG,GAAG,iBAAiB,CAAC,MAA+C,CAAC,CAAC;IAC/E,MAAM,MAAM,GAAG,gBAAgB,CAC9B,QAAQ,CAAC,MAAM,EAAE,WAAiC,CAAC,EACnD,QAAQ,CAAC,GAAG,EAAE,MAAM,CAAC,EACrB,WAAW,CACX,CAAC;IAEF,MAAM,CAAC,gBAAgB,CAAC,MAAM,EAAE;QAC/B,MAAM,EAAE;YACP,GAAG;gBACF,OAAO,MAAM,CAAC;aACd;SACD;QACD,UAAU,EAAE;YACX,GAAG;gBACF,OAAO,MAAM,CAAC;aACd;SACD;KACD,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC;CACd;;EAAC,FC9BK,MAAM,aAAa,GAAG,UAAU;;iCAAC,jCCAjC,MAAM,YAAY,GAAG,SAAS;;+BAAC,/BCA/B,MAAM,eAAe,GAAG,YAAY;;qCAAC,rCCArC,MAAM,WAAW,GAAG,MAAM;;2BAAC,3BCA3B,MAAM,YAAY,GAAG,OAAO;;6BAAC,7BCuBpC;;;;;;AAMA,SAAgB,qCAAqC,CAAE,GAAuB,EAAE,IAAY;IAC3F,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC;QAAE,OAAO,GAAG,CAAC,GAAG,CAAC;IAC/C,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI;QAAE,OAAO,qCAAqC,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC7F,OAAO,SAAS,CAAC;CACjB;;;;;;AAOD,SAAgB,8BAA8B,CAAE,GAAuB;IACtE,IAAI,GAAG,CAAC,MAAM,IAAI,IAAI;QAAE,OAAO,GAAG,CAAC,MAAM,CAAC;SACrC,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI;QAAE,OAAO,8BAA8B,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;;QAChF,OAAO,qBAAqB,CAAC,IAAI,CAAC;CACvC;;;;;;;;AASD,SAAgB,yBAAyB,CAAE,IAAoB,EAAE,GAAuB,EAAE,IAAY;IACrG,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE;QAC/B,MAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACnC,QAAQ,IAAI;;YAEX,KAAK,WAAW,CAAC;YACjB,KAAK,YAAY;gBAChB,MAAM,MAAM,GAAG,8BAA8B,CAAC,GAAG,CAAC,CAAC;gBACnD,OAAO,MAAM,KAAK,qBAAqB,CAAC,IAAI,IAAI,OAAO,OAAO,KAAK,UAAU,IAAI,IAAI,IAAI,IAAI;sBAC1F,EAAC,OAAO,EAAE,OAAO,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,QAAQ,CAAC,EAAC;sBACjD,EAAC,OAAO,EAAC,CAAC;YACd;gBACC,OAAO,EAAC,OAAO,EAAC,CAAC;SAClB;KACD;IAED,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI;QAAE,OAAO,yBAAyB,CAAC,IAAI,EAAE,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACvF,OAAO,SAAS,CAAC;CACjB;;;;;;;;;AAUD,SAAgB,8BAA8B,CAAE,IAAU,EAAE,GAAuB,EAAE,MAAe,EAAE,GAAG,UAAoB;IAC5H,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI;QAC1B,MAAM,KAAK,GAAG,yBAAyB,CAAC,IAAI,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QACzD,OAAO,KAAK,IAAI,IAAI,GAAG,KAAK,GAAG,KAAK,CAAC,OAAO,KAAK,MAAM,CAAC;KACxD,CAAC,CAAC;CACH;;;;;;AAOD,SAAgB,gBAAgB,CAAE,KAAc;IAC/C,QAAQ,KAAK;QACZ,KAAK,aAAa,CAAC;QACnB,KAAK,YAAY,CAAC;QAClB,KAAK,eAAe,CAAC;QACrB,KAAK,WAAW,CAAC;QACjB,KAAK,YAAY;YAChB,OAAO,IAAI,CAAC;QACb;YACC,OAAO,KAAK,CAAC;KACd;CACD;;;;;;AAOD,SAAgB,uBAAuB,CAAE,EAAC,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAE,IAAI,EAAE,UAAU,GAAG,KAAK,EAAkC;IAChI,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC,IAAI,UAAU,IAAI,GAAG,CAAC,SAAS,IAAI,IAAI,EAAE;;QAEtE,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,KAAK;YAAE,OAAO;;QAG/D,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;;QAG1B,IAAI,SAAS,CAAC,cAAc,IAAI,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;YAChE,SAAS,CAAC,cAAc,CAAC,EAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;SAC9C;KACD;SAEI;QACJ,IAAI,gBAAgB,GAAiC,GAAG,CAAC,SAAS,CAAC;QACnE,OAAO,gBAAgB,IAAI,IAAI,EAAE;YAChC,IAAI,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE;;gBAE5C,IAAI,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK,KAAK;oBAAE,OAAO;;gBAGzF,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;;gBAGvC,IAAI,SAAS,CAAC,cAAc,IAAI,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE;oBAChE,SAAS,CAAC,cAAc,CAAC,EAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;iBAC9C;gBACD,OAAO;aACP;iBACI;gBACJ,gBAAgB,GAAG,gBAAgB,CAAC,SAAS,CAAC;aAC9C;SACD;KACD;CACD;;;;;;AAOD,SAAgB,kCAAkC,CAAE,GAAuB,EAAE,IAAY;IACxF,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IACvC,IAAI,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE;QAC/B,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;KACnB;SAEI;QACJ,IAAI,gBAAgB,GAAiC,GAAG,CAAC,SAAS,CAAC;QACnE,OAAO,gBAAgB,IAAI,IAAI,EAAE;YAChC,IAAI,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE;gBAC5C,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;gBAChC,OAAO;aACP;iBACI;gBACJ,gBAAgB,GAAG,gBAAgB,CAAC,SAAS,CAAC;aAC9C;SACD;KACD;CACD;;;;;;AAOD,SAAgB,wBAAwB,CAAE,EAAC,gBAAgB,EAAE,EAAC,KAAK,EAAE,MAAM,EAAC,EAAE,MAAM,EAAE,cAAc,EAAmC;IAEtI,IAAI,QAAsB,CAAC;IAE3B,QAAQ,MAAM;QACb,KAAK,qBAAqB,CAAC,IAAI;YAC9B,QAAQ,GAAG,gBAAgB,CAAC,KAAK,CAAC,CAAC;YACnC,MAAM;QAEP,KAAK,qBAAqB,CAAC,IAAI;YAC9B,QAAQ,GAAG,gBAAgB,CAAC,YAAY,EAAE,EAAE,KAAK,CAAC,CAAC;YACnD,MAAM;QAEP,KAAK,qBAAqB,CAAC,IAAI;YAC9B,QAAQ,GAAG,gBAAgB,CAAC,YAAY,EAAE,EAAE,KAAK,CAAC,CAAC;YACnD,MAAM;QAEP,KAAK,qBAAqB,CAAC,OAAO;YACjC,QAAQ,GAAG,gBAAgB,CAAC,eAAe,EAAE,EAAE,KAAK,CAAC,CAAC;YACtD,MAAM;QAEP;YACC,QAAQ,GAAG,EAAE,CAAC;YACd,MAAM;KACP;IAED,OAAO;QACN,MAAM;QACN,SAAS,EAAE,SAAS;QACpB,GAAG,EAAE,0BAA0B,CAAC;YAC/B,MAAM;YACN,GAAG,EAAE,QAAQ;YACb,cAAc;SACd,CAAC;KACF,CAAC;;;CACF,DCtND;;;;;AAKA,SAAgB,gBAAgB,CAAE,IAA0B;IAC3D,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,WAAW,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,YAAY,CAAC;;;CACrF,DCPD;;;;;AAKA,SAAgB,aAAa,CAAE,IAAU;IACxC,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,WAAW,CAAC;;;CAC5C,DCJD;;;;;;AAMA,SAAgB,qBAAqB,CAAE,IAAU;IAChD,IAAI,mBAAmB,CAAC,IAAI,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,EAAC,CAAC;SACnE,IAAI,gBAAgB,CAAC,IAAI,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,WAAW,EAAC,CAAC;SAChG,IAAI,0BAA0B,CAAC,IAAI,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,QAAQ,CAAC,UAAU,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,EAAC,CAAC;SAC3G,IAAI,gBAAgB,CAAC,IAAI,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAC,CAAC;SAC7E,IAAI,eAAe,CAAC,IAAI,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,EAAC,CAAC;SAC5E,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,UAAU;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAC,CAAC;SAC5F,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,KAAK;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAC,CAAC;SAClF,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,MAAM;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC;SACpF,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,KAAK,WAAW;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,SAAS,EAAC,CAAC;SAC9F,IAAI,aAAa,CAAC,IAAI,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC;;QAC7D,OAAO,EAAC,OAAO,EAAE,KAAK,EAAC,CAAC;;;CAC7B,DCpBD;;;AAGA,MAAa,mBAAoB,SAAQ,WAAW;IAMnD,YAAa,EAAC,GAAG,EAAE,IAAI,EAAE,OAAO,GAAG,yBAAyB,GAAG,EAAE,EAA8B;QAC9F,KAAK,CAAC,EAAC,SAAS,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QAC5C,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;KACf;;;CACD,DCXD;;;;;AAKA,SAAgB,2BAA2B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,uBAAuB,EAAyC,EAAE,WAAqB;IAExK,MAAM,iBAAiB,GAAG,WAAW,IAAI,IAAI,GAAG,WAAW,GAAG,IAAI,CAAC,WAAW,IAAI,IAAI;;UAEnF,SAAS;UACT,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;IAG/E,IAAI,iBAAiB,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;QAC1D,MAAM,IAAI,eAAe,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;KAClC;;IAGD,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,iBAAiB,EAAE,uBAAuB,CAAC,CAAC;IAC9F,KAAK,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;;;CAC9B,DCvBD;;;;;AAKA,SAAgB,gBAAgB,CAAE,IAAU;IAC3C,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,WAAW,CAAC;;;CAC5C,DCPD;;;;;AAKA,SAAgB,iBAAiB,CAAE,IAAU;IAC5C,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,YAAY,CAAC;;;CAC7C,DCFD;;;;;;AAMA,SAAgB,kBAAkB,CAAkB,EAA+C;QAA/C,EAAC,IAAI,EAAE,QAAQ,OAAgC,EAA9B,uCAAO;IAC3E,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QACvB,OAAO,IAAI,CAAC,IAAI,CAAC;KACjB;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,WAAW,CAAC;KACnB;SAEI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,YAAY,CAAC;KACpB;SAEI,IAAI,yBAAyB,CAAC,IAAI,CAAC,EAAE;QACzC,OAAO,kBAAkB,iBAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,IAAK,IAAI,EAAE,CAAC;KACtE;SACI,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,kBAAkB,iBAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,IAAK,IAAI,EAAE,CAAC;KACtE;SAEI,IAAI,0BAA0B,CAAC,IAAI,CAAC,EAAE;QAC1C,IAAI,QAAQ,GAAG,kBAAkB,iBAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,IAAK,IAAI,EAAE,CAAC;QAC9E,IAAI,QAAQ,IAAI,IAAI;YAAE,QAAQ,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAW,CAAC;QAClI,IAAI,SAAS,GAAG,kBAAkB,iBAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,QAAQ,IAAK,IAAI,EAAE,CAAC;QACzE,IAAI,SAAS,IAAI,IAAI;YAAE,SAAS,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAW,CAAC;QAE9H,IAAI,QAAQ,IAAI,IAAI,IAAI,SAAS,IAAI,IAAI;YAAE,OAAO,SAAS,CAAC;QAC5D,OAAO,GAAG,QAAQ,IAAI,SAAS,EAAE,CAAC;KAClC;SAEI,IAAI,yBAAyB,CAAC,IAAI,CAAC,EAAE;QACzC,IAAI,QAAQ,GAAG,kBAAkB,iBAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAE,QAAQ,IAAK,IAAI,EAAE,CAAC;QAC9E,IAAI,QAAQ,IAAI,IAAI;YAAE,QAAQ,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAW,CAAC;QAClI,MAAM,SAAS,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,uBAAuB,CAAC,CAAW,CAAC;QAE3H,IAAI,QAAQ,IAAI,IAAI,IAAI,SAAS,IAAI,IAAI;YAAE,OAAO,SAAS,CAAC;QAC5D,OAAO,GAAG,QAAQ,IAAI,SAAS,EAAE,CAAC;KAClC;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;YAAE,OAAO,SAAS,CAAC;QACxC,OAAO,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;KACtB;IAED,OAAO,SAAS,CAAC;;;CACjB,DCtDD;;;AAGA,MAAa,mBAAoB,SAAQ,eAAe;IAEvD,YAAa,EAAC,IAAI,EAAE,OAAO,GAAG,qBAAqB,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAA8B;QACxG,KAAK,CAAC,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;KACvB;;;CACD,DCTD;;;AAGA,MAAa,uBAAwB,SAAQ,eAAe;IAE3D,YAAa,EAAC,IAAI,EAAE,OAAO,GAAG,oCAAoC,EAAkC;QACnG,KAAK,CAAC,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;KACvB;;;CACD,DCHD;;;;;;AAOA,SAAgB,wBAAwB,CAAE,EAAuH;QAAvH,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,uBAAuB,EAAE,SAAS,OAA+C,EAA7C,wGAAO;IAC1H,MAAM,SAAS,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAW,CAAC;IACnG,MAAM,UAAU,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAW,CAAC;IACrG,MAAM,cAAc,GAAG,kBAAkB,iBAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,uBAAuB,EAAE,SAAS,IAAK,IAAI,EAAE,CAAC;IAEzI,MAAM,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC;IACzC,QAAQ,QAAQ;QAEf,KAAK,UAAU,CAAC,cAAc,EAAE;YAC/B,OAAO,SAAS,GAAG,UAAU,CAAC;SAC9B;QAED,KAAK,UAAU,CAAC,uBAAuB,EAAE;YACxC,OAAO,SAAS,IAAI,UAAU,CAAC;SAC/B;QAED,KAAK,UAAU,CAAC,oBAAoB,CAAC;QACrC,KAAK,UAAU,CAAC,gBAAgB,CAAC;QACjC,KAAK,UAAU,CAAC,cAAc,CAAC;QAC/B,KAAK,UAAU,CAAC,gBAAgB,CAAC;QACjC,KAAK,UAAU,CAAC,eAAe,CAAC;QAChC,KAAK,UAAU,CAAC,kBAAkB,CAAC;QACnC,KAAK,UAAU,CAAC,gBAAgB,CAAC;QACjC,KAAK,UAAU,CAAC,mBAAmB,CAAC;QACpC,KAAK,UAAU,CAAC,2BAA2B,CAAC;QAC5C,KAAK,UAAU,CAAC,2BAA2B,CAAC;QAC5C,KAAK,UAAU,CAAC,iCAAiC,CAAC;QAClD,KAAK,UAAU,CAAC,4CAA4C,EAAE;;YAG7D,IAAI,aAAa,GAAG,SAAS,CAAC;YAC9B,QAAQ,QAAQ;gBACf,KAAK,UAAU,CAAC,oBAAoB;oBACnC,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;gBACP,KAAK,UAAU,CAAC,gBAAgB;oBAC/B,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;gBACP,KAAK,UAAU,CAAC,cAAc;oBAC7B,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;gBACP,KAAK,UAAU,CAAC,mBAAmB;oBAClC,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;gBACP,KAAK,UAAU,CAAC,2BAA2B;oBAC1C,aAAa,KAAK,UAAU,CAAC;oBAC7B,MAAM;gBACP,KAAK,UAAU,CAAC,2BAA2B;oBAC1C,aAAa,KAAK,UAAU,CAAC;oBAC7B,MAAM;gBACP,KAAK,UAAU,CAAC,iCAAiC;oBAChD,aAAa,KAAK,UAAU,CAAC;oBAC7B,MAAM;gBACP,KAAK,UAAU,CAAC,4CAA4C;oBAC3D,aAAa,MAAM,UAAU,CAAC;oBAC9B,MAAM;gBACP,KAAK,UAAU,CAAC,gBAAgB;oBAC/B,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;gBACP,KAAK,UAAU,CAAC,eAAe;oBAC9B,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;gBACP,KAAK,UAAU,CAAC,kBAAkB;oBACjC,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;gBACP,KAAK,UAAU,CAAC,gBAAgB;oBAC/B,aAAa,IAAI,UAAU,CAAC;oBAC5B,MAAM;aACP;;YAGD,IAAI,cAAc,IAAI,IAAI,EAAE;gBAC3B,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,cAAc,EAAE,KAAK,EAAE,aAAa,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;aACzG;;YAGD,OAAO,aAAa,CAAC;SACrB;QAED,KAAK,UAAU,CAAC,aAAa,EAAE;YAC9B,OAAO,SAAS,GAAG,UAAU,CAAC;SAC9B;QAED,KAAK,UAAU,CAAC,qBAAqB,EAAE;YACtC,OAAO,SAAS,IAAI,UAAU,CAAC;SAC/B;QAED,KAAK,UAAU,CAAC,QAAQ,EAAE;YACzB,OAAO,SAAS,GAAG,UAAU,CAAC;SAC9B;QAED,KAAK,UAAU,CAAC,WAAW,EAAE;YAC5B,OAAO,SAAS,IAAI,UAAU,CAAC;SAC/B;QAED,KAAK,UAAU,CAAC,UAAU,EAAE;YAC3B,OAAO,SAAS,GAAG,UAAU,CAAC;SAC9B;QAED,KAAK,UAAU,CAAC,UAAU,EAAE;YAC3B,OAAO,UAAU,CAAC;SAClB;QAED,KAAK,UAAU,CAAC,UAAU;YACzB,OAAO,SAAS,GAAG,UAAU,CAAC;QAE/B,KAAK,UAAU,CAAC,SAAS;YACxB,MAAM,CAAC,SAAS,CAAC,SAAS,GAAG,UAAU,EAAE,8BAA8B,CAAC,CAAC;YACzE,OAAO,SAAS,GAAG,UAAU,CAAC;QAE/B,KAAK,UAAU,CAAC,YAAY;YAC3B,OAAO,SAAS,GAAG,UAAU,CAAC;QAE/B,KAAK,UAAU,CAAC,UAAU;YACzB,OAAO,SAAS,GAAG,UAAU,CAAC;QAE/B,KAAK,UAAU,CAAC,WAAW,EAAE;;YAE5B,IAAI,cAAc,IAAI,IAAI,EAAE;gBAC3B,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,cAAc,EAAE,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;gBACtG,MAAM,CAAC,UAAU,CAAC,cAAc,EAAE,UAAU,EAAE,YAAY,CAAC,CAAC;aAC5D;iBAEI;gBACJ,MAAM,IAAI,uBAAuB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAC,CAAC,CAAC;aACrD;;YAGD,OAAO,UAAU,CAAC;SAClB;QAED,KAAK,UAAU,CAAC,iBAAiB,EAAE;;YAElC,OAAO,SAAS,IAAI,UAAU,CAAC;;SAE/B;QAED,KAAK,UAAU,CAAC,uBAAuB,EAAE;YACxC,OAAO,SAAS,KAAK,UAAU,CAAC;SAChC;QAED,KAAK,UAAU,CAAC,sBAAsB,EAAE;;YAEvC,OAAO,SAAS,IAAI,UAAU,CAAC;;SAE/B;QAED,KAAK,UAAU,CAAC,4BAA4B,EAAE;YAC7C,OAAO,SAAS,KAAK,UAAU,CAAC;SAChC;QAED,KAAK,UAAU,CAAC,gBAAgB;YAC/B,OAAO,SAAS,GAAG,UAAU,CAAC;QAE/B,KAAK,UAAU,CAAC,sBAAsB;YACrC,OAAO,SAAS,IAAI,UAAU,CAAC;QAEhC,KAAK,UAAU,CAAC,aAAa;YAC5B,OAAO,SAAS,GAAG,UAAU,CAAC;QAE/B,KAAK,UAAU,CAAC,mBAAmB;YAClC,OAAO,SAAS,IAAI,UAAU,CAAC;QAEhC,KAAK,UAAU,CAAC,SAAS,EAAE;YAC1B,OAAO,SAAS,IAAK,UAAgC,CAAC;SACtD;;QAGD,KAAK,UAAU,CAAC,qBAAqB;YACpC,OAAO,SAAS,IAAI,IAAI,GAAG,SAAS,GAAG,UAAU,CAAC;QAEnD,KAAK,UAAU,CAAC,iBAAiB,EAAE;YAClC,OAAO,SAA8B,YAAa,UAAkC,CAAC;SACrF;KACD;;IAGD,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,aAAa,EAAC,CAAC,CAAC;;;AChM3D;AAMA,AAAO,MAAM,cAAc,GAAG,iBAAiB,CAAC;;;;;;AAYhD,SAAgB,UAAU,CAAE,OAAgB;IAC3C,OAAO,OAAO,IAAI,IAAI,IAAI,OAAO,OAAO,KAAK,QAAQ,IAAI,cAAc,IAAI,OAAO,CAAC;CACnF;;;;;;AAgBD,SAAgB,gBAAgB,CAAE,OAAgB;IACjD,IAAI,OAAO,KAAK,SAAS;QAAE,OAAO,WAAW,CAAC;SACzC,IAAI,OAAO,KAAK,IAAI;QAAE,OAAO,MAAM,CAAC;SACpC,IAAI,OAAO,OAAO,KAAK,QAAQ;QAAE,OAAO,IAAI,OAAO,GAAG,CAAC;IAC5D,OAAO,OAAO,CAAC,QAAQ,EAAE,CAAC;;;CAC1B,DCrCD;;;AAGA,MAAa,gBAAiB,SAAQ,eAAe;IAOpD,YAAa,EAAC,KAAK,EAAE,IAAI,EAAE,OAAO,GAAG,GAAG,gBAAgB,CAAC,KAAK,CAAC,qBAAqB,EAA2B;QAC9G,KAAK,CAAC,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QACvB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;KACnB;;;CACD,DCdD;;;;;AAKA,SAAgB,8BAA8B,CAAE,UAAsB;IACrE,IAAI,iBAAiB,CAAC,UAAU,CAAC;QAAE,OAAO,IAAI,CAAC;SAE1C,IAAI,0BAA0B,CAAC,UAAU,CAAC,EAAE;QAChD,OAAO,8BAA8B,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,8BAA8B,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;KAChH;SAEI,IAAI,yBAAyB,CAAC,UAAU,CAAC,EAAE;QAC/C,OAAO,8BAA8B,CAAC,UAAU,CAAC,UAAU,CAAC,IAAI,8BAA8B,CAAC,UAAU,CAAC,kBAAkB,CAAC,CAAC;KAC9H;SAEI,IAAI,yBAAyB,CAAC,UAAU,CAAC;QAAE,OAAO,8BAA8B,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;SACxG,IAAI,cAAc,CAAC,UAAU,CAAC;QAAE,OAAO,8BAA8B,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;SAC7F,IAAI,eAAe,CAAC,UAAU,CAAC;QAAE,OAAO,8BAA8B,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;SAC9F;QACJ,OAAO,KAAK,CAAC;KACb;CACD;;AClBD;;;;;AAKA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAE,MAAM,EAAoC;IAExI,MAAM,aAAa,GAAc,EAAE,CAAC;IAEpC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC/C,aAAa,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;KAChG;;IAGD,MAAM,gBAAgB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAuB,CAAC;IAE5H,IAAI,UAAU,CAAC,gBAAgB,CAAC,EAAE;QACjC,MAAM,kBAAkB,GAAG,8BAA8B,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,WAAW,CAAC,GAAG,SAAS,CAAC;QACnJ,MAAM,KAAK,GAAG,gBAAgB,CAAC,MAAM,CACpC,kBAAkB,IAAI,IAAI;cACvB,kBAAkB,CAAC,OAAO;cAC1B,SAAS,EACZ,GAAG,aAAa,CAChB,CAAC;QACF,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;QAC1C,OAAO,KAAK,CAAC;KACb;;SAGI;;QAEJ,IAAI,IAAI,CAAC,gBAAgB,IAAI,IAAI,IAAI,OAAO,gBAAgB,KAAK,UAAU,EAAE;YAC5E,MAAM,IAAI,gBAAgB,CAAC,EAAC,KAAK,EAAE,gBAAgB,EAAE,IAAI,EAAE,IAAI,CAAC,UAAU,EAAC,CAAC,CAAC;SAC7E;QAED,MAAM,KAAK,GAAG,OAAO,gBAAgB,KAAK,UAAU,GAAG,SAAS,GAAG,gBAAgB,CAAC,GAAG,aAAa,CAAC,CAAC;QACtG,MAAM,CAAC,SAAS,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;QAC1C,OAAO,KAAK,CAAC;KACb;;;AC1CF;;;;;AAKA,SAAgB,+BAA+B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAA6C;IAClJ,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;;ACRnF;;;;;AAKA,SAAgB,uBAAuB,CAAE,WAA+B;IACvE,OAAO;QACN,SAAS,EAAE,WAAW;QACtB,GAAG,EAAE,EAAE;KACP,CAAC;;;ACTH;;;;;;AAMA,SAAgB,WAAW,CAAE,IAAqB,EAAE,QAA0B;IAC7E,MAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,GAAuC,IAAI,CAAC,SAAS,CAAC;IAClG,OAAO,SAAS,IAAI,IAAI,IAAI,SAAS,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAC;;;CACrE,DCLD;;;;;;AAMA,SAAgB,6BAA6B,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAAqD,EAAE,cAAyB,EAAE,OAAsB;;IAE3M,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,IAAI,EAAE,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC;IAEnG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAC3C,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;;QAGhC,IAAI,SAAS,CAAC,cAAc,IAAI,IAAI,EAAE;YACrC,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,uBAAuB,CAAC,CAAC;;YAEpG,MAAM;SACN;aAEI;YACJ,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC,CAAC,EAAE,uBAAuB,CAAC,CAAC;;;YAI9F,IAAI,OAAO,IAAI,IAAI,IAAI,YAAY,CAAC,SAAS,CAAC,IAAI,CAAC,KAClD,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC,aAAa,CAAC;gBAChD,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC,gBAAgB,CAAC;gBACnD,WAAW,CAAC,SAAS,EAAE,UAAU,CAAC,cAAc,CAAC,CACjD,EACC;gBACD,MAAM,KAAK,GAAG,yBAAyB,CAAC,SAAS,EAAE,WAAW,EAAE,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACrF,IAAI,KAAK,IAAI,IAAI,EAAE;oBAClB,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC;iBAC7C;aACD;SACD;KACD;;;CACD,DCnCD;;;;;;AAOA,SAAgB,+BAA+B,CAAE,EAAmH;QAAnH,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,uBAAuB,EAAE,SAAS,OAA4C,EAA1C,uGAAO;IAEhI,MAAM,uBAAuB,GAAG,WAAW,CAAC,IAAI,EAAE,UAAU,CAAC,YAAY,CAAC;UACvE,OAAO,GAAG,IAAe;;YAG1B,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAGhI,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,uBAAuB;gBACvB,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;;YAGF,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACvB,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;gBAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;oBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;iBACnB;;;oBAGI,OAAO,SAAS,CAAC;aACtB;;iBAGI;gBACJ,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,EAAE,uBAAuB,CAAC,CAAC;aACxF;SACD;UACC,CAAC,GAAG,IAAe;;YAGpB,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAGhI,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,uBAAuB;gBACvB,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;;YAGF,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;gBACvB,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;gBAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;oBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;iBACnB;;;oBAGI,OAAO,SAAS,CAAC;aACtB;;iBAGI;gBACJ,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,EAAE,uBAAuB,CAAC,CAAC;aACxF;SACD,CAAC;IAEH,uBAAuB,CAAC,QAAQ,GAAG,MAAM,uBAAuB,CAAC;;;IAIjE,MAAM,CAAC,cAAc,CACpB,uBAAuB,EACvB,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,CAAE,CAAC,OAAmB,CAC7E,CAAC;IAEF,OAAO,uBAAuB,CAAC;;;AC3GhC;;;;;AAKA,SAAgB,qBAAqB,CAAE,EAAC,IAAI,EAAuC;IAClF,OAAO,IAAI,CAAC,IAAI,CAAC;;;ACNlB;;;;;AAKA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAoC;IAChF,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;;CACzB,DCPD;;;;;AAKA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAA2E;IACvH,OAAO,IAAI,CAAC,IAAI,KAAK,UAAU,CAAC,WAAW,CAAC;;;CAC5C,DCND;;;;;AAKA,SAAgB,gCAAgC,CAAE,EAAC,IAAI,EAAE,WAAW,EAA8C;IACjH,MAAM,YAAY,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,CAAE,CAAC,OAA8B,CAAC;IAC9G,QAAQ,IAAI,YAAY,CAAC,UAAU,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE;;;CACnD,DCPD;;;;;AAKA,SAAgB,+BAA+B,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,uBAAuB,EAA6C;;;IAG7J,MAAM,UAAU,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC,OAA4B,CAAC;IACxG,MAAM,KAAK,GAAiB,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;;IAGpE,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;IAEzG,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,UAAU,EAAE;QACvC,QAAQ,CAAC,gBAAgB,CAAC,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAC;KACjF;IAED,OAAO,KAAK,CAAC;;;ACtBd;;;;;AAKA,SAAgB,UAAU,CAAE,IAAa;IACxC,OAAO,IAAI,IAAI,IAAI,IAAK,IAA0B,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC;;;CAC5E,DCHD;;;;;AAKA,SAAgB,8BAA8B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAA4C;;IAEhJ,MAAM,SAAS,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,OAAO,CAAE,CAAC,OAA2B,CAAC;IACrG,MAAM,KAAK,GAAc,SAAS,CAAC,EAAE,EAAE,CAAC;IAExC,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;QACpC,MAAM,SAAS,GAAG,QAAQ,CAAC,UAAU,CAAC,OAAO,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;QACrF,IAAI,eAAe,CAAC,OAAO,CAAC,IAAI,UAAU,CAAC,SAAS,CAAC,EAAE;YACtD,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;SACzB;aAEI;YACJ,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;SACtB;KACD;IAED,OAAO,KAAK,CAAC;;;CACb,DCxBD;;;AAGA,MAAa,wBAAyB,SAAQ,eAAe;IAO5D,YAAa,EAAC,IAAI,EAAE,OAAO,GAAG,IAAI,IAAI,CAAC,IAAI,mBAAmB,EAAmC;QAChG,KAAK,CAAC,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;KACvB;;;CACD,DCfD;;;;;AAKA,SAAgB,gBAAgB,CAAE,eAAwC;IACzE,OAAO,eAAe,CAAC,KAAK,KAAK,SAAS,CAAC,KAAK,IAAI,eAAe,CAAC,KAAK,KAAK,SAAS,CAAC,GAAG,CAAC;;;CAC5F,DCPD;;;;;;AAMA,SAAgB,2BAA2B,CAAkB,IAAU,EAAE,IAAgB;IACxF,IAAI,aAAa,GAAG,IAAI,CAAC;IACzB,OAAO,IAAI,EAAE;QACZ,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC;QACrC,IAAI,aAAa,IAAI,IAAI;YAAE,OAAO,SAAS,CAAC;QAC5C,IAAI,aAAa,CAAC,IAAI,KAAK,IAAI,EAAE;YAChC,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,aAAa,CAAC,CAAC;YAC9D,MAAM,WAAW,IAChB,CAAC,CAAC,iBAAiB,GAAG,SAAS,CAAC,SAAS,MAAM,CAAC;iBAC/C,CAAC,iBAAiB,GAAG,SAAS,CAAC,eAAe,MAAM,CAAC,CAAC,CACvD,CAAC;YACF,IAAI,CAAC,WAAW;gBAAE,OAAU,aAAa,CAAC;SAC1C;QAED,IAAI,YAAY,CAAC,aAAa,CAAC;YAAE,OAAO,SAAS,CAAC;KAClD;;;CACD,DCrBD;;;AAGA,MAAa,mBAAoB,SAAQ,eAAe;IAQvD,YAAa,EAAC,IAAI,EAAE,IAAI,EAAE,OAAO,GAAG,WAAW,IAAI,0BAA0B,EAA8B;QAC1G,KAAK,CAAC,EAAC,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QACvB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;KACjB;;;CACD,DCdD;;;;;AAKA,SAAgB,kBAAkB,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAAiC;IACzH,MAAM,IAAI,GAAG,oBAAoB,CAAC,IAAI,CAAC,CAAC;IACxC,IAAI,IAAI,IAAI,IAAI;QAAE,OAAO,SAAS,CAAC;IAEnC,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QACvB,OAAO,IAAI,CAAC,IAAI,CAAC;KACjB;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,IAAI,CAAC,IAAI,CAAC;KACjB;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACzB;SAEI,IAAI,sBAAsB,CAAC,IAAI,CAAC,EAAE;QACtC,QAAQ,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,EAA2C;KAC7H;SAEI;QACJ,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,EAAC,CAAC,CAAC;KAC5C;;;CAED,DCvBD;;;;;AAKA,SAAgB,oDAAoD,CAAE,OAAuC;IAC5G,MAAM,EAAC,IAAI,EAAC,GAAG,OAAO,CAAC;IACvB,MAAM,IAAI,GAAG,kBAAkB,CAAC,OAAO,CAAC,CAAC;IAEzC,IAAI,IAAI,IAAI,IAAI,EAAE;QACjB,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;KACtC;;IAGD,MAAM,yBAAyB,GAAG,yBAAyB,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,IAAc,CAAC,CAAC;;IAEvG,IAAI,yBAAyB,IAAI,IAAI,IAAI,yBAAyB,CAAC,OAAO,IAAI,IAAI,EAAE;QACnF,OAAO,yBAAyB,CAAC,OAAO,CAAC;KACzC;;IAGD,MAAM,OAAO,GAAG,yBAAyB,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,EAAE,SAAS,CAAE,CAAC,OAAsB,CAAC;IAExG,MAAM,iBAAiB,GAAG,mBAAmB,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,2BAA2B,CAAoB,IAAI,EAAE,UAAU,CAAC,iBAAiB,CAAC,CAAC;IAChJ,IAAI,iBAAiB,IAAI,IAAI,EAAE;QAC9B,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;KACtC;IAED,IAAI;QACH,MAAM,MAAM,GAAG,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpD,OAAO,mBAAmB,CAAC,IAAI,CAAC;cAC7B,MAAM;cACN,MAAM,CAAC,IAAI,CAAC,CAAC;KAChB;IAAC,OAAO,EAAE,EAAE;QACZ,IAAI,EAAE,YAAY,eAAe;YAAE,MAAM,EAAE,CAAC;;YACvC,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,iBAAiB,EAAE,IAAI,EAAE,iBAAiB,CAAC,IAAI,CAAC,IAAI,EAAC,CAAC,CAAC;KACjG;;;CACD,DCvCD;;;;;AAKA,SAAgB,kBAAkB,CAAE,EAAqI;QAArI,EAAC,IAAI,EAAE,WAAW,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,uBAAuB,OAAyC,EAAvC,gIAAO;;IAGxI,MAAM,gBAAgB,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IACjF,IAAI,gBAAgB,IAAI,IAAI,EAAE;QAC7B,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,gBAAgB,CAAC,OAAO,EAAE,2BAA2B,CAAC,CAAC;;QAEpF,OAAO,gBAAgB,CAAC,OAAO,CAAC;KAChC;;;IAID,MAAM,MAAM,GAAG,WAAW,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;IACrD,IAAI,gBAAgB,GAA0B,MAAM,IAAI,IAAI,GAAG,SAAS,GAAG,MAAM,CAAC,gBAAgB,CAAC;IAEnG,IAAI,MAAM,IAAI,IAAI,IAAI,gBAAgB,IAAI,IAAI,EAAE;QAC/C,IAAI;;YAEH,MAAM,aAAa,GAAG,WAAW,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;YAC3D,gBAAgB,GAAG,aAAa,CAAC,gBAAgB,CAAC;SAClD;QAAC,WAAM;;SAEP;KACD;;IAGD,IAAI,gBAAgB,IAAI,IAAI,EAAE;QAC7B,IAAI,gBAAgB,CAAC,aAAa,EAAE,CAAC,iBAAiB,EAAE;YAEvD,MAAM,cAAc,GAAG,oDAAoD,iBAAE,IAAI,EAAE,gBAAgB,EAAE,uBAAuB,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,WAAW,EAAE,KAAK,IAAK,IAAI,EAAE,CAAC;;YAEtM,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,cAAc,EAAE,SAAS,EAAE,IAAI,EAAE,gBAAgB,EAAC,CAAC,CAAC;YACvH,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,cAAc,EAAE,+BAA+B,gBAAgB,CAAC,aAAa,EAAE,KAAK,IAAI,CAAC,aAAa,EAAE,GAAG,EAAE,GAAG,oBAAoB,IAAI,CAAC,aAAa,EAAE,CAAC,QAAQ,WAAW,gBAAgB,CAAC,aAAa,EAAE,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC;YAC1P,OAAO,cAAc,CAAC;SAEtB;;;QAID,IAAI,qBAAqB,CAAC,gBAAgB,CAAC,IAAI,gBAAgB,CAAC,aAAa,EAAE,CAAC,QAAQ,KAAK,IAAI,CAAC,aAAa,EAAE,CAAC,QAAQ,IAAI,gBAAgB,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE;;YAG9J,IAAI,yBAAyB,CAAC,gBAAgB,CAAC,MAAM,CAAC,IAAI,gBAAgB,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE;gBACpG,MAAM,WAAW,GAAG,SAAS,CAAC;gBAC9B,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,WAAW,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,gBAAgB,EAAC,CAAC,CAAC;gBACtI,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,yBAAyB,CAAC,CAAC;gBACrE,OAAO,WAAW,CAAC;aACnB;;iBAGI;gBACJ,MAAM,IAAI,wBAAwB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;aAC3C;SAED;QAED,QAAQ,CAAC,WAAW,CAAC,gBAAgB,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;QAC7E,MAAM,UAAU,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;;QAG/B,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,IAAI,EAAE,gBAAgB,EAAC,CAAC,CAAC;QACnH,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,+BAA+B,gBAAgB,CAAC,aAAa,EAAE,KAAK,IAAI,CAAC,aAAa,EAAE,GAAG,EAAE,GAAG,oBAAoB,IAAI,CAAC,aAAa,EAAE,CAAC,QAAQ,WAAW,gBAAgB,CAAC,aAAa,EAAE,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC;QACtP,OAAO,UAAU,CAAC;KAClB;;IAGD,MAAM,IAAI,wBAAwB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;;;CAC3C,DCvED;;;;AAIA,SAAgB,aAAa,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAA2B;;IAErF,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;IAEzF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAChD,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;;QAGrC,IAAI,wBAAwB,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,qBAAqB,CAAC,SAAS,CAAC,IAAI,gBAAgB,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,iBAAiB,CAAC,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC;YAAE,SAAS;QAEnM,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,uBAAuB,CAAC,CAAC;;QAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,YAAY,EAAE,eAAe,EAAE,aAAa,CAAC,EAAE;YACtH,MAAM;SACN;KACD;;;CACD,DCzBD;;;;;AAKA,SAAgB,uBAAuB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,EAAE,uBAAuB,EAAqC;IACpJ,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;IAG/F,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;QAC5B,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KACtB;SAEI;QACJ,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC,CAAC;KACvF;;;ACjBF;;;;;AAKA,SAAgB,+BAA+B,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAA6C;IAClJ,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,YAAY,EAAE;QAC5C,QAAQ,CAAC,WAAW,CAAC,WAAW,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;KACxE;;;CACD,DCRD;;;;AAIA,SAAgB,yBAAyB,CAAE,EAAqD;QAArD,EAAC,IAAI,OAAgD,EAA9C,2BAAO;IACxD,+BAA+B,iBAAE,IAAI,EAAE,IAAI,CAAC,eAAe,IAAK,IAAI,EAAE,CAAC;;;CACvE,DCJD;;;;;;AAOA,SAAgB,6BAA6B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,uBAAuB,EAA2C;IACzJ,MAAM,YAAY,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAW,CAAC;IAEzG,QAAQ,IAAI,CAAC,QAAQ;QACpB,KAAK,UAAU,CAAC,SAAS,EAAE;YAC1B,OAAO,CAAC,YAAY,CAAC;SACrB;QAED,KAAK,UAAU,CAAC,UAAU,EAAE;YAC3B,OAAO,CAAC,YAAY,CAAC;SACrB;QAED,KAAK,UAAU,CAAC,UAAU,EAAE;YAC3B,OAAO,CAAC,YAAY,CAAC;SACrB;QAED,KAAK,UAAU,CAAC,gBAAgB,EAAE;YACjC,OAAO,CAAC,YAAY,CAAC;SACrB;QAED,KAAK,UAAU,CAAC,aAAa,EAAE;;YAE9B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;gBAChC,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAC,CAAC,CAAC;aACpD;;YAGD,MAAM,IAAI,GAAG,qCAAqC,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAC;YACpF,MAAM,KAAK,GAAG,EAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAa,CAAC;;YAGrD,IAAI,SAAS,CAAC,cAAc,IAAI,IAAI,EAAE;gBACrC,SAAS,CAAC,cAAc,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;aACjE;YACD,OAAO,KAAK,CAAC;SACb;QAED,KAAK,UAAU,CAAC,eAAe,EAAE;;YAEhC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;gBAChC,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAC,CAAC,CAAC;aACpD;;YAGD,MAAM,IAAI,GAAG,qCAAqC,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAC;YACpF,MAAM,KAAK,GAAG,EAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAa,CAAC;;YAGrD,IAAI,SAAS,CAAC,cAAc,IAAI,IAAI,EAAE;gBACrC,SAAS,CAAC,cAAc,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;aACjE;YACD,OAAO,KAAK,CAAC;SACb;KACD;;;CACD,DC9DD;;;;;AAKA,SAAgB,gCAAgC,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAA8C;IACpJ,MAAM,gBAAgB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAiB,CAAC;IAEtH,MAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,IAAI,IAAI,IAAI,gBAAgB,IAAI,IAAI;;UAEpE,SAAS;UACT,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;;IAIpC,IAAI,OAAO,KAAK,KAAK,UAAU,IAAI,uBAAuB,CAAC,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,EAAE;QAC/F,OAAO;YACN,CAAC,cAAc;YACf,MAAM,EAAE,CAAC,cAAyC,EAAE,GAAG,IAAe;gBACrE,OAAO,cAAc,IAAI,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,WAAW,CAAC;sBACjE,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAc,CAAC,IAAI,CAAC,cAAc,EAAE,GAAG,IAAI,CAAC;sBAC3E,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAc,CAAC,GAAG,IAAI,CAAC,CAAC;aAC3D;SACW,CAAC;KACd;;QAEI,OAAO,KAAK,CAAC;;;CAClB,DC3BD;;;;;AAKA,SAAgB,+BAA+B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAA6C;IAClJ,MAAM,gBAAgB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAiB,CAAC;IACtH,MAAM,wBAAwB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,kBAAkB,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;IAGzI,MAAM,KAAK,GAAG,IAAI,CAAC,gBAAgB,IAAI,IAAI,IAAI,gBAAgB,IAAI,IAAI;;UAEpE,SAAS;UACT,gBAAgB,CAAC,wBAAwB,CAAC,CAAC;;;IAI9C,IAAI,OAAO,KAAK,KAAK,UAAU,IAAI,uBAAuB,CAAC,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,EAAE;QAC/F,OAAO;YACN,CAAC,cAAc;YACf,MAAM,EAAE,CAAC,cAAyC,EAAE,GAAG,IAAe,KAAK,cAAc,IAAI,IAAI,IAAI,CAAC,eAAe,CAAC,KAAK,EAAE,WAAW,CAAC;kBACrI,gBAAgB,CAAC,wBAAwB,CAAc,CAAC,IAAI,CAAC,cAAc,EAAE,GAAG,IAAI,CAAC;kBACrF,gBAAgB,CAAC,wBAAwB,CAAc,CAAC,GAAG,IAAI,CAAC;SACxD,CAAC;KACd;;QAEI,OAAO,KAAK,CAAC;;;AC3BnB;;;;;AAKA,SAAgB,4BAA4B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAA0C;IAC5I,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;;CAClF,DCAD;;;;;;AAOA,SAAgB,2BAA2B,CAAE,OAA+C;IAC3F,MAAM,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,KAAa,OAAO,EAAlB,iFAAkB,CAAC;IAEzE,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAElE,MAAM,oBAAoB,GAAG,WAAW,CAAC,IAAI,EAAE,UAAU,CAAC,YAAY,CAAC;UACpE,eAAe,mBAAmB,CAAiB,GAAG,IAAe;;YAEtE,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;YAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;gBACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;aAC3H;;YAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;YAEF,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YACxC,IAAI,UAAU,IAAI,IAAI,IAAI,UAAU,CAAC,iBAAiB,EAAE;gBACvD,MAAM,cAAc,GAAG,oDAAoD,CAAC,OAAO,CAAC,CAAC;gBACrF,OAAQ,cAA2B,CAAC,GAAG,IAAI,CAAC,CAAC;aAC7C;;YAGD,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;gBAAE,OAAO;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;YAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;aACnB;;iBAGI;gBACJ,OAAO,SAAS,CAAC;aACjB;SACD;UACC,SAAS,mBAAmB,CAAiB,GAAG,IAAe;;YAEhE,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;YAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;gBACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;aAC3H;;YAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;YAEF,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;YACxC,IAAI,UAAU,IAAI,IAAI,IAAI,UAAU,CAAC,iBAAiB,EAAE;gBACvD,MAAM,cAAc,GAAG,oDAAoD,CAAC,OAAO,CAAC,CAAC;gBACrF,OAAQ,cAA2B,CAAC,GAAG,IAAI,CAAC,CAAC;aAC7C;;YAGD,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;gBAAE,OAAO;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;YAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;aACnB;;;gBAGI,OAAO,SAAS,CAAC;SACtB,CAAC;IAEH,IAAI,UAAU,IAAI,IAAI,EAAE;QACvB,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,oBAAoB,CAAC,IAAI,CAAC,oBAAoB,CAAC,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;KACvI;IAED,oBAAoB,CAAC,QAAQ,GAAG,MAAM,YAAY,UAAU,IAAI,IAAI,GAAG,EAAE,GAAG,KAAK,UAAU,EAAE,GAAG,CAAC;;;IAIjG,MAAM,CAAC,cAAc,CACpB,oBAAoB,EACpB,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,CAAE,CAAC,OAAmB,CAC7E,CAAC;IAEF,KAAK,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;;;AC3HlC;;;;;AAMA,SAAgB,mBAAmB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAiC;IAE1H,MAAM,eAAe,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;IAGnG,IAAI,eAAe,EAAE;;QAEpB,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;KACpD;;SAGI,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,EAAE;QACpC,OAAO,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,EAAE,WAAW,CAAC,CAAC;KAC3D;;;ACnBF;;;;;AAKA,SAAgB,2BAA2B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,uBAAuB,EAAyC;IACjJ,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC,CAAC;;;ACLxF;;;;;AAKA,SAAgB,0BAA0B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAwC;IACxI,IAAI,GAAG,GAAG,EAAE,CAAC;IACb,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IACtB,KAAK,MAAM,IAAI,IAAI,IAAI,CAAC,aAAa,EAAE;QACtC,MAAM,UAAU,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAW,CAAC;QAC1G,GAAG,IAAI,UAAU,CAAC;QAClB,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC;KACzB;IACD,OAAO,GAAG,CAAC;;;ACbZ;;;;;AAKA,SAAgB,qBAAqB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAmC;IAC9H,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;;CAClF,DCLD;;;;;AAKA,SAAgB,8BAA8B,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,uBAAuB,EAA4C;;IAE3J,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,OAAO,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;IAExE,QAAQ,IAAI,CAAC,QAAQ;QACpB,KAAK,UAAU,CAAC,aAAa,EAAE;;YAE9B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;gBAChC,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAC,CAAC,CAAC;aACpD;;YAGD,MAAM,KAAK,GAAI,qCAAqC,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAa,EAAE,CAAC;;YAGvH,IAAI,SAAS,CAAC,cAAc,IAAI,IAAI,EAAE;gBACrC,SAAS,CAAC,cAAc,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;aACjE;YACD,OAAO,KAAK,CAAC;SACb;QAED,KAAK,UAAU,CAAC,eAAe,EAAE;;YAEhC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;gBAChC,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,EAAC,CAAC,CAAC;aACpD;;YAGD,MAAM,KAAK,GAAI,qCAAqC,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAE,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAa,EAAE,CAAC;;YAGvH,IAAI,SAAS,CAAC,cAAc,IAAI,IAAI,EAAE;gBACrC,SAAS,CAAC,cAAc,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;aACjE;YACD,OAAO,KAAK,CAAC;SACb;KACD;;;AC3CF;;;;;AAKA,SAAgB,qBAAqB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAmC;IAE9H,MAAM,aAAa,GAAc,EAAE,CAAC;IAEpC,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,EAAE;QAC3B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/C,aAAa,CAAC,CAAC,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;SAChG;KACD;;IAGD,MAAM,gBAAgB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAA0C,CAAC;IAE/I,QAAQ,IAAI,gBAAgB,CAAC,GAAG,aAAa,CAAC,EAAE;;;AClBjD;;;;;AAKA,SAAgB,yBAAyB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAuC;IACtI,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;;ACNnF;;;;;AAKA,SAAgB,oBAAoB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAkC;IAC5H,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;;ACPnF;;;;;AAKA,SAAgB,uBAAuB,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAAqC;IAClI,MAAM,gBAAgB,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;IACpG,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,EAAE,gBAAgB,EAAE,uBAAuB,CAAC,CAAC;;;CAClG,DCPD;;;AAGA,MAAa,sBAAuB,SAAQ,eAAe;IAE1D,YAAa,EAAC,OAAO,GAAG,kGAAkG,EAAiC;QAC1J,KAAK,CAAC,EAAC,OAAO,EAAE,IAAI,EAAE,oBAAoB,EAAE,EAAC,CAAC,CAAC;KAC/C;;;CACD,DCVD,IAAI,SAAyD,CAAC;AAE9D,IAAI;;IAEH,MAAM,cAAc,GAAG,OAAO,CAAC,SAAS,CAA6B,CAAC;IACtE,SAAS,GAAG,cAAc,CAAC,SAAS,CAAC;CACrC;AAAC,WAAM;;CAEP;;;;;;AAOD,SAAgB,SAAS,CAAK,OAAmB;IAChD,IAAI,SAAS,KAAK,SAAS,EAAE;;QAE5B,MAAM,IAAI,sBAAsB,CAAC,EAAE,CAAC,CAAC;KACrC;IACD,IAAI,IAAI,GAAG,KAAK,CAAC;IACjB,IAAI,QAAQ,GAAG,KAAK,CAAC;IACrB,IAAI,aAAsB,CAAC;IAC3B,IAAI,YAAqB,CAAC;IAE1B,OAAO,CAAC,IAAI,CAAC,UAAU,OAAO;QAC7B,IAAI,GAAG,IAAI,CAAC;QACZ,aAAa,GAAG,OAAO,CAAC;KACxB,CAAC;SACA,KAAK,CAAC,UAAU,CAAC;QACjB,IAAI,GAAG,IAAI,CAAC;QACZ,QAAQ,GAAG,IAAI,CAAC;QAChB,YAAY,GAAG,CAAC,CAAC;KACjB,CAAC,CAAC;IAEJ,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAEvB,IAAI,QAAQ,EAAE;QACb,MAAM,YAAY,CAAC;KACnB;IACD,OAAO,aAAkB,CAAC;;;CAC1B,DChCD;;;;;;AAOA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,uBAAuB,EAAoC;;IAGnJ,MAAM,gBAAgB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAsB,CAAC;;IAG3H,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;QACjD,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,WAAW,EAAC,CAAC,CAAC;KACxD;;SAGI,IAAI,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;QAClD,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC;KACxE;IAED,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,EAAE;QAC/B,KAAK,MAAM,OAAO,IAAI,gBAAgB,EAAE;;YAEvC,MAAM,gBAAgB,GAAG,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAG9D,uBAAuB,CAAC,EAAC,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAGtH,uBAAuB,CAAC,EAAC,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAGzH,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,gBAAgB,EAAE,OAAO,EAAE,uBAAuB,CAAC,CAAC;;YAGhH,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;;YAGrD,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,CAAC,EAAE;gBAC/E,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACtB,MAAM;aACN;iBAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,eAAe,CAAC,EAAE;gBACvF,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;;gBAEzB,SAAS;aACT;iBAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACrF,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBACvB,OAAO;aACP;SACD;KACD;SAEI;QACJ,KAAK,IAAI,OAAO,IAAI,gBAAgB,EAAE;YACrC,IAAI,IAAI,CAAC,aAAa,IAAI,IAAI,EAAE;gBAC/B,OAAO,GAAG,SAAS,CAAC,OAA2B,CAAC,CAAC;aACjD;;YAGD,MAAM,gBAAgB,GAAG,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAG9D,uBAAuB,CAAC,EAAC,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAGtH,uBAAuB,CAAC,EAAC,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAGzH,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,gBAAgB,EAAE,OAAO,EAAE,uBAAuB,CAAC,CAAC;;YAGhH,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;;YAGrD,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,CAAC,EAAE;gBAC/E,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBACtB,MAAM;aACN;iBAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,eAAe,CAAC,EAAE;gBACvF,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;;gBAEzB,SAAS;aACT;iBAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACrF,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;gBACvB,OAAO;aACP;SACD;KACD;;;CACD,DCtGD;;;;;AAKA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAoC;IAC7F,MAAM,KAAK,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;IACxE,OAAO,KAAK,IAAI,IAAI,GAAG,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC;;;CACjD,DCTD;;;;;AAKA,SAAgB,sBAAsB,CAAE,EAAC,WAAW,EAAE,SAAS,EAAE,IAAI,EAAoC;IACxG,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;;CAC9F,DCPD;;;;;AAKA,SAAgB,yBAAyB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,SAAS,EAAuC;IAC9G,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;;CACjG,DCJD;;;;;;AAOA,SAAgB,oBAAoB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,SAAS,EAAE,uBAAuB,EAAkC;;IAGvI,MAAM,cAAc,GAAG,uBAAuB,CAAC,WAAW,CAAC,CAAC;;IAG5D,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,EAAE;QACnC,IAAI,yBAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;YAChD,KAAK,MAAM,WAAW,IAAI,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE;gBACxD,QAAQ,CAAC,WAAW,CAAC,WAAW,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAC;aAC3E;SACD;aAEI;YACJ,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAC;SAC/E;KACD;IAED,OAAO,IAAI,EAAE;;QAEZ,MAAM,oBAAoB,GAAG,uBAAuB,CAAC,cAAc,CAAC,CAAC;;QAGrE,uBAAuB,CAAC,EAAC,GAAG,EAAE,oBAAoB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAG1H,uBAAuB,CAAC,EAAC,GAAG,EAAE,oBAAoB,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAG7H,MAAM,eAAe,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI;cAC3C,IAAI;eACH,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAY,CAAC;;QAG7F,IAAI,CAAC,eAAe;YAAE,OAAO;;QAG7B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,oBAAoB,CAAC,CAAC;;QAGzD,IAAI,8BAA8B,CAAC,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE,YAAY,CAAC,EAAE;YACnF,MAAM;SACN;aAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;YACzF,OAAO;SACP;;QAGD,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,EAAE;YAC7B,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAC;SAC/E;;aAGI,IAAI,8BAA8B,CAAC,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE,eAAe,CAAC,EAAE;;YAE3F,SAAS;SACT;KAED;;;CACD,DCnED;;;;;;AAOA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,uBAAuB,EAAoC;IAEnJ,IAAI,SAAS,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAY,CAAC;IAExG,OAAO,SAAS,EAAE;;QAEjB,MAAM,oBAAoB,GAAG,uBAAuB,CAAC,WAAW,CAAC,CAAC;;QAGlE,uBAAuB,CAAC,EAAC,GAAG,EAAE,oBAAoB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAG1H,uBAAuB,CAAC,EAAC,GAAG,EAAE,oBAAoB,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAG7H,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,oBAAoB,CAAC,CAAC;;QAGzD,IAAI,8BAA8B,CAAC,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE,YAAY,CAAC,EAAE;YACnF,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YACtB,MAAM;SACN;aAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;YACzF,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YACvB,OAAO;SACP;QAED,SAAS,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAY,CAAC;;QAGpG,IAAI,8BAA8B,CAAC,IAAI,EAAE,oBAAoB,EAAE,IAAI,EAAE,eAAe,CAAC,EAAE;YACtF,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;;YAEzB,SAAS;SACT;KACD;;;CACD,DC1CD;;;;;;AAOA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,uBAAuB,EAAoC;;IAGnJ,MAAM,gBAAgB,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAiB,CAAC;;IAGtH,IAAI,CAAC,yBAAyB,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE;QACjD,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,WAAW,EAAC,CAAC,CAAC;KACxD;;SAGI,IAAI,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;QAClD,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,EAAC,CAAC,CAAC;KACxE;IAED,KAAK,MAAM,OAAO,IAAI,gBAAgB,EAAE;;QAEvC,MAAM,gBAAgB,GAAG,uBAAuB,CAAC,WAAW,CAAC,CAAC;;QAG9D,uBAAuB,CAAC,EAAC,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAGtH,uBAAuB,CAAC,EAAC,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAGzH,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC,YAAY,CAAC,CAAC,CAAC,EAAE,gBAAgB,EAAE,OAAO,EAAE,uBAAuB,CAAC,CAAC;;QAGhH,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;;QAGrD,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,CAAC,EAAE;YAC/E,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YACtB,MAAM;SACN;aAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,eAAe,CAAC,EAAE;YACvF,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;;YAEzB,SAAS;SACT;aAEI,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;YACrF,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YACvB,OAAO;SACP;KACD;;;CACD,DCvDD;;;;;;AAOA,SAAgB,0BAA0B,CAAE,EAA+F;QAA/F,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,OAAiD,EAA/C,4EAAO;IAElG,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAElE,MAAM,mBAAmB,GAAG,WAAW,CAAC,IAAI,EAAE,UAAU,CAAC,YAAY,CAAC;UACnE,eAAe,kBAAkB,CAAiB,GAAG,IAAe;;YAErE,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;YAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;gBACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;aAC3H;;YAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;;YAGF,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;gBAAE,OAAO;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;YAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;aACnB;;;gBAGI,OAAO,SAAS,CAAC;SACtB;UACC,SAAS,kBAAkB,CAAiB,GAAG,IAAe;;YAE/D,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;YAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;gBACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;aAC3H;;YAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;;YAGF,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;gBAAE,OAAO;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;YAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;aACnB;;;gBAGI,OAAO,SAAS,CAAC;SACtB,CAAC;IAEH,IAAI,UAAU,IAAI,IAAI,EAAE;QACvB,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,mBAAmB,CAAC,IAAI,CAAC,mBAAmB,CAAC,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;KACrI;IAED,mBAAmB,CAAC,QAAQ,GAAG,MAAM,YAAY,UAAU,IAAI,IAAI,GAAG,EAAE,GAAG,KAAK,UAAU,EAAE,GAAG,CAAC;;;IAIhG,MAAM,CAAC,cAAc,CACpB,mBAAmB,EACnB,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,CAAE,CAAC,OAAmB,CAC7E,CAAC;IAEF,OAAO,mBAAmB,CAAC;;;CAC3B,DC3GD;;;AAGA,MAAa,kCAAmC,SAAQ,eAAe;IAOtE,YAAa,EAAC,IAAI,EAAE,OAAO,GAAG,oCAAoC,EAA6C;QAC9G,KAAK,CAAC,EAAC,IAAI,EAAE,OAAO,EAAC,CAAC,CAAC;KACvB;;;CACD,DCjBM,MAAM,UAAU,GAAG,OAAO;;2BAAC,3BCMlC;;;;;AAKA,SAAgB,oBAAoB,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,uBAAuB,EAAkC;IACvI,MAAM,UAAU,GAAG;QAClB,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,EAAE,IAAI,EAAC,CAAC,CAAC;;QAE9G,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;KAC/C,CAAC;IAEF,MAAM,YAAY,GAAG,CAAC,EAAS;QAC9B,kCAAkC,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;;QAE5D,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAY,EAAE,WAAW,EAAE,EAAE,EAAE,uBAAuB,CAAC,CAAC;KACvF,CAAC;IAEF,MAAM,cAAc,GAAG;QACtB,kCAAkC,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;;QAE5D,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,YAAa,EAAE,WAAW,CAAC,CAAC;KACpD,CAAC;;IAGF,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;QAC1D,MAAM,IAAI,kCAAkC,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;KACrD;;SAGI,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;QAC/D,IAAI;YACH,UAAU,EAAE,CAAC;SACb;QAAC,OAAO,EAAE,EAAE;YACZ,YAAY,CAAC,EAAE,CAAC,CAAC;SACjB;KACD;;SAGI,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;QAC/D,IAAI;YACH,UAAU,EAAE,CAAC;SACb;QAAC,OAAO,EAAE,EAAE;YACZ,YAAY,CAAC,EAAE,CAAC,CAAC;SACjB;gBAAS;YACT,cAAc,EAAE,CAAC;SACjB;KACD;;SAGI,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;QAC/D,IAAI;YACH,UAAU,EAAE,CAAC;SACb;gBAAS;YACT,cAAc,EAAE,CAAC;SACjB;KACD;;;AC5DF;;;;;;;AAOA,SAAgB,wBAAwB,CAAE,EAAC,IAAI,EAAE,YAAY,EAAE,IAAI,GAAG,SAAQ,EAA4C;IACzH,IAAI,YAAY,IAAI,IAAI,EAAE;QACzB,OAAO,IAAI,QAAQ,CAAC,MAAM,EAAE,gBAAgB,IAAI,IAAI,IAAI,GAAG,EAAE,GAAG,IAAI,iIAAiI,CAAC,CAAC,IAAI,CAAC,CAAC;KAC7M;SAEI;QACJ,OAAO,IAAI,QAAQ,CAAC,cAAc,EAAE,MAAM,EAAE,gBAAgB,IAAI,IAAI,IAAI,GAAG,EAAE,GAAG,IAAI,2KAA2K,CAAC,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;KACrR;;;CACD,DCXD;;;;AAIA,SAAgB,wBAAwB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,uBAAuB,EAAsC;IAC9J,IAAI,YAAgC,CAAC;IACrC,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;IAC/D,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAC,CAAC;IAEtF,IAAI,IAAwB,CAAC;IAC7B,IAAI,UAAU,IAAI,IAAI,EAAE;QACvB,QAAQ,CAAC,WAAW,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;QACvE,IAAI,GAAG,KAAK,CAAC,GAAG,EAAc,CAAC;KAC/B;IAED,IAAI,IAAI,CAAC,eAAe,IAAI,IAAI,EAAE;QACjC,MAAM,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,KAAK,KAAK,UAAU,CAAC,cAAc,CAAC,CAAC;QACtG,IAAI,aAAa,IAAI,IAAI,EAAE;YAC1B,MAAM,CAAC,iBAAiB,CAAC,GAAG,aAAa,CAAC,KAAK,CAAC;YAChD,IAAI,iBAAiB,IAAI,IAAI,EAAE;gBAC9B,YAAY,IAAI,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAa,CAAC;aACrH;SACD;KACD;IAED,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAC5D,IAAI,gBAAgB,GAAG,wBAAwB,CAAC,EAAC,IAAI,EAAE,YAAY,EAAE,IAAI,EAAC,CAAC,CAAC;IAE5E,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;QAC5B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;YACxC,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,CAAC,gBAAgB,CAAC,EAAE,uBAAuB,CAAC,CAAC;YAC/F,gBAAgB,GAAG,KAAK,CAAC,GAAG,EAAc,CAAC;SAC3C;KACD;IAED,gBAAgB,CAAC,QAAQ,GAAG,MAAM,SAAS,IAAI,IAAI,IAAI,GAAG,EAAE,GAAG,KAAK,IAAI,EAAE,GAAG,CAAC;IAE9E,IAAI,IAAI,IAAI,IAAI,EAAE;QACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,gBAAgB,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;KACpH;;IAGD,KAAK,MAAM,MAAM,IAAI,YAAY,EAAE;QAClC,QAAQ,CAAC,gBAAgB,CACxB,MAAM,EACN,WAAW,EACX,WAAW,CAAC,MAAM,EAAE,UAAU,CAAC,aAAa,CAAC;cAC1C,gBAAgB;cAChB,gBAAgB,CAAC,SAAS,EAC7B,uBAAuB,CACvB,CAAC;KACF;IAED,MAAM,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC;IACrC,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;IAC7B,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;;;CACvB,DCrDD;;;;;AAKA,SAAgB,8BAA8B,CAAE,EAAmG;QAAnG,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,OAAqD,EAAnD,4EAAO;;;;;IAMtG,SAAS,WAAW,CAAsB,GAAG,IAAe;;;QAI3D,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;QAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;QAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;YACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;SAC3H;;QAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;YACR,KAAK;YACL,SAAS,IACN,IAAI,GACL,IAAI,EAAE,IAAI,CACb,CAAC;;QAGF,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;YAAE,OAAO;QAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;QAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;YACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;SACnB;;;YAGI,OAAO,SAAS,CAAC;KACtB;IAED,WAAW,CAAC,QAAQ,GAAG,MAAM,yBAAyB,CAAC;IACvD,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;;;CACxB,DCxDD;;;;;AAKA,SAAgB,uBAAuB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAqC;IAC/F,MAAM,KAAK,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,YAAY,CAAC,CAAC;IACzE,OAAO,KAAK,IAAI,IAAI,GAAG,SAAS,GAAG,KAAK,CAAC,OAAO,CAAC;;;ACTlD;;;;;AAKA,SAAgB,qBAAqB,CAAE,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,uBAAuB,EAAmC;IAC9H,QAAQ,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,EAAe;;;CACjG,DCJD;;;;;AAKA,SAAgB,uBAAuB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS,EAAE,uBAAuB,EAAqC;IAC5J,IAAI,YAAgC,CAAC;IACrC,MAAM,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;IAC/D,MAAM,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,wBAAwB,CAAC,MAAM,CAAC,CAAC,CAAC;IAEtF,IAAI,IAAwB,CAAC;IAC7B,IAAI,UAAU,IAAI,IAAI,EAAE;QACvB,QAAQ,CAAC,WAAW,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;QACvE,IAAI,GAAG,KAAK,CAAC,GAAG,EAAc,CAAC;KAC/B;IAED,IAAI,IAAI,CAAC,eAAe,IAAI,IAAI,EAAE;QACjC,MAAM,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,KAAK,KAAK,UAAU,CAAC,cAAc,CAAC,CAAC;QACtG,IAAI,aAAa,IAAI,IAAI,EAAE;YAC1B,MAAM,CAAC,iBAAiB,CAAC,GAAG,aAAa,CAAC,KAAK,CAAC;YAChD,IAAI,iBAAiB,IAAI,IAAI,EAAE;gBAC9B,YAAY,IAAI,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAa,CAAC;aACrH;SACD;KACD;IAED,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,IAAI,IAAI,GAAG,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAC5D,IAAI,eAAe,GAAG,wBAAwB,CAAC,EAAC,IAAI,EAAE,YAAY,EAAE,IAAI,EAAC,CAAC,CAAC;IAE3E,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;QAC5B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;YACxC,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,CAAC,eAAe,CAAC,EAAE,uBAAuB,CAAC,CAAC;YAC9F,eAAe,GAAG,KAAK,CAAC,GAAG,EAAc,CAAC;SAC1C;KACD;IAED,eAAe,CAAC,QAAQ,GAAG,MAAM,SAAS,IAAI,IAAI,IAAI,GAAG,EAAE,GAAG,KAAK,IAAI,EAAE,GAAG,CAAC;IAE7E,IAAI,IAAI,IAAI,IAAI,EAAE;QACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,eAAe,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;KACnH;;IAGD,KAAK,MAAM,MAAM,IAAI,YAAY,EAAE;QAClC,QAAQ,CAAC,gBAAgB,CACxB,MAAM,EACN,WAAW,EACX,WAAW,CAAC,MAAM,EAAE,UAAU,CAAC,aAAa,CAAC;cAC1C,eAAe;cACf,eAAe,CAAC,SAAS,EAC5B,uBAAuB,CACvB,CAAC;KACF;IAED,MAAM,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC;IACpC,OAAO,eAAe,CAAC;;;AC1DxB;;;;;AAKA,SAAgB,mBAAmB,CAAE,QAAwC;IAC5E,OAAO,IAAI,CAAC;;;ACNb;;;;;AAKA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAoC;IAChI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;IAE3E,OAAO,SAAS,CAAC;;;ACRlB;;;;;AAKA,SAAgB,wBAAwB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAsC;IACpI,OAAO,QAAQ,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC,CAAC;;;CAC3F,DCND;;;;;AAKA,SAAgB,qBAAqB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAmC;;IAE3F,MAAM,OAAO,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC,OAA4B,CAAC;;IAGrG,OAAO,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC;UACnC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;UACtB,IAAI,CAAC,IAAI,CACX,CAAC;;;CACF,DCdD;;;;;AAKA,SAAgB,uBAAuB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAE,SAAS,EAAE,KAAK,EAAqC;;;IAGpJ,MAAM,UAAU,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC,OAA4B,CAAC;IACxG,MAAM,eAAe,GAAiB,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;IAC9E,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;;IAG5B,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,EAAE,KAAK,EAAE,eAAe,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;IAEnH,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;QAClC,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE,WAAW,EAAE,eAAe,EAAE,uBAAuB,CAAC,CAAC;KACzF;IAED,eAAe,CAAC,QAAQ,GAAG,MAAM,UAAU,IAAI,GAAG,CAAC;;IAGnD,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;;;CAC5B,DCvBD;;;;;AAKA,SAAgB,mCAAmC,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,EAAE,KAAK,EAAE,uBAAuB,EAAgC;;;IAG7J,MAAM,UAAU,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,CAAE,CAAC,OAA4B,CAAC;IACxG,MAAM,eAAe,GAAiB,UAAU,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;IAE9E,MAAM,YAAY,GAAG,WAAW,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC;IAC3D,IAAI,YAAY,IAAI,IAAI,EAAE;QACzB,MAAM,OAAO,GAAG,YAAY,CAAC,OAAO,CAAC;QACrC,IAAI,OAAO,IAAI,IAAI,EAAE;YACpB,KAAK,MAAM,CAAC,UAAU,EAAE,MAAM,CAAC,IAAK,OAAO,CAAC,OAAO,EAAyC,EAAE;gBAE7F,MAAM,gBAAgB,GAAG,MAAM,CAAC,gBAAgB,CAAC;gBACjD,IAAI,gBAAgB,IAAI,IAAI;oBAAE,OAAO;gBAErC,QAAQ,CAAC,WAAW,CAAC,gBAAgB,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;gBAC7E,eAAe,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;aAC1C;SACD;KACD;IACD,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;;;CAC5B,DC3BD;;;;;AAKA,SAAgB,yBAAyB,CAAE,OAA6C;IACvF,OAAO,CAAC,KAAK,CAAC,IAAI,CACjB,oDAAoD,CAAC,OAAO,CAAC,CAC7D,CAAC;;;ACTH;;;;;;;AAOA,SAAgB,yBAAyB,CAAE,QAA8C;;;ACPzF;;;;;AAKA,SAAgB,sBAAsB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAoC;IAChI,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAW,EAAE,WAAW,EAAE,uBAAuB,CAAC,EAAE;;;ACNrF;;;;;;;AAOA,SAAgB,+BAA+B,CAAE,QAAoD;;;CACpG,DCRD;;;AAGA,MAAa,0BAA2B,SAAQ,WAAW;IAM1D,YAAa,EAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,GAAG,wCAAwC,QAAQ,EAAE,EAAqC;QAC9H,KAAK,CAAC,EAAC,SAAS,EAAE,eAAe,EAAE,OAAO,EAAE,IAAI,EAAC,CAAC,CAAC;QACnD,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KACzB;;;CACD,DCVD;;;;;AAKA,SAAgB,uBAAuB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,MAAM,EAAE,uBAAuB,EAAqC;;IAE1I,MAAM,OAAO,GAAG,MAAM,CAAC,aAAa,KAAK,QAAQ;UAC9C,SAAS;UACT,UAAU,CAAC;YACZ,MAAM,IAAI,0BAA0B,CAAC,EAAC,QAAQ,EAAE,MAAM,CAAC,aAAa,EAAE,IAAI,EAAC,CAAC,CAAC;SAC7E,EAAE,MAAM,CAAC,aAAa,CAAC,CAAC;IAE1B,MAAM,MAAM,GAAG,SAAS,CAAC,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAqB,CAAC,CAAC;;IAGzH,IAAI,OAAO,IAAI,IAAI;QAAE,YAAY,CAAC,OAAO,CAAC,CAAC;;IAG3C,OAAO,MAAM,CAAC;;;ACrBf;;;;;;AAOA,SAAgB,6BAA6B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAA2C;IAC9I,MAAM,cAAc,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;IAGjG,IAAI,cAAc,EAAE;;QAEnB,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;KAChF;;IAGD,OAAO,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,SAAS,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;;CACjF,DCnBD;;;;;AAKA,SAAgB,eAAe,CAAE,IAAU;IAC1C,IAAI,WAAW,GAAG,IAAI,CAAC;IACvB,OAAO,WAAW,IAAI,IAAI,IAAI,CAAC,YAAY,CAAC,WAAW,CAAC,EAAE;QACzD,IAAI,WAAW,CAAC,WAAW,EAAE,UAAU,CAAC,aAAa,CAAC;YAAE,OAAO,IAAI,CAAC;QACpE,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC;KACjC;IACD,OAAO,KAAK,CAAC;;;CACb,DCHD;;;;;;AAOA,SAAgB,yBAAyB,CAAE,EAAuH,EAAE,MAAqB;QAA9I,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,uBAAuB,EAAE,SAAS,OAAgD,EAA9C,uGAAO;IAC1H,MAAM,UAAU,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;IAChH,MAAM,QAAQ,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;IAEvC,IAAI,MAAM,IAAI,IAAI,EAAE;QACnB,IAAI,aAAsC,CAAC;QAC3C,IAAI,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YAC7B,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;YACxE,aAAa,GAAG,KAAK,CAAC,GAAG,EAA6B,CAAC;SACvD;aACI;YACJ,aAAa,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,uBAAuB,CAA4B,CAAC;SAClH;QACD,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,GAAG,aAAa,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;QACvF,OAAO;KACP;IAED,MAAM,kBAAkB,GAAG,WAAW,CAAC,IAAI,EAAE,UAAU,CAAC,YAAY,CAAC;UAClE,eAAe,iBAAiB,CAAiB,GAAG,IAAe;;YAGpE,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;YAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;gBACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;gBAG3H,uBAAuB,CAAC;oBACvB,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,QAAQ;0BAC9D,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC;0BAC3B,MAAM,CAAC,cAAc,CAAE,IAAiB,CAAC,WAAW,CAAC,CAAC,SAAS;oBAClE,UAAU,EAAE,IAAI;oBAChB,SAAS;oBACT,IAAI;iBACJ,CAAC,CAAC;aACH;;YAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,uBAAuB;gBACvB,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;;YAGF,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;gBAAE,OAAO;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;YAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;aACnB;;;gBAGI,OAAO,SAAS,CAAC;SACtB;UACC,SAAS,iBAAiB,CAAiB,GAAG,IAAe;;YAG9D,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;YAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;YAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;gBACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;gBAG3H,uBAAuB,CAAC;oBACvB,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,QAAQ;0BAC9D,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC;0BAC3B,MAAM,CAAC,cAAc,CAAE,IAAiB,CAAC,WAAW,CAAC,CAAC,SAAS;oBAClE,UAAU,EAAE,IAAI;oBAChB,SAAS;oBACT,IAAI;iBACJ,CAAC,CAAC;aACH;;YAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;gBACR,KAAK;gBACL,uBAAuB;gBACvB,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;;YAGF,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;gBAAE,OAAO;YAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;YAGvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;gBACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;aACnB;;;gBAGI,OAAO,SAAS,CAAC;SACtB,CAAC;IAEH,kBAAkB,CAAC,QAAQ,GAAG,MAAM,YAAY,UAAU,GAAG,CAAC;;;IAI9D,MAAM,CAAC,cAAc,CACpB,kBAAkB,EAClB,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,CAAE,CAAC,OAAmB,CAC7E,CAAC;IAEF,MAAM,CAAC,UAAU,CAAC,GAAG,kBAAkB,CAAC;IAExC,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;QAC5B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;YACxC,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,CAAC,MAAM,EAAE,UAAU,CAAC,EAAE,uBAAuB,CAAC,CAAC;;YAEjG,KAAK,CAAC,GAAG,EAAE,CAAC;SACZ;KACD;;IAGD,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;;QAE5B,MAAM,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,IAAI,EAAE,YAAY,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC;QAC9G,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC3C,MAAM,SAAS,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;YAChC,IAAI,SAAS,CAAC,UAAU,IAAI,IAAI,EAAE;gBACjC,KAAK,MAAM,SAAS,IAAI,SAAS,CAAC,UAAU,EAAE;oBAC7C,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,CAAC,CAAC,EAAE,uBAAuB,CAAC,CAAC;;oBAEpG,KAAK,CAAC,GAAG,EAAE,CAAC;iBACZ;aACD;SACD;KACD;;;CAED,DCtKD;;;;;;AAMA,SAAgB,2BAA2B,CAAE,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,uBAAuB,EAAE,KAAK,EAAyC,EAAE,MAAqB;;IAExK,MAAM,kBAAkB,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;IAExH,IAAI,MAAM,IAAI,IAAI,EAAE;QACnB,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;QACxE,MAAM,aAAa,GAAG,KAAK,CAAC,GAAG,EAA2B,CAAC;QAC3D,MAAM,QAAQ,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;QACvC,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,aAAa,CAAC,kBAAkB,CAAC,GAAG,aAAa,CAAC,SAAS,CAAC,kBAAkB,CAAC,CAAC,CAAC;QACvG,OAAO;KACP;IAED,MAAM,CAAC,kBAAkB,CAAC,GAAG,IAAI,CAAC,WAAW,IAAI,IAAI;UAClD,SAAS;UACT,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;IAE/E,IAAI,IAAI,CAAC,UAAU,IAAI,IAAI,EAAE;QAC5B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;YACxC,QAAQ,CAAC,gBAAgB,CAAC,SAAS,EAAE,WAAW,EAAE,CAAC,MAAM,EAAE,kBAAkB,CAAC,EAAE,uBAAuB,CAAC,CAAC;;YAEzG,KAAK,CAAC,GAAG,EAAE,CAAC;SACZ;KACD;;;CACD,DCxBD;;;;;AAKA,SAAgB,8BAA8B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,SAAS,EAAE,uBAAuB,EAA4C,EAAE,MAAqB;IAEzL,MAAM,UAAU,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;IAChH,MAAM,QAAQ,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;IAEvC,IAAI,MAAM,IAAI,IAAI,EAAE;QACnB,IAAI,aAAsC,CAAC;QAC3C,IAAI,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YAC7B,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;YACxE,aAAa,GAAG,KAAK,CAAC,GAAG,EAA6B,CAAC;SACvD;aACI;YACJ,aAAa,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,uBAAuB,CAA4B,CAAC;SAClH;QACD,KAAK,CAAC,IAAI,CAAC,QAAQ,GAAG,aAAa,CAAC,UAAU,CAAC,GAAG,aAAa,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC;QACvF,OAAO;KACP;;;;IAKD,SAAS,sBAAsB;;QAG9B,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;QAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;QAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;YACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG3H,uBAAuB,CAAC;gBACvB,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,QAAQ;sBAC9D,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC;sBAC3B,MAAM,CAAC,cAAc,CAAE,IAAiB,CAAC,WAAW,CAAC,CAAC,SAAS;gBAClE,UAAU,EAAE,IAAI;gBAChB,SAAS;gBACT,IAAI;aACJ,CAAC,CAAC;SACH;;QAGD,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;YAAE,OAAO;QAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;;QAEvD,IAAI,8BAA8B,CAAC,IAAI,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,CAAC,EAAE;YACvF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;SACnB;;;YAGI,OAAO,SAAS,CAAC;KACtB;IAED,sBAAsB,CAAC,QAAQ,GAAG,MAAM,SAAS,UAAU,GAAG,CAAC;IAE/D,IAAI,yBAAyB,GAAG,MAAM,CAAC,wBAAwB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IACpF,IAAI,yBAAyB,IAAI,IAAI;QAAE,yBAAyB,GAAG,EAAE,CAAC;IAEtE,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,UAAU,kCACpC,yBAAyB,KAC5B,YAAY,EAAE,IAAI,EAClB,GAAG,EAAE,sBAAsB,IAC1B,CAAC;;;CACH,DCdD;;;;;AAKA,SAAgB,YAAY,CAAE,EAAwC;QAAxC,EAAC,IAAI,OAAmC,EAAjC,2BAAO;IAE3C,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QACvB,OAAO,kBAAkB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC3C;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,qBAAqB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC9C;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;QAC9B,OAAO,oBAAoB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC7C;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,0BAA0B,CAAC,IAAI,CAAC,EAAE;QAC1C,OAAO,gCAAgC,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACzD;SAEI,IAAI,yBAAyB,CAAC,IAAI,CAAC,EAAE;QACzC,OAAO,+BAA+B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACxD;SAEI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,uBAAuB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAChD;SAEI,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,qBAAqB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC9C;SAEI,IAAI,oBAAoB,CAAC,IAAI,CAAC,EAAE;QACpC,OAAO,0BAA0B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACnD;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAClD;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,OAAO,2BAA2B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACpD;SAEI,IAAI,wBAAwB,CAAC,IAAI,CAAC,EAAE;QACxC,OAAO,8BAA8B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACvD;SAEI,IAAI,wBAAwB,CAAC,IAAI,CAAC,EAAE;QACxC,OAAO,8BAA8B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACvD;SAEI,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QAC5B,OAAO,mCAAmC,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC5D;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAClD;SAEI,IAAI,uBAAuB,CAAC,IAAI,CAAC,EAAE;QACvC,OAAO,6BAA6B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACtD;SAEI,IAAI,wBAAwB,CAAC,IAAI,CAAC,EAAE;QACxC,OAAO,8BAA8B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACvD;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAClD;SAEI,IAAI,sBAAsB,CAAC,IAAI,CAAC,EAAE;QACtC,OAAO,4BAA4B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACrD;SAEI,IAAI,yBAAyB,CAAC,IAAI,CAAC,EAAE;QACzC,OAAO,+BAA+B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACxD;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAClD;SAEI,IAAI,yBAAyB,CAAC,IAAI,CAAC,EAAE;QACzC,OAAO,+BAA+B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACxD;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,OAAO,2BAA2B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACpD;SAEI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,uBAAuB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAChD;SAEI,IAAI,wBAAwB,CAAC,IAAI,CAAC,EAAE;QACxC,OAAO,8BAA8B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACvD;SAEI,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;QAClC,OAAO,wBAAwB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACjD;SAEI,IAAI,yBAAyB,CAAC,IAAI,CAAC,EAAE;QACzC,OAAO,+BAA+B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACxD;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,OAAO,2BAA2B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACpD;SAEI,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,+BAA+B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACxD;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,OAAO,2BAA2B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACpD;SAEI,IAAI,oBAAoB,CAAC,IAAI,CAAC,EAAE;QACpC,OAAO,0BAA0B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACnD;SAEI,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;QAClC,OAAO,wBAAwB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACjD;SAEI,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;QAC7B,OAAO,mBAAmB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC5C;SAEI,IAAI,uBAAuB,CAAC,IAAI,CAAC,EAAE;QACvC,OAAO,6BAA6B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACtD;SAEI,IAAI,0BAA0B,CAAC,IAAI,CAAC,EAAE;QAC1C,OAAO,gCAAgC,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACzD;SAEI,IAAI,yBAAyB,CAAC,IAAI,CAAC,EAAE;QACzC,OAAO,+BAA+B,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACxD;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,uBAAuB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAChD;SAEI,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,qBAAqB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC9C;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAClD;SAEI,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;QAC9B,OAAO,oBAAoB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC7C;SAEI,IAAI,OAAO,CAAC,IAAI,CAAC,EAAE;QACvB,OAAO,aAAa,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACtC;SAEI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,uBAAuB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAChD;SAEI,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,qBAAqB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC9C;SAEI,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;QAC9B,OAAO,oBAAoB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC7C;SAEI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,uBAAuB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAChD;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;QAClC,OAAO,wBAAwB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KACjD;SAEI,IAAI,iBAAiB,CAAC,IAAI,CAAC,EAAE;QACjC,OAAO,uBAAuB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAChD;SAEI,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;QAC7B,OAAO,mBAAmB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC5C;SAEI,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,qBAAqB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC9C;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC/C;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAClD;IAED,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;;;ACpTvC;;;;AAIA,SAAgB,6BAA6B;IAC5C,OAAO,EAAE,CAAC;;;CACV,DCLD;;;;;AAKA,SAAgB,iBAAiB,CAAE,OAAqC;IACvE,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;;IAGrC,OAAO,CAAC,uBAAuB,GAAG,6BAA6B,EAAE,CAAC;IAElE,YAAY,CAAC,OAAO,CAAC,CAAC;;;CACtB,DCZD;;;;;AAKA,SAAgB,kBAAkB,CAAE,OAAsC;IACzE,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IACrC,MAAM,KAAK,GAAG,YAAY,CAAC,OAAO,CAAqB,CAAC;;IAGxD,IAAI,OAAO,CAAC,SAAS,CAAC,yBAAyB,IAAI,IAAI,EAAE;QACxD,OAAO,CAAC,SAAS,CAAC,yBAAyB,CAAC;YAC3C,IAAI,EAAE,OAAO,CAAC,IAAI;YAClB,KAAK;SACL,CAAC,CAAC;KACH;IAED,OAAO,KAAK,CAAC;;;CACb,DCnBD;;;;;AAKA,SAAgB,mBAAmB,CAAE,OAAuC;IAC3E,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAErC,YAAY,CAAC,OAAO,CAAC,CAAC;;;CACtB,DCRD;;;;;;AAMA,SAAgB,mBAAmB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAE,SAAS,EAAE,MAAM,EAAiC,EAAE,cAAuB;;IAEtK,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QACvB,uBAAuB,CAAC,EAAC,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,cAAc,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;QACvH,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,cAAc,EAAE,qBAAqB,CAAC,CAAC;KACpE;SAEI;QACJ,QAAQ,CAAC,gBAAgB,CAAC,IAAI,EAAE,WAAW,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAC;KACtF;;;CACD,DCVD;;;;;AAKA,SAAgB,8BAA8B,CAAE,EAA4H,EAAE,MAAoB;QAAlJ,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAE,SAAS,EAAE,KAAK,OAAqD,EAAnD,uGAAO;IAE/H,MAAM,UAAU,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;IAChH,MAAM,QAAQ,GAAG,eAAe,CAAC,IAAI,CAAC,CAAC;;;;;IAMvC,SAAS,sBAAsB,CAAiB,GAAG,IAAe;;QAGjE,MAAM,uBAAuB,GAAuB,uBAAuB,CAAC,WAAW,CAAC,CAAC;;QAGzF,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,aAAa,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;QAG9H,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;QAEhI,IAAI,IAAI,IAAI,IAAI,EAAE;YACjB,uBAAuB,CAAC,EAAC,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,WAAW,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;;YAG3H,uBAAuB,CAAC;gBACvB,GAAG,EAAE,uBAAuB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,QAAQ;sBAC9D,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC;sBAC3B,MAAM,CAAC,cAAc,CAAE,IAAiB,CAAC,WAAW,CAAC,CAAC,SAAS;gBAClE,UAAU,EAAE,IAAI;gBAChB,SAAS;gBACT,IAAI;aACJ,CAAC,CAAC;SACH;;QAGD,6BAA6B,iBAC3B,IAAI,EAAE,IAAI,CAAC,UAAU,EACrB,WAAW,EAAE,uBAAuB,EACpC,QAAQ;YACR,KAAK;YACL,uBAAuB;YACvB,SAAS,IACN,IAAI,GACL,IAAI,CACP,CAAC;;QAGF,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI;YAAE,OAAO;QAC9B,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;KACvD;IAED,sBAAsB,CAAC,QAAQ,GAAG,MAAM,SAAS,UAAU,GAAG,CAAC;IAE/D,IAAI,yBAAyB,GAAG,MAAM,CAAC,wBAAwB,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IACpF,IAAI,yBAAyB,IAAI,IAAI;QAAE,yBAAyB,GAAG,EAAE,CAAC;IAEtE,MAAM,CAAC,cAAc,CAAC,MAAM,EAAE,UAAU,kCACpC,yBAAyB,KAC5B,YAAY,EAAE,IAAI,EAClB,GAAG,EAAE,sBAAsB,IAC1B,CAAC;;;ACxEJ;;;;;;AAMA,SAAgB,0BAA0B,CAAE,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,uBAAuB,EAAwC,EAAE,MAAoB;IAC9J,MAAM,WAAW,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;IAEhG,MAAM,kBAAkB,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;IAExH,MAAM,CAAC,kBAAkB,CAAC,GAAG,WAAW,CAAC;;;ACX1C;;;;;;AAMA,SAAgB,4BAA4B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAAE,MAAM,EAA0C,EAAE,aAAsB;;IAG5K,MAAM,UAAU,GAAG,aAAa,IAAI,IAAI,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS;UACvE,aAAa;UACb,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;IAE/E,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,UAAU,EAAE,8BAA8B,CAAC,CAAC;IACnF,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,EAAE,uBAAuB,CAAC,CAAC;;;CACvF,DCbD;;;;;;AAMA,SAAgB,mCAAmC,CAAE,EAAC,WAAW,EAAE,IAAI,EAAiD,EAAE,MAAoB;IAC7I,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;IAClC,MAAM,KAAK,GAAG,yBAAyB,CAAC,IAAI,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IAEvE,IAAI,KAAK,IAAI,IAAI,EAAE;QAClB,MAAM,IAAI,wBAAwB,CAAC,EAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAC,CAAC,CAAC;KACtD;IAED,MAAM,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC;;;AChBpC;;;;;;AAMA,SAAgB,wBAAwB,CAAE,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,uBAAuB,EAAsC,EAAE,MAAoB;IAC1J,MAAM,OAAO,IAAI,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAiB,CAAC;IAC7G,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;;;ACRhC;;;;;;AAMA,SAAgB,2BAA2B,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAAyC,EAAE,cAAiC;IAC7K,MAAM,QAAQ,GAAG,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;IACnD,IAAI,cAAc,GAAG,CAAC,CAAC;IAEvB,OAAO,cAAc,GAAG,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;QAC7C,MAAM,EAAC,IAAI,EAAE,KAAK,EAAC,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;QACtC,IAAI,IAAI,KAAK,IAAI;YAAE,MAAM;QAEzB,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,cAAc,EAAE,CAAC,EAAE,WAAW,EAAE,KAAK,EAAE,uBAAuB,CAAC,CAAC;KACxG;;;CACD,DCfD;;;;;;AAMA,SAAgB,sBAAsB,CAAE,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,MAAM,EAAE,SAAS,EAAE,uBAAuB,EAAoC,EAAE,cAAuB;;IAE5K,MAAM,yBAAyB,GAAG,IAAI,CAAC,WAAW,IAAI,IAAI;UACvD,SAAS;UACT,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;IAG/E,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;;QAGzD,MAAM,SAAS,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;;QAGjC,MAAM,kBAAkB,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,YAAY,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;;QAGhI,MAAM,aAAa,GAAG,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC;cACrD,cAAc;cACb,cAA+B,CAAC,kBAAkB,CAAC,CAAC;;QAGxD,MAAM,oCAAoC,GAAG,aAAa,IAAI,IAAI;cAC/D,aAAa;cACb,yBAAyB,CAAC;QAE7B,uBAAuB,CAAC;YACvB,GAAG,EAAE,WAAW;YAChB,IAAI,EAAE,SAAS;YACf,KAAK,EAAE,oCAAoC;YAC3C,UAAU,EAAE,IAAI;YAChB,IAAI;YACJ,SAAS;SACT,CAAC,CAAC;KACH;;SAGI,IAAI,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;;QAG9D,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;;QAGlC,MAAM,aAAa,GAAG,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC;cACrD,cAAc;cACb,cAA+B,CAAC,UAAU,CAAC,CAAC;;QAGhD,MAAM,oCAAoC,GAAG,aAAa,IAAI,IAAI;cAC/D,aAAa;cACb,yBAAyB,CAAC;QAE7B,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,oCAAoC,CAAC,CAAC;QAExE,uBAAuB,CAAC;YACvB,GAAG,EAAE,WAAW;YAChB,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI;YACpB,KAAK,EAAE,oCAAoC;YAC3C,UAAU,EAAE,IAAI;YAChB,IAAI;YACJ,SAAS;SACT,CAAC,CAAC;KACH;;SAGI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;;QAE/D,MAAM,kBAAkB,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,YAAY,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;;QAGhI,MAAM,aAAa,GAAG,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC;cACrD,cAAc;cACb,cAA+B,CAAC,kBAAkB,CAAC,CAAC;;QAGxD,MAAM,oCAAoC,GAAG,aAAa,IAAI,IAAI;cAC/D,aAAa;cACb,yBAAyB,CAAC;;QAG7B,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,oCAAoC,EAAE,uBAAuB,CAAC,CAAC;KACjH;;SAGI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,IAAI,IAAI,EAAE;;QAG/D,MAAM,oCAAoC,GAAG,cAAc,IAAI,IAAI;cAChE,cAAc;cACd,yBAAyB,CAAC;QAE7B,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,oCAAoC,EAAE,uBAAuB,CAAC,CAAC;KACjH;;;AClGF;;;;;AAKA,SAAgB,4BAA4B,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,uBAAuB,EAA0C,EAAE,cAAuB;IACrK,KAAK,MAAM,OAAO,IAAI,IAAI,CAAC,QAAQ,EAAE;QACpC,QAAQ,CAAC,gBAAgB,CAAC,OAAO,EAAE,WAAW,EAAE,cAAc,EAAE,uBAAuB,CAAC,CAAC;KACzF;;;CACD,DCJD;;;;;;AAMA,SAAgB,iBAAiB,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,uBAAuB,EAA+B,EAAE,gBAAyB;;IAE5J,MAAM,gBAAgB,GAAG,uBAAuB,CAAC,WAAW,CAAC,CAAC;;IAE9D,uBAAuB,CAAC,EAAC,GAAG,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAC,CAAC,CAAC;IAEtH,KAAK,MAAM,MAAM,IAAI,IAAI,CAAC,OAAO,EAAE;QAClC,QAAQ,CAAC,gBAAgB,CAAC,MAAM,EAAE,gBAAgB,EAAE,gBAAgB,EAAE,uBAAuB,CAAC,CAAC;;QAG/F,IAAI,8BAA8B,CAAC,IAAI,EAAE,gBAAgB,EAAE,IAAI,EAAE,YAAY,EAAE,eAAe,EAAE,aAAa,CAAC,EAAE;YAC/G,MAAM;SACN;KACD;;;CACD,DCrBD;;;;;;AAMA,SAAgB,kBAAkB,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAAgC,EAAE,gBAAyB;IACnJ,MAAM,gBAAgB,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;;IAEpG,IAAI,gBAAgB,KAAK,gBAAgB;QAAE,OAAO;IAElD,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;QACxC,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;;QAG3C,IAAI,8BAA8B,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,YAAY,EAAE,eAAe,EAAE,aAAa,CAAC,EAAE;YAC1G,MAAM;SACN;KACD;;;CACD,DCpBD;;;;AAIA,SAAgB,qBAAqB,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAmC;IAErG,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;QACxC,QAAQ,CAAC,SAAS,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;;QAG3C,IAAI,8BAA8B,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,YAAY,EAAE,eAAe,EAAE,aAAa,CAAC,EAAE;YAC1G,MAAM;SACN;KACD;;;CACD,DCjBD;;;;;AAKA,SAAgB,mBAAmB,CAAE,EAAC,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAAiC,EAAE,EAAS;;IAErI,MAAM,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,IAAI,IAAI,GAAG,WAAW,GAAG,uBAAuB,CAAC,WAAW,CAAC,CAAC;;IAG/G,IAAI,IAAI,CAAC,mBAAmB,IAAI,IAAI,EAAE;QACrC,QAAQ,CAAC,gBAAgB,CAAC,IAAI,CAAC,mBAAmB,EAAE,gBAAgB,EAAE,EAAE,EAAE,uBAAuB,CAAC,CAAC;KACnG;;IAGD,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;;;AChBlD;;;;;AAKA,SAAgB,yBAAyB,CAAE,QAA8C;IACxF,OAAO,SAAS,CAAC;;;CACjB,DCJD;;;;;;;AAOA,SAAgB,iBAAiB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,KAAK,EAAE,uBAAuB,EAA+B,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,KAAK,CAAmC;IAC9L,MAAM,uBAAuB,GAAG,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC;IAE3G,IAAI,OAAO,uBAAuB,KAAK,UAAU,EAAE;QAClD,MAAM,IAAI,gBAAgB,CAAC,EAAC,IAAI,EAAE,KAAK,EAAE,uBAAuB,EAAE,OAAO,EAAE,GAAG,gBAAgB,CAAC,uBAAuB,CAAC,2CAA2C,EAAC,CAAC,CAAC;KACrK;IAED,KAAK,CAAC,IAAI,CACT,UAAU,CAAC;QACV,KAAK,IAAI,IAAI;cACV,OAAO,CAAC,KAAK,EAAE,uBAAuB,CAAC;cACvC,uBAAuB;KAC1B,EAAE,MAAM,EAAE,YAAY,CAAC,CACxB,CAAC;;;ACtBH;;;;;AAKA,SAAgB,kBAAkB,CAAE,EAAC,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,WAAW,EAAE,uBAAuB,EAAgC,EAAE,MAAoB;IAC3J,MAAM,aAAa,GAAG,WAAW,CAAC,gBAAgB,CAAC,IAAI,CAAkB,CAAC;IAC1E,MAAM,YAAY,IAAI,QAAQ,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAoB,CAAC;;IAGlH,IAAI,OAAO,aAAa,KAAK,QAAQ,EAAE;QACtC,MAAM,CAAC,YAAY,CAAC,GAAG,aAAa,CAAC;KACrC;SAEI;QACJ,MAAM,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,aAAa,CAAC,GAAG,YAAY,CAAC;KAC5D;;;CACD,DCID;;;;;;AAMA,SAAgB,wBAAwB,CAAE,OAAgC,EAAE,GAAY;IACvF,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;IACzD,MAAM,EAAC,IAAI,KAAa,OAAO,EAAlB,gCAAkB,CAAC;IAEhC,IAAI,wBAAwB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,8BAA8B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KAC5E;SAEI,IAAI,wBAAwB,CAAC,IAAI,CAAC,EAAE;QACxC,OAAO,8BAA8B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KAC5E;SAEI,IAAI,oBAAoB,CAAC,IAAI,CAAC,EAAE;QACpC,OAAO,0BAA0B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KACxE;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,OAAO,2BAA2B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KACzE;SAEI,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;QAC3B,OAAO,4BAA4B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAG,CAAC,CAAC;KAC1D;SAEI,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QAC5B,OAAO,kBAAkB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KAChE;SAEI,IAAI,6BAA6B,CAAC,IAAI,CAAC,EAAE;QAC7C,OAAO,mCAAmC,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KACjF;SAEI,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;QAC3B,OAAO,iBAAiB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAA8B,CAAC,CAAC;KAC1E;SAEI,IAAI,kBAAkB,CAAC,IAAI,CAAC,EAAE;QAClC,OAAO,wBAAwB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KACtE;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAmB,CAAC,CAAC;KACvE;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,OAAO,2BAA2B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAwB,CAAC,CAAC;KAC9E;SAEI,IAAI,gBAAgB,CAAC,IAAI,CAAC,EAAE;QAChC,OAAO,sBAAsB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAG,CAAC,CAAC;KACpD;SAEI,IAAI,sBAAsB,CAAC,IAAI,CAAC,EAAE;QACtC,OAAO,4BAA4B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAG,CAAC,CAAC;KAC1D;SAEI,IAAI,qBAAqB,CAAC,IAAI,CAAC,EAAE;QACrC,OAAO,2BAA2B,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAG,CAAC,CAAC;KACzD;SAEI,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;QAC3B,OAAO,iBAAiB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAG,CAAC,CAAC;KAC/C;SAEI,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;QAC5B,OAAO,kBAAkB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAG,CAAC,CAAC;KAChD;SAEI,IAAI,eAAe,CAAC,IAAI,CAAC,EAAE;QAC/B,OAAO,qBAAqB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC9C;SAEI,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;QAC7B,OAAO,mBAAmB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAY,CAAC,CAAC;KAC1D;SAEI,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;QAC7B,OAAO,mBAAmB,iBAAE,IAAI,IAAK,IAAI,GAAG,GAAG,CAAC,CAAC;KACjD;SAEI,IAAI,mBAAmB,CAAC,IAAI,CAAC,EAAE;QACnC,OAAO,yBAAyB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAClD;IAED,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;;;CACtC,DChHD;;;;;AAKA,SAAgB,oBAAoB,CAAE,EAAC,WAAW,EAAE,IAAI,EAAE,QAAQ,EAAE,uBAAuB,EAAkC;IAC5H,QACC,sBAAsB,CAAC,IAAI,CAAC;UACzB,QAAQ,CAAC,UAAU,CAAC,IAAI,CAAC,UAAU,EAAE,WAAW,EAAE,uBAAuB,CAAC;UAC1E,YAAY,CAAC,IAAI,CAAC;cAClB,IAAI,CAAC,IAAI;cACT,QAAQ,CAAC,UAAU,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,EAC9C;;;CACrB,DCVD;;;;;AAKA,SAAgB,qBAAqB,CAAE,OAAyC;IAC/E,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,eAAe,CAAC,CAAC;IACtD,MAAM,EAAC,IAAI,KAAa,OAAO,EAAlB,gCAAkB,CAAC;IAEhC,IAAI,cAAc,CAAC,IAAI,CAAC,EAAE;QACzB,OAAO,oBAAoB,iBAAE,IAAI,IAAK,IAAI,EAAE,CAAC;KAC7C;IAED,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;;;CACtC,DCjBD;;;;;;AAMA,SAAgB,WAAW,CAAE,SAAoC,EAAE,KAAY,EAAE,IAAU;;IAE1F,IAAI,SAAS,CAAC,YAAY,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QAC7E,SAAS,CAAC,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACtC,SAAS,CAAC,YAAY,CAAC;YACtB,KAAK,EAAE,KAAK;YACZ,IAAI,EAAE,KAAK,YAAY,eAAe;kBACnC,KAAK,CAAC,IAAI;kBACV,IAAI;SACP,CAAC,CAAC;KACH;;;CACD,DCLD;;;;;AAKA,SAAgB,mBAAmB,CAAE,EAAC,WAAW,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,QAAQ,EAA8B;IAC1H,IAAI,GAAG,GAAG,CAAC,CAAC;IAEZ,MAAM,aAAa,GAAG,CAAC,IAAU,EAAE,uBAAgD;QAClF,QAAQ,CAAC,IAAI,CAAC,CAAC;;QAGf,GAAG,EAAE,CAAC;;QAGN,IAAI,GAAG,IAAI,MAAM,CAAC,MAAM,EAAE;YACzB,MAAM,IAAI,mBAAmB,CAAC,EAAC,GAAG,EAAE,IAAI,EAAC,CAAC,CAAC;SAC3C;;QAGD,uBAAuB,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxC,IAAI,SAAS,CAAC,eAAe,IAAI,IAAI,EAAE;YACtC,SAAS,CAAC,eAAe,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;SAClC;KACD,CAAC;;;;;;;IAQF,MAAM,sBAAsB,GAAG,CAAC,WAA+B,EAAE,IAAU,EAAE,MAAgB;;QAE5F,IAAI,8BAA8B,CAAC,IAAI,EAAE,WAAW,EAAE,IAAI,EAAE,UAAU,CAAC,EAAE;YACxE,OAAO,MAAM,EAAE,CAAC;SAChB;QAED,IAAI;YACH,OAAO,MAAM,EAAE,CAAC;SAChB;QAAC,OAAO,EAAE,EAAE;;YAEZ,WAAW,CAAC,SAAS,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;;YAGjC,MAAM,EAAE,CAAC;SACT;KACD,CAAC;IAEF,MAAM,aAAa,GAAkB;QACpC,UAAU,EAAE,CAAC,IAAgB,EAAE,WAA+B,EAAE,uBAAgD;YAC/G,OAAO,sBAAsB,CAAC,WAAW,EAAE,IAAI,EAAE;gBAChD,aAAa,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;gBAC7C,OAAO,kBAAkB,CAAC,mBAAmB,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC,CAAC;aAC3F,CAAC,CAAC;SACH;QACD,SAAS,EAAE,CAAC,IAAe,EAAE,WAA+B;YAC3D,OAAO,sBAAsB,CAAC,WAAW,EAAE,IAAI,EAAE;gBAChD,MAAM,uBAAuB,GAAG,6BAA6B,EAAE,CAAC;gBAChE,aAAa,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;gBAC7C,OAAO,iBAAiB,CAAC,mBAAmB,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC,CAAC;aAC1F,CAAC,CAAC;SACH;QACD,WAAW,EAAE,CAAC,IAAiB,EAAE,WAA+B,EAAE,uBAAgD;YACjH,OAAO,sBAAsB,CAAC,WAAW,EAAE,IAAI,EAAE;gBAChD,aAAa,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;gBAC7C,OAAO,mBAAmB,CAAC,mBAAmB,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC,CAAC;aAC5F,CAAC,CAAC;SACH;QACD,gBAAgB,EAAE,CAAC,IAAU,EAAE,WAA+B,EAAE,GAAY,EAAE,uBAAgD;YAC7H,OAAO,sBAAsB,CAAC,WAAW,EAAE,IAAI,EAAE;gBAChD,aAAa,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;gBAC7C,OAAO,wBAAwB,CAAC,mBAAmB,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,EAAE,GAAG,CAAC,CAAC;aACtG,CAAC,CAAC;SACH;QACD,aAAa,EAAE,CAAC,IAAmB,EAAE,WAA+B,EAAE,uBAAgD;YACrH,OAAO,sBAAsB,CAAC,WAAW,EAAE,IAAI,EAAE;gBAChD,aAAa,CAAC,IAAI,EAAE,uBAAuB,CAAC,CAAC;gBAC7C,OAAO,qBAAqB,CAAC,mBAAmB,CAAC,IAAI,EAAE,WAAW,EAAE,uBAAuB,CAAC,CAAC,CAAC;aAC9F,CAAC,CAAC;SACH;KACD,CAAC;;;;;;;;IASF,SAAS,mBAAmB,CAAkB,IAAO,EAAE,WAA+B,EAAE,uBAAgD;QACvI,OAAO;YACN,WAAW;YACX,MAAM;YACN,SAAS;YACT,IAAI;YACJ,QAAQ,EAAE,aAAa;YACvB,WAAW;YACX,KAAK;YACL,MAAM;YACN,uBAAuB;SACvB,CAAC;KACF;IAED,OAAO,aAAa,CAAC;;;CACrB,DCvHD;;;;;AAKA,SAAgB,mBAAmB,CAAE,IAAgB;IACpD,IAAI,IAAI,KAAK,UAAU,CAAC,cAAc;QAAE,OAAO,gBAAgB,CAAC;IAChE,OAAO,UAAU,CAAC,IAAI,CAAC,CAAC;;;CACxB,DCDD;;;AAGA,MAAa,MAAM;IAElB,YAA6B,QAAsB;QAAtB,aAAQ,GAAR,QAAQ,CAAc;KAClD;;;;;;IAOM,OAAO,CAAE,OAAe;QAC9B,IAAI,IAAI,CAAC,QAAQ;YAAsB,OAAO;QAC9C,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;KACrB;;;;;;IAOM,UAAU,CAAE,OAAe;QACjC,IAAI,IAAI,CAAC,QAAQ;YAAyB,OAAO;QACjD,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;KACrB;;;;;;IAOM,QAAQ,CAAE,OAAe;QAC/B,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAC/C,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;KACrB;;;;;IAMM,WAAW,CAAE,IAAU;QAC7B,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAC/C,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,UAAU,CAAC,uBAAuB,KAAK,CAAC,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;KAC9G;;;;;IAMM,QAAQ,CAAE,IAAU;QAC1B,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAC/C,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,uBAAuB,KAAK,CAAC,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;KAC3G;;;;;IAMM,SAAS,CAAE,IAAU;QAC3B,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAC/C,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,uBAAuB,KAAK,CAAC,MAAM,CAAC,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;KAC5G;;;;;;IAOM,SAAS,CAAE,MAAe,EAAE,mBAA4B;QAC9D,IAAI,IAAI,CAAC,QAAQ;YAAsB,OAAO;QAC9C,IAAI,mBAAmB,IAAI,IAAI,EAAE;YAChC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,qCAAqC,mBAAmB,MAAM,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC;SAC7I;;YACI,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,KAAK,CAAC,WAAW,CAAC,EAAE,MAAM,CAAC,CAAC;KACnD;;;;;;IAOM,OAAO,CAAE,IAAU,EAAE,OAAgB;QAC3C,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAE/C,IAAI,OAAO,GAAG,IAAI,mBAAmB,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAC/D,IAAI,OAAO,IAAI,IAAI;YAAE,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,OAAO,GAAG,CAAC,CAAC;QAC3D,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QAE/B,MAAM,IAAI,GAAG,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACnC,MAAM,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEjC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAClB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KAClB;;;;;;;IAQM,UAAU,CAAE,MAAc,EAAE,MAAe,EAAE,KAAc;QACjE,IAAI,IAAI,CAAC,QAAQ;YAAyB,OAAO;QACjD,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,IAAI,IAAI,GAAG,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC;KACrH;;;;;IAMM,WAAW,CAAE,gBAA0B;QAC7C,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAC/C,MAAM,MAAM,GAAG,MAAM,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;QACvD,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;YACzC,OAAO,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,EAAE,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC;SACtH;KACD;;;;;IAMM,QAAQ,CAAE,KAAY;QAC5B,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAC/C,OAAO,CAAC,GAAG,CAAC,gBAAgB,KAAK,CAAC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;KAC/F;;;;;;IAOM,0BAA0B,CAAE,KAA8B;QAChE,IAAI,IAAI,CAAC,QAAQ;YAAuB,OAAO;QAC/C,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,KAAK,CAAC,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;KACxF;;;;;;IAOO,YAAY,CAAK,KAAQ;QAChC,OAAO,OAAO,CAAC,KAAK,EAAE,EAAC,KAAK,EAAE,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE,CAAC,EAAC,CAAC,CAAC;KAClF;;;CACD,DC1JD;;;;;;AAMA,SAAgB,YAAY,CAAE,IAAa;IAC1C,OAAQA,gBAAgF,CAAC,IAAI,CAAC,IAAIC,YAAe,CAAC,IAAI,CAAC,CAAC;;;CACxH,DCRD;;;;;;AAMA,SAAgB,WAAW,CAAE,IAAa;IACzC,OAAQC,4BAAsG,CAAC,IAAI,CAAC,CAAC;;;ACGtH;;;;AAIA,SAAgB,WAAW;IAC1B,MAAM,KAAK,GAAiB,EAAE,CAAC;IAE/B,OAAO;;;;;QAKN,CAAC,MAAM,CAAC,QAAQ,CAAC;YAChB,OAAO,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC;SAChC;;;;;QAMD,IAAI,MAAM;YACT,OAAO,KAAK,CAAC,MAAM,CAAC;SACpB;;;;;QAMD,IAAI,QAAQ;YACX,OAAO,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAC/B;;;;;;QAOD,IAAI,CAAE,GAAG,MAAoB;YAC5B,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC;SAC7B;;;;;QAMD,GAAG;YACF,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC;SACnB;KACD,CAAC;;;CACF,DC3DD;;;;;;AAMA,SAAgB,aAAa,CAAE,IAAa;IAC3C,OAAQC,eAAwE,CAAC,IAAI,CAAC,CAAC;;;ACPxF;;;;AAIA,SAAgB,sBAAsB;IACrC,OAAO,IAAI,OAAO,EAAS,CAAC;;;CAC5B,DCaD;;;;;AAKA,SAAgB,QAAQ,CAAE,EACZ,WAAW,EACX,IAAI,EACJ,WAAW,EAAE,EACZ,MAAM,GAAG,qBAAqB,CAAC,IAAI,EACnC,KAAK,GAAG,EAAE,EACV,GAAG,EAAE,EACN,QAAQ,mBACR,MAAM,EAAE,EACP,aAAa,GAAG,KAAK,EACrB,OAAO,GAAG,KAAK,EACf,OAAO,GAAG,KAAK,EACf,MAAM,GAAG,QAAQ,EACjB,aAAa,GAAG,QAAQ,EACxB,EAAE,GAAG;IACJ,IAAI,EAAE,IAAI;IACV,KAAK,EAAE,KAAK;CACZ,EACD,OAAO,GAAG;IACT,IAAI,EAAE,KAAK;IACX,UAAU,EAAE,KAAK;CACjB,EACD,GAAG,EAAE,EACN,SAAS,EAAE,cAAc,GAAG,EAAE,EACZ;;IAE/B,MAAM,mBAAmB,GAAG,qBAAqB,CAAC,IAAI,CAAC,CAAC;IACxD,IAAI,mBAAmB,CAAC,OAAO;QAAE,OAAO,mBAAmB,CAAC;;;IAI5D,MAAM,MAAM,GAA6B;QACxC,aAAa;QACb,MAAM;QACN,aAAa;QACb,OAAO;QACP,OAAO;QACP,EAAE,EAAE;YACH,IAAI,EAAE,OAAO,EAAE,KAAK,SAAS,GAAG,EAAE,GAAG,EAAE,CAAC,IAAI;YAC5C,KAAK,EAAE,OAAO,EAAE,KAAK,SAAS,GAAG,EAAE,GAAG,EAAE,CAAC,KAAK;SAC9C;QACD,OAAO,EAAE;YACR,IAAI,EAAE,OAAO,OAAO,KAAK,SAAS,GAAG,OAAO,GAAG,OAAO,CAAC,IAAI;YAC3D,UAAU,EAAE,OAAO,OAAO,KAAK,SAAS,GAAG,OAAO,GAAG,OAAO,CAAC,UAAU;SACvE;KACD,CAAC;;IAGF,MAAM,SAAS,mCACX,cAAc,KACjB,gBAAgB,EAAE,sBAAsB,EAAE,GAC1C,CAAC;;IAGF,IAAI,WAAW,GAAS,IAAI,CAAC;;IAG7B,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC;;IAGpC,MAAM,kBAAkB,GAAG,wBAAwB,CAAC;QACnD,gBAAgB,EAAE;YACjB,MAAM;YACN,KAAK;SACL;QACD,MAAM;QACN,cAAc,EAAE,MAAM,WAAW;KACjC,CAAC,CAAC;;IAGH,MAAM,KAAK,GAAU,WAAW,EAAE,CAAC;;IAGnC,MAAM,aAAa,GAAG,mBAAmB,CAAC;QACzC,MAAM;QACN,WAAW;QACX,MAAM;QACN,KAAK;QACL,SAAS,EAAE,SAAS;QACpB,QAAQ,EAAE,QAAQ,IAAI,WAAW,GAAG,QAAQ;KAC5C,CAAC,CAAC;IAEH,IAAI;QACH,IAAI,KAAc,CAAC;QACnB,IAAI,YAAY,CAAC,IAAI,CAAC,EAAE;YACvB,KAAK,GAAG,aAAa,CAAC,UAAU,CAAC,IAAI,EAAE,kBAAkB,EAAE,6BAA6B,EAAE,CAAC,CAAC;SAC5F;aAEI,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;YAC3B,aAAa,CAAC,SAAS,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;YAClD,KAAK,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;SACpB;aAEI,IAAI,aAAa,CAAC,IAAI,CAAC,EAAE;YAC7B,aAAa,CAAC,WAAW,CAAC,IAAI,EAAE,kBAAkB,EAAE,6BAA6B,EAAE,CAAC,CAAC;YACrF,KAAK,GAAG,KAAK,CAAC,GAAG,EAAE,CAAC;SACpB;;aAGI;;YAEJ,MAAM,IAAI,mBAAmB,CAAC,EAAC,IAAI,EAAC,CAAC,CAAC;SACtC;;QAGD,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;QAExB,OAAO;YACN,OAAO,EAAE,IAAI;YACb,KAAK;SACL,CAAC;KACF;IAAC,OAAO,MAAM,EAAE;;QAEhB,WAAW,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;QAErC,OAAO;YACN,OAAO,EAAE,KAAK;YACd,MAAM;SACN,CAAC;KACF;;;;;"}