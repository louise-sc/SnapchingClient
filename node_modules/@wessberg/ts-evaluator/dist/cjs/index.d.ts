import { Node, Expression, Identifier, Declaration, TryStatement, Statement, TypeChecker } from "typescript";
declare type Literal = object | Function | string | number | boolean | symbol | bigint | null | undefined;
interface IndexLiteral {
    [key: string]: Literal;
}
interface IEvaluateIOPolicy {
    read: boolean;
    write: boolean;
}
interface IEvaluateProcessPolicy {
    exit: boolean;
    spawnChild: boolean;
}
interface IEvaluatePolicy {
    io: boolean | IEvaluateIOPolicy;
    process: boolean | IEvaluateProcessPolicy;
    network: boolean;
    console: boolean;
    deterministic: boolean;
    maxOps: number;
    maxOpDuration: number;
}
interface IEvaluatePolicySanitized {
    io: IEvaluateIOPolicy;
    process: IEvaluateProcessPolicy;
    network: boolean;
    console: boolean;
    deterministic: boolean;
    maxOps: number;
    maxOpDuration: number;
}
declare const enum PolicyTrapKind {
    GET = "__$$_PROXY_GET",
    APPLY = "__$$_PROXY_APPLY",
    CONSTRUCT = "__$$_PROXY_CONSTRUCT"
}
declare type TrapConditionFunction<ConditionType> = (...args: unknown[]) => ConditionType;
declare type TrapCondition<ConditionType> = ConditionType | TrapConditionFunction<ConditionType>;
declare type PolicyTrapKindToTrapConditionMap<ConditionType> = {
    [key in PolicyTrapKind]?: TrapCondition<ConditionType>;
};
declare type TrapConditionMemberMap<T, ConditionType> = {
    [Key in keyof T]?: TrapConditionMapValue<T[Key], ConditionType>;
};
declare type TrapConditionMapValue<T, ConditionType> = TrapCondition<ConditionType> | TrapConditionMemberMap<T, ConditionType> | PolicyTrapKindToTrapConditionMap<ConditionType> | undefined;
interface IEvaluationErrorOptions {
    node: Node;
    message?: string;
}
interface INonDeterministicErrorOptions extends IEvaluationErrorOptions {
    operation: string;
}
/**
 * A Base class for EvaluationErrors
 */
declare class EvaluationError extends Error {
    /**
     * The node that caused or thew the error
     */
    readonly node: Node;
    constructor({ node, message }: IEvaluationErrorOptions);
}
interface IPolicyErrorOptions extends IEvaluationErrorOptions {
    violation: keyof IEvaluatePolicySanitized;
}
/**
 * An Error that can be thrown when a policy is violated
 */
declare class PolicyError extends EvaluationError {
    /**
     * The kind of policy violation encountered
     * @type {string}
     */
    readonly violation: keyof IEvaluatePolicySanitized;
    constructor({ violation, node, message }: IPolicyErrorOptions);
}
/**
 * An Error that can be thrown when something nondeterministic is attempted to be evaluated and has been disallowed to be so
 */
declare class NonDeterministicError extends PolicyError {
    /**
     * The kind of operation that was attempted to be performed but was in violation of the policy
     * @type {string}
     */
    readonly operation: string;
    constructor({ operation, node, message }: INonDeterministicErrorOptions);
}
interface IIoErrorOptions extends IEvaluationErrorOptions {
    kind: keyof IEvaluateIOPolicy;
}
/**
 * An Error that can be thrown when an IO operation is attempted to be executed that is in violation of the context policy
 */
declare class IoError extends PolicyError {
    /**
     * The kind of IO operation that was violated
     * @type {keyof IEvaluateIOPolicy}
     */
    readonly kind: keyof IEvaluateIOPolicy;
    constructor({ node, kind, message }: IIoErrorOptions);
}
interface INetworkErrorOptions extends IEvaluationErrorOptions {
    operation: string;
}
/**
 * An Error that can be thrown when a network operation is attempted to be executed that is in violation of the context policy
 */
declare class NetworkError extends PolicyError {
    /**
     * The kind of operation that was attempted to be performed but was in violation of the policy
     * @type {string}
     */
    readonly operation: string;
    constructor({ operation, node, message }: INetworkErrorOptions);
}
interface IProcessErrorOptions extends IEvaluationErrorOptions {
    kind: keyof IEvaluateProcessPolicy;
}
/**
 * An Error that can be thrown when a Process operation is attempted to be executed that is in violation of the context policy
 */
declare class ProcessError extends PolicyError {
    /**
     * The kind of process operation that was violated
     * @type {keyof IEvaluateProcessPolicy}
     */
    readonly kind: keyof IEvaluateProcessPolicy;
    constructor({ kind, node, message }: IProcessErrorOptions);
}
declare enum EnvironmentPresetKind {
    NONE = "NONE",
    ECMA = "ECMA",
    BROWSER = "BROWSER",
    NODE = "NODE"
}
interface IBindingReportEntry {
    path: string;
    value: unknown;
    node: Node;
}
interface ITraversalReportEntry {
    node: Node;
}
interface IIntermediateResultReportEntry {
    node: Expression;
    value: unknown;
}
interface IErrorReportEntry {
    node: Node;
    error: Error;
}
declare type BindingReportCallback = (entry: IBindingReportEntry) => void | (Promise<void>);
declare type ErrorReportCallback = (entry: IErrorReportEntry) => void | (Promise<void>);
declare type IntermediateResultReportCallback = (entry: IIntermediateResultReportEntry) => void | (Promise<void>);
declare type TraversalReportCallback = (entry: ITraversalReportEntry) => void | (Promise<void>);
interface IReportingOptions {
    reportBindings: BindingReportCallback;
    reportTraversal: TraversalReportCallback;
    reportIntermediateResults: IntermediateResultReportCallback;
    reportErrors: ErrorReportCallback;
}
declare type ReportingOptions = Partial<IReportingOptions>;
interface IEnvironment {
    preset: EnvironmentPresetKind;
    extra: LexicalEnvironment["env"];
}
interface LexicalEnvironment {
    parentEnv: LexicalEnvironment | undefined;
    env: IndexLiteral;
    preset?: EnvironmentPresetKind;
}
interface IMaxOpsExceededErrorOptions extends IEvaluationErrorOptions {
    ops: number;
}
/**
 * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded
 */
declare class MaxOpsExceededError extends PolicyError {
    /**
     * The amount of operations performed before creating this error instance
     */
    readonly ops: number;
    constructor({ ops, node, message }: IMaxOpsExceededErrorOptions);
}
declare const enum LogLevelKind {
    SILENT = 0,
    INFO = 10,
    VERBOSE = 20,
    DEBUG = 30
}
interface IUnexpectedNodeErrorOptions extends IEvaluationErrorOptions {
}
/**
 * An Error that can be thrown when an unexpected node is encountered
 */
declare class UnexpectedNodeError extends EvaluationError {
    constructor({ node, message }: IUnexpectedNodeErrorOptions);
}
interface IUndefinedLeftValueErrorOptions extends IEvaluationErrorOptions {
}
/**
 * An Error that can be thrown when an undefined leftValue is encountered
 */
declare class UndefinedLeftValueError extends EvaluationError {
    constructor({ node, message }: IUndefinedLeftValueErrorOptions);
}
interface INotCallableErrorOptions extends IEvaluationErrorOptions {
    value: Literal;
}
/**
 * An Error that can be thrown when a value is attempted to be called, but isn't callable
 */
declare class NotCallableError extends EvaluationError {
    /**
     * The non-callable value
     * @type {Literal}
     */
    readonly value: Literal;
    constructor({ value, node, message }: INotCallableErrorOptions);
}
interface IUndefinedIdentifierErrorOptions extends IEvaluationErrorOptions {
    node: Identifier;
}
/**
 * An Error that can be thrown when an undefined identifier is encountered
 */
declare class UndefinedIdentifierError extends EvaluationError {
    /**
     * The identifier that is undefined in the context that created this error
     * @type {Identifier}
     */
    readonly node: Identifier;
    constructor({ node, message }: IUndefinedIdentifierErrorOptions);
}
interface IModuleNotFoundErrorOptions extends IEvaluationErrorOptions {
    path: string;
}
/**
 * An Error that can be thrown when a moduleSpecifier couldn't be resolved
 */
declare class ModuleNotFoundError extends EvaluationError {
    /**
     * The path/moduleName that could not be resolved
     * @type {string}
     */
    readonly path: string;
    constructor({ path, node, message }: IModuleNotFoundErrorOptions);
}
interface IAsyncNotSupportedErrorOptions extends Omit<IEvaluationErrorOptions, "node"> {
}
/**
 * An Error that can be thrown when an async operation is attempted but can't be computed
 */
declare class AsyncNotSupportedError extends EvaluationError {
    constructor({ message }: IAsyncNotSupportedErrorOptions);
}
interface IMissingCatchOrFinallyAfterTryErrorOptions extends IEvaluationErrorOptions {
    node: TryStatement;
}
/**
 * An Error that can be thrown when a TryStatement is encountered without neither a catch {...} nor a finally {...} block
 */
declare class MissingCatchOrFinallyAfterTryError extends EvaluationError {
    /**
     * The TryStatement that lacks a catch/finally block
     * @type {TryStatement}
     */
    readonly node: TryStatement;
    constructor({ node, message }: IMissingCatchOrFinallyAfterTryErrorOptions);
}
interface IMaxOpDurationExceededErrorOptions extends IEvaluationErrorOptions {
    duration: number;
}
/**
 * An Error that can be thrown when the maximum amount of operations dictated by the policy is exceeded
 */
declare class MaxOpDurationExceededError extends PolicyError {
    /**
     * The total duration of an operation that was being performed before exceeding the limit
     */
    readonly duration: number;
    constructor({ duration, node, message }: IMaxOpDurationExceededErrorOptions);
}
interface IEvaluateOptions {
    node: Statement | Declaration | Expression;
    typeChecker: TypeChecker;
    environment?: Partial<IEnvironment>;
    logLevel?: LogLevelKind;
    policy?: Partial<IEvaluatePolicy>;
    reporting?: ReportingOptions;
}
interface IEvaluateResultBase {
    success: boolean;
}
interface IEvaluateSuccessResult extends IEvaluateResultBase {
    success: true;
    value: unknown;
}
interface IEvaluateFailureResult extends IEvaluateResultBase {
    success: false;
    reason: EvaluationError;
}
declare type EvaluateResult = IEvaluateSuccessResult | IEvaluateFailureResult;
/**
 * Will get a literal value for the given Expression, ExpressionStatement, or Declaration.
 * @param {IEvaluateOptions} options
 * @returns {Promise<EvaluateResult>}
 */
declare function evaluate({ typeChecker, node, environment: { preset, extra }, logLevel, policy: { deterministic, network, console, maxOps, maxOpDuration, io, process }, reporting: reportingInput }: IEvaluateOptions): EvaluateResult;
export { evaluate, EvaluateResult, IEvaluateOptions, LogLevelKind, EnvironmentPresetKind, IEnvironment, EvaluationError, MissingCatchOrFinallyAfterTryError, ModuleNotFoundError, NotCallableError, PolicyError, UndefinedIdentifierError, UndefinedLeftValueError, UnexpectedNodeError, IoError, MaxOpsExceededError, MaxOpDurationExceededError, NetworkError, NonDeterministicError, ProcessError, AsyncNotSupportedError, BindingReportCallback, IReportingOptions, ReportingOptions };
